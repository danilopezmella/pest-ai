# Stream Debug - 20250206_015343

# Original Question
```
What is noptmax?
```

# Context Content
```markdown
# Search Results for: What is noptmax?

Keywords: noptmax

## Variations
1. What does noptmax refer to?
2. Can you explain what noptmax is?
3. Could you describe what noptmax means?
4. What is the definition of noptmax?
5. Please clarify what noptmax is.


## Context

### Summary
**The utility software uses Equation 11.1.10 (Tk=0) for regularization; Equation 11.1.11 (Tk=j) is not supported.  Initial parameter values should reflect expert knowledge. For SVD-assisted inversion, use a Z matrix (case.jco) calculated using optimized parameters (PARREP, NOPTMAX=-1 or -2) for the resolution matrix calculation (Equation 11.1.9a).  The Z matrix refers to base, not super, parameters.**

### Header
**11.1.3 Some Special Considerations**

### Content
Regularisation Relationships
As mentioned above, where Tikhonov regularisation is employed it is assumed to be of the type
Tk = 0 (11.1.10)
In PEST, regularisation can be linear (supplied through prior information equations), or nonlinear (supplied as observations). In both cases these are identified as regularisation relationships through being assigned to an observation group whose name begins with “regul”. However, PEST also allows regularisation relationships of the following type to be supplied
Tk = j (11.1.11)
Calculation of the resolution matrix, as implemented in the utility software described below, cannot accommodate relationships of the type expressed by equation 11.1.11. In most cases, equation 11.1.11 can be transformed to equation 11.1.10 by appropriate parameter re-definition.
Initial Parameter Values
When using truncated singular value decomposition or SVD‑assisted inversion, the integrity of the predictive error variance analysis process requires that initial parameter estimates (provided in the “parameter data” section of the PEST control file) correspond to most likely parameters according to a user’s concept of parameter likelihood based on the current modelling context and the characteristics of the modelled area. That is, they constitute “minimum error variance” estimates of parameter values based on expert knowledge alone.
The Z Matrix in SVD-Assisted Inversion
As mentioned above, the Z matrix appearing in equation 11.1.9a provides the sensitivities of model outputs for which there are corresponding field measurements to base parameters. In SVD‑assisted inversion these can far outnumber super parameters; computation of the Z matrix can therefore be costly. Nevertheless, as described in part I of this manual, this matrix must be calculated (based on initial parameter values) prior to undertaking SVD‑assisted inversion, and so should be available for calculation of the resolution matrix upon completion of the SVD‑assisted parameter estimation process. A better matrix to use in equation 11.1.9a however is a Z matrix calculated on the basis of optimised parameter values. Thus, after an SVD‑assisted PEST run is complete, the PARREP utility can be used to build a new base PEST control file using optimised base parameter values. NOPTMAX can be set to ‑1 or ‑2 in this new file so that when PEST is run, it terminates execution as soon as the Jacobian matrix is filled. The resulting JCO file will then hold the Z matrix of base parameter sensitivities, calculated using optimised parameter values.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 11. Linear Error and Uncertainty – Part II
- **Subsection:** 11.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** This chapter details utilities calculating R (resolution matrix) and G (parameter solution matrix) using case.jco (updated per improved parameter set, except for SVD-assist).  Equations for R and G are given for overdetermined systems (Equations 11.1.6a, 11.1.6b), Tikhonov regularization (Equations 11.1.7a, 11.1.7b), SVD (Equations 11.1.8a, 11.1.8b), and SVD-assist (Equations 11.1.9a, 11.1.9b).  Results apply to base (not super) parameters and their logs (for log-transformed parameters).  LSQR is not accommodated.
- **Next Summary:** IRES (0 or 1, default 1 for regularization or SVD) in the "control data" section controls creation of the binary resolution data file (case.rsd).  PEST deletes existing case.rsd files before creating a new one.  case.rsd (used by RESPROC) is updated whenever parameter estimates improve; it's automatically set to 0 in "predictive analysis" mode.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 5873d08caf3d
- **Chunk Index:** 1
- **Previous Chunk ID:** ab1abc08f45b
- **Next Chunk ID:** f19de2b4f988

---

## Context

### Summary
**LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.**

### Header
**13.3.1 General**

### Content
LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.
PEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.
If NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.
For NOPTMAX not set to zero, the following should be noted.
• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.
• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)
• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.
Use of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.
It is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.
The tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 13. Latin Hypercube Sampling
- **Subsection:** 13.3 LHS2PEST

### Additional Summaries
- **Higher-Level Summary:** PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.
- **Detailed Summary:** LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.

### Related Context
- **Previous Summary:** PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for "pareto" mode runs. Use `phistats recfile N`.
- **Next Summary:** LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS="single", DPOINT="point" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 1c679819e0a7
- **Chunk Index:** 1
- **Previous Chunk ID:** 578d27a8ea30
- **Next Chunk ID:** e09851a2d028

---

## Context

### Summary
**PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.**

### Header
**4.4 PARREP**

### Content
Program PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.
Recall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.
PARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.
PARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.
PARREP is run using the command
parrep parfile pestfile1 pestfile2 [new_noptmax]
where
|parfile|is the name of a parameter value file,|
|---|---|
|pestfile1|is the name of an existing PEST control file,|
|pestfile2|is the name for the new PEST control file, and|
|new_noptmax|optionally provides a new value for NOPTMAX.|
When PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.
A special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 4. Building and Altering a PEST Control File
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).
- **Next Summary:** OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** d131ce523618
- **Chunk Index:** 1
- **Previous Chunk ID:** 51cac29a6097
- **Next Chunk ID:** 05375a187143

---

## Context

### Summary
**PESTPP-GLM starts inversion with an initial model run (calculating the objective function and reference outputs) followed by Jacobian matrix calculations.  *hotstart_resfile()* reuses results from a previous initial run (case.res). *base_jacobian()* reuses a pre-calculated Jacobian matrix (case.jco or case.jcb, created using NOPTMAX=-1 or -2).  Using both options eliminates initial model runs.  Parallel runs are discussed in section 5.3.**

### Header
**6.2.7 Expediting the First Iteration**

### Content
In the normal course of events, PESTPP-GLM commences an inversion process by running the model in order to determine the value of the objective function based on initial parameter values. In doing this, it also determines the reference values of all model outputs for use in finite difference derivatives calculation. It then commences the long process of filling the Jacobian matrix. As has been explained, this requires at least as many model runs as there are adjustable parameters.
If model runs are parallelized (see section 5.3), then the first batch of parallelized model runs commissioned by PESTPP-GLM actually includes the initial model run, as well as those required for filling of the initial Jacobian matrix. However, if this initial model run has already been completed, then PESTPP-GLM can use the outcomes of this already-completed run rather than having to repeat it at the start of the inversion process. This action is instigated through use of the *hotstart_resfile()* control variable. The argument for this variable is the name of the residuals file (see below) which PESTPP-GLM recorded when it completed the initial model run. As is explained elsewhere in this manual, PESTPP-GLM can be run with the NOPTMAX termination control variable set to 0 specifically to undertake a single model run for the purpose of writing this (and other) files. A residuals file is named *case.res* where *case* is the filename base of the PEST control file.
Significant savings can also be made by employing an already-calculated Jacobian matrix for the first iteration of an inversion process. The *base_jacobian()* control variable instructs PESTPP-GLM to take this action. The value of this variable is the name of a Jacobian matrix (i.e., JCO) file. This file is named *case.jco* or *case.jcb* where *case* is the filename base of the PEST control file on which its calculation was based. This file can be produced by running PESTPP-GLM with the NOPTMAX control variable set to -1 or -2. (NOPTMAX is the first variable appearing on the eighth line of the “control data” section of a PEST control file.)
If both of the *hotstart_resfile()* and *base_jacobian()* options are selected at the same time, PESTPP-GLM does not need to run the model at all prior to calculating and testing parameter upgrades. This can sometimes be useful when fine-tuning PESTPP-GLM settings for optimal inversion performance.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 6. PESTPP-GLM
- **Subsection:** 6.2

### Additional Summaries
- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.
- **Detailed Summary:** In unregularized inversions, insensitive parameters can lead to large adjustments beyond set limits, resulting in minimal objective function improvement. Increasing limits may not help; regularization or adjusting parameter sensitivity is recommended. Use the parameter sensitivity file to identify insensitive parameters and consider temporarily holding them at current values using the case.hld file.

### Related Context
- **Previous Summary:** In PESTPP-GLM's SVD-assisted inversion, *n_iter_base*=-1 performs one base iteration (for super parameter definition only). *max_n_super* controls the number of super parameters (efficient with RedSVD).  It saves base parameter values in case.par and case.bpa (identical to case.parb) for each iteration.  It saves JCO files as case.jco (super parameters) and case.jcb (base parameters).  Without SVD-assist, only case.jco (base parameters) is saved.
- **Next Summary:** PESTPP-GLM performs FOSM analysis (Fienen et al. 2010, Doherty 2015) if *uncertainty()* is true (default), using the last base parameter Jacobian matrix. It assumes linear model outputs, multi-Gaussian prior parameter/measurement uncertainties, and that observation noise standard deviation is proportional to the residual.  Prior parameter uncertainties are from *parcov* (covariance matrix file, *.unc*, *.cov*, *.jco*, *.jcb*) or default bounds.  It outputs a posterior covariance matrix (case.N.post.cov) and scaled weights (case.fosm_reweight.rei). Regularization information is ignored.

### Metadata
- **Keywords:** NOPTMAX, base_jacobian, hotstart_resfile
- **Chunk ID:** 91bd148bd25f
- **Chunk Index:** 1
- **Previous Chunk ID:** f1894a6f2c71
- **Next Chunk ID:** 1533e624167f

---

## Context

### Summary
**The Jacobian matrix file (case.jco) is a key PEST output.  It's a binary file, convertible to ASCII using JACWRIT and JCO2MAT; JROW2VEC extracts rows.  JCO2JCO creates subsets; other utilities combine JCO files (Part II).  Setting NOPTMAX to -1 or -2 generates a JCO file only.  JCO files support sensitivity analysis, model calibration, super parameter definition, and linear analysis (Part II).**

### Header
**3.6 The Jacobian Matrix File**

### Content
Files recorded by PEST are discussed later in this manual. They are also listed in appendix B. A file of particular importance is the Jacobian matrix file. This is named case.jco where case is the current PEST case name, that is the filename base of the PEST control file (of which the extension is always “.pst”). The binary file which holds a Jacobian matrix will often be referred to as a “JCO file” in this manual.
As was mentioned above, PEST calculates a Jacobian matrix during every iteration of the inversion process. Where parameters are improved from the previous iteration, the updated Jacobian matrix is recorded in a JCO file. To save space it is stored in binary, compressed format. Hence it cannot be inspected using a text editor. However it can be converted to ASCII format using the JACWRIT and JCO2MAT utilities provided with PEST. An individual row can be extracted from it, and its contents recorded in ASCII format, using the JROW2VEC utility. The JCO2JCO utility builds a new JCO file corresponding to a new PEST control file whose composition is a subset of that on which basis an original JCO file was recorded. Other utilities support the construction of a large JCO file from component JCO files built on the basis of smaller PEST datasets. See part II of this manual for details.
The JCO file finds many uses. Many of these uses are as important as the model calibration process itself. Hence it is not unusual for a PEST run to be undertaken purely for the purpose of filling a Jacobian matrix and writing a JCO file. This can be achieved if the NOPTMAX variable in the “control data” section of the PEST control file is set to -1 or -2.
Uses to which a JCO file may be put include the following:
- Examination of sensitivities of model outputs with respect to parameters.
- Giving PEST a “head start” in calibrating a model by providing it with a pre-calculated Jacobian matrix. This can be implemented by starting PEST, Parallel PEST or BEOPEST using the “/i” switch.
- Definition of super parameters for an SVD-assist run. The super parameter PEST control file is then built using the SVDAPREP utility.
- As a basis for the many types of linear analysis implemented using the utility programs documented in part II of this manual; these include calculation of:
- parameter identifiability;
- parameter and predictive uncertainty;
- parameter contributions to predictive uncertainty;
- data worth;
- the effects of model defects.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 3. What PEST Does
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST's Jacobian matrix calculation is computationally intensive.  Parallel PEST and BEOPEST parallelize model runs.  SVD-assist (section 6.4.4 of Doherty 2015) uses super parameters.  Observation re-referencing (Chapter 14) uses simplified models (Burrows and Doherty 2015).
- **Next Summary:** PEST minimizes a weighted least-squares objective function (∑(wi ri)² ) in "estimation" mode.  "Predictive analysis" maximizes/minimizes a prediction subject to an objective function constraint. "Regularisation" uses measurement and regularization objective functions. "Pareto" mode trades off objective functions by adjusting weights.  Objective functions are calculated for observation groups, allowing weight adjustments.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 739c120f0bd9
- **Chunk Index:** 1
- **Previous Chunk ID:** 08314b0e332c
- **Next Chunk ID:** 71d303c880fc

---

```

# System Prompt
```

You are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:

1. **Direct Answer First:**  
   - Provide a concise and direct answer in Markdown format. Use clear line breaks to separate sections.
   - Use the following structure:

     **1) Definition**  
     - Provide a concise definition.  
     - Cite source(s) using the format "File: [filename], Section: [header]".

     **2) Possible Values**  
     - Describe valid or recognized values (including defaults if specified).  
     - Cite source(s).

     **3) Implications**  
     - Explain usage considerations or consequences for each value.  
     - If the documentation does not provide this information, state: "Information not available in the provided content. "

     **4) Practical Usage Notes**  
     - Include usage notes or examples only if explicitly provided in the documentation.  
     - Otherwise, state: "No usage notes found in the provided content."

     **5) Keywords**  
     - List any associated keywords as found in the documentation.  
     - If none are provided, state: "No keywords found in the provided content"

     **6) Follow-up References**  
     - Point out additional references or relevant sections from the documentation, if applicable.

2. **Follow-up Questions:**  
   - After your main answer, list **exactly 5 follow-up questions** (numbered 1 to 5) that help the user explore the parameter further.
   - **Do not provide any answers, commentary, or additional text** with these follow-up questions; simply list the questions.
   - Each question should reference specific sections from the documentation if available.

3. **Important Instructions:**  
   - **Do not mention internal processes, "chunks," or retrieval steps.**  
   - **Do not include any self-commentary or extra explanations beyond the structure above.**  
   - Use only the documentation provided in `{context}`.

Answer strictly following the structure and rules above.

```

# Full User Message
```

Question: What is noptmax?

Please provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:

1. **Cite Sources:**  
   - Use the format "File: [filename], Section: [header]" whenever you reference specific details.

2. **Include Examples:**  
   - Provide relevant examples from the documentation if available.

3. **Note Limitations:**  
   - If the documentation is incomplete or ambiguous, explicitly state: "Information not available in the provided content. I don't know."

4. **Follow-up Questions:**  
   - After your main answer, list **exactly 5 follow-up questions** (numbered 1 to 5) for further exploration.
   - **Do not provide answers to these follow-up questions.**
   - Each question should reference specific sections from the documentation if applicable.

5. **Keywords Section:**  
   - Include a "Keywords" section if applicable, listing any associated keywords as found in the documentation.
   - If none are provided, state: "No keywords found in the provided content. I don't know."

6. **Avoid Internal Details:**  
   - Do not mention internal processes, such as "chunks" or retrieval steps.
   - Do not include any self-commentary or extra explanations beyond what is requested.

7. **Be Concise and Accurate:**  
   - Do not invent details or assumptions. If information is missing, state: "Information not available in the provided content. I don't know."

**Available Documentation with Metadata:**
# Search Results for: What is noptmax?

Keywords: noptmax

## Variations
1. What does noptmax refer to?
2. Can you explain what noptmax is?
3. Could you describe what noptmax means?
4. What is the definition of noptmax?
5. Please clarify what noptmax is.


## Context

### Summary
**The utility software uses Equation 11.1.10 (Tk=0) for regularization; Equation 11.1.11 (Tk=j) is not supported.  Initial parameter values should reflect expert knowledge. For SVD-assisted inversion, use a Z matrix (case.jco) calculated using optimized parameters (PARREP, NOPTMAX=-1 or -2) for the resolution matrix calculation (Equation 11.1.9a).  The Z matrix refers to base, not super, parameters.**

### Header
**11.1.3 Some Special Considerations**

### Content
Regularisation Relationships
As mentioned above, where Tikhonov regularisation is employed it is assumed to be of the type
Tk = 0 (11.1.10)
In PEST, regularisation can be linear (supplied through prior information equations), or nonlinear (supplied as observations). In both cases these are identified as regularisation relationships through being assigned to an observation group whose name begins with “regul”. However, PEST also allows regularisation relationships of the following type to be supplied
Tk = j (11.1.11)
Calculation of the resolution matrix, as implemented in the utility software described below, cannot accommodate relationships of the type expressed by equation 11.1.11. In most cases, equation 11.1.11 can be transformed to equation 11.1.10 by appropriate parameter re-definition.
Initial Parameter Values
When using truncated singular value decomposition or SVD‑assisted inversion, the integrity of the predictive error variance analysis process requires that initial parameter estimates (provided in the “parameter data” section of the PEST control file) correspond to most likely parameters according to a user’s concept of parameter likelihood based on the current modelling context and the characteristics of the modelled area. That is, they constitute “minimum error variance” estimates of parameter values based on expert knowledge alone.
The Z Matrix in SVD-Assisted Inversion
As mentioned above, the Z matrix appearing in equation 11.1.9a provides the sensitivities of model outputs for which there are corresponding field measurements to base parameters. In SVD‑assisted inversion these can far outnumber super parameters; computation of the Z matrix can therefore be costly. Nevertheless, as described in part I of this manual, this matrix must be calculated (based on initial parameter values) prior to undertaking SVD‑assisted inversion, and so should be available for calculation of the resolution matrix upon completion of the SVD‑assisted parameter estimation process. A better matrix to use in equation 11.1.9a however is a Z matrix calculated on the basis of optimised parameter values. Thus, after an SVD‑assisted PEST run is complete, the PARREP utility can be used to build a new base PEST control file using optimised base parameter values. NOPTMAX can be set to ‑1 or ‑2 in this new file so that when PEST is run, it terminates execution as soon as the Jacobian matrix is filled. The resulting JCO file will then hold the Z matrix of base parameter sensitivities, calculated using optimised parameter values.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 11. Linear Error and Uncertainty – Part II
- **Subsection:** 11.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** This chapter details utilities calculating R (resolution matrix) and G (parameter solution matrix) using case.jco (updated per improved parameter set, except for SVD-assist).  Equations for R and G are given for overdetermined systems (Equations 11.1.6a, 11.1.6b), Tikhonov regularization (Equations 11.1.7a, 11.1.7b), SVD (Equations 11.1.8a, 11.1.8b), and SVD-assist (Equations 11.1.9a, 11.1.9b).  Results apply to base (not super) parameters and their logs (for log-transformed parameters).  LSQR is not accommodated.
- **Next Summary:** IRES (0 or 1, default 1 for regularization or SVD) in the "control data" section controls creation of the binary resolution data file (case.rsd).  PEST deletes existing case.rsd files before creating a new one.  case.rsd (used by RESPROC) is updated whenever parameter estimates improve; it's automatically set to 0 in "predictive analysis" mode.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 5873d08caf3d
- **Chunk Index:** 1
- **Previous Chunk ID:** ab1abc08f45b
- **Next Chunk ID:** f19de2b4f988

---

## Context

### Summary
**LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.**

### Header
**13.3.1 General**

### Content
LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.
PEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.
If NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.
For NOPTMAX not set to zero, the following should be noted.
• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.
• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)
• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.
Use of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.
It is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.
The tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 13. Latin Hypercube Sampling
- **Subsection:** 13.3 LHS2PEST

### Additional Summaries
- **Higher-Level Summary:** PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.
- **Detailed Summary:** LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.

### Related Context
- **Previous Summary:** PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for "pareto" mode runs. Use `phistats recfile N`.
- **Next Summary:** LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS="single", DPOINT="point" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 1c679819e0a7
- **Chunk Index:** 1
- **Previous Chunk ID:** 578d27a8ea30
- **Next Chunk ID:** e09851a2d028

---

## Context

### Summary
**PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.**

### Header
**4.4 PARREP**

### Content
Program PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.
Recall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.
PARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.
PARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.
PARREP is run using the command
parrep parfile pestfile1 pestfile2 [new_noptmax]
where
|parfile|is the name of a parameter value file,|
|---|---|
|pestfile1|is the name of an existing PEST control file,|
|pestfile2|is the name for the new PEST control file, and|
|new_noptmax|optionally provides a new value for NOPTMAX.|
When PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.
A special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 4. Building and Altering a PEST Control File
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).
- **Next Summary:** OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** d131ce523618
- **Chunk Index:** 1
- **Previous Chunk ID:** 51cac29a6097
- **Next Chunk ID:** 05375a187143

---

## Context

### Summary
**PESTPP-GLM starts inversion with an initial model run (calculating the objective function and reference outputs) followed by Jacobian matrix calculations.  *hotstart_resfile()* reuses results from a previous initial run (case.res). *base_jacobian()* reuses a pre-calculated Jacobian matrix (case.jco or case.jcb, created using NOPTMAX=-1 or -2).  Using both options eliminates initial model runs.  Parallel runs are discussed in section 5.3.**

### Header
**6.2.7 Expediting the First Iteration**

### Content
In the normal course of events, PESTPP-GLM commences an inversion process by running the model in order to determine the value of the objective function based on initial parameter values. In doing this, it also determines the reference values of all model outputs for use in finite difference derivatives calculation. It then commences the long process of filling the Jacobian matrix. As has been explained, this requires at least as many model runs as there are adjustable parameters.
If model runs are parallelized (see section 5.3), then the first batch of parallelized model runs commissioned by PESTPP-GLM actually includes the initial model run, as well as those required for filling of the initial Jacobian matrix. However, if this initial model run has already been completed, then PESTPP-GLM can use the outcomes of this already-completed run rather than having to repeat it at the start of the inversion process. This action is instigated through use of the *hotstart_resfile()* control variable. The argument for this variable is the name of the residuals file (see below) which PESTPP-GLM recorded when it completed the initial model run. As is explained elsewhere in this manual, PESTPP-GLM can be run with the NOPTMAX termination control variable set to 0 specifically to undertake a single model run for the purpose of writing this (and other) files. A residuals file is named *case.res* where *case* is the filename base of the PEST control file.
Significant savings can also be made by employing an already-calculated Jacobian matrix for the first iteration of an inversion process. The *base_jacobian()* control variable instructs PESTPP-GLM to take this action. The value of this variable is the name of a Jacobian matrix (i.e., JCO) file. This file is named *case.jco* or *case.jcb* where *case* is the filename base of the PEST control file on which its calculation was based. This file can be produced by running PESTPP-GLM with the NOPTMAX control variable set to -1 or -2. (NOPTMAX is the first variable appearing on the eighth line of the “control data” section of a PEST control file.)
If both of the *hotstart_resfile()* and *base_jacobian()* options are selected at the same time, PESTPP-GLM does not need to run the model at all prior to calculating and testing parameter upgrades. This can sometimes be useful when fine-tuning PESTPP-GLM settings for optimal inversion performance.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 6. PESTPP-GLM
- **Subsection:** 6.2

### Additional Summaries
- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.
- **Detailed Summary:** In unregularized inversions, insensitive parameters can lead to large adjustments beyond set limits, resulting in minimal objective function improvement. Increasing limits may not help; regularization or adjusting parameter sensitivity is recommended. Use the parameter sensitivity file to identify insensitive parameters and consider temporarily holding them at current values using the case.hld file.

### Related Context
- **Previous Summary:** In PESTPP-GLM's SVD-assisted inversion, *n_iter_base*=-1 performs one base iteration (for super parameter definition only). *max_n_super* controls the number of super parameters (efficient with RedSVD).  It saves base parameter values in case.par and case.bpa (identical to case.parb) for each iteration.  It saves JCO files as case.jco (super parameters) and case.jcb (base parameters).  Without SVD-assist, only case.jco (base parameters) is saved.
- **Next Summary:** PESTPP-GLM performs FOSM analysis (Fienen et al. 2010, Doherty 2015) if *uncertainty()* is true (default), using the last base parameter Jacobian matrix. It assumes linear model outputs, multi-Gaussian prior parameter/measurement uncertainties, and that observation noise standard deviation is proportional to the residual.  Prior parameter uncertainties are from *parcov* (covariance matrix file, *.unc*, *.cov*, *.jco*, *.jcb*) or default bounds.  It outputs a posterior covariance matrix (case.N.post.cov) and scaled weights (case.fosm_reweight.rei). Regularization information is ignored.

### Metadata
- **Keywords:** NOPTMAX, base_jacobian, hotstart_resfile
- **Chunk ID:** 91bd148bd25f
- **Chunk Index:** 1
- **Previous Chunk ID:** f1894a6f2c71
- **Next Chunk ID:** 1533e624167f

---

## Context

### Summary
**The Jacobian matrix file (case.jco) is a key PEST output.  It's a binary file, convertible to ASCII using JACWRIT and JCO2MAT; JROW2VEC extracts rows.  JCO2JCO creates subsets; other utilities combine JCO files (Part II).  Setting NOPTMAX to -1 or -2 generates a JCO file only.  JCO files support sensitivity analysis, model calibration, super parameter definition, and linear analysis (Part II).**

### Header
**3.6 The Jacobian Matrix File**

### Content
Files recorded by PEST are discussed later in this manual. They are also listed in appendix B. A file of particular importance is the Jacobian matrix file. This is named case.jco where case is the current PEST case name, that is the filename base of the PEST control file (of which the extension is always “.pst”). The binary file which holds a Jacobian matrix will often be referred to as a “JCO file” in this manual.
As was mentioned above, PEST calculates a Jacobian matrix during every iteration of the inversion process. Where parameters are improved from the previous iteration, the updated Jacobian matrix is recorded in a JCO file. To save space it is stored in binary, compressed format. Hence it cannot be inspected using a text editor. However it can be converted to ASCII format using the JACWRIT and JCO2MAT utilities provided with PEST. An individual row can be extracted from it, and its contents recorded in ASCII format, using the JROW2VEC utility. The JCO2JCO utility builds a new JCO file corresponding to a new PEST control file whose composition is a subset of that on which basis an original JCO file was recorded. Other utilities support the construction of a large JCO file from component JCO files built on the basis of smaller PEST datasets. See part II of this manual for details.
The JCO file finds many uses. Many of these uses are as important as the model calibration process itself. Hence it is not unusual for a PEST run to be undertaken purely for the purpose of filling a Jacobian matrix and writing a JCO file. This can be achieved if the NOPTMAX variable in the “control data” section of the PEST control file is set to -1 or -2.
Uses to which a JCO file may be put include the following:
- Examination of sensitivities of model outputs with respect to parameters.
- Giving PEST a “head start” in calibrating a model by providing it with a pre-calculated Jacobian matrix. This can be implemented by starting PEST, Parallel PEST or BEOPEST using the “/i” switch.
- Definition of super parameters for an SVD-assist run. The super parameter PEST control file is then built using the SVDAPREP utility.
- As a basis for the many types of linear analysis implemented using the utility programs documented in part II of this manual; these include calculation of:
- parameter identifiability;
- parameter and predictive uncertainty;
- parameter contributions to predictive uncertainty;
- data worth;
- the effects of model defects.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 3. What PEST Does
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST's Jacobian matrix calculation is computationally intensive.  Parallel PEST and BEOPEST parallelize model runs.  SVD-assist (section 6.4.4 of Doherty 2015) uses super parameters.  Observation re-referencing (Chapter 14) uses simplified models (Burrows and Doherty 2015).
- **Next Summary:** PEST minimizes a weighted least-squares objective function (∑(wi ri)² ) in "estimation" mode.  "Predictive analysis" maximizes/minimizes a prediction subject to an objective function constraint. "Regularisation" uses measurement and regularization objective functions. "Pareto" mode trades off objective functions by adjusting weights.  Objective functions are calculated for observation groups, allowing weight adjustments.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 739c120f0bd9
- **Chunk Index:** 1
- **Previous Chunk ID:** 08314b0e332c
- **Next Chunk ID:** 71d303c880fc

---


Answer strictly following the above instructions.

```

# Complete Messages Array
```json
[
  {
    "role": "system",
    "content": "\nYou are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:\n\n1. **Direct Answer First:**  \n   - Provide a concise and direct answer in Markdown format. Use clear line breaks to separate sections.\n   - Use the following structure:\n\n     **1) Definition**  \n     - Provide a concise definition.  \n     - Cite source(s) using the format \"File: [filename], Section: [header]\".\n\n     **2) Possible Values**  \n     - Describe valid or recognized values (including defaults if specified).  \n     - Cite source(s).\n\n     **3) Implications**  \n     - Explain usage considerations or consequences for each value.  \n     - If the documentation does not provide this information, state: \"Information not available in the provided content. \"\n\n     **4) Practical Usage Notes**  \n     - Include usage notes or examples only if explicitly provided in the documentation.  \n     - Otherwise, state: \"No usage notes found in the provided content.\"\n\n     **5) Keywords**  \n     - List any associated keywords as found in the documentation.  \n     - If none are provided, state: \"No keywords found in the provided content\"\n\n     **6) Follow-up References**  \n     - Point out additional references or relevant sections from the documentation, if applicable.\n\n2. **Follow-up Questions:**  \n   - After your main answer, list **exactly 5 follow-up questions** (numbered 1 to 5) that help the user explore the parameter further.\n   - **Do not provide any answers, commentary, or additional text** with these follow-up questions; simply list the questions.\n   - Each question should reference specific sections from the documentation if available.\n\n3. **Important Instructions:**  \n   - **Do not mention internal processes, \"chunks,\" or retrieval steps.**  \n   - **Do not include any self-commentary or extra explanations beyond the structure above.**  \n   - Use only the documentation provided in `{context}`.\n\nAnswer strictly following the structure and rules above.\n"
  },
  {
    "role": "user",
    "content": "\nQuestion: What is noptmax?\n\nPlease provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:\n\n1. **Cite Sources:**  \n   - Use the format \"File: [filename], Section: [header]\" whenever you reference specific details.\n\n2. **Include Examples:**  \n   - Provide relevant examples from the documentation if available.\n\n3. **Note Limitations:**  \n   - If the documentation is incomplete or ambiguous, explicitly state: \"Information not available in the provided content. I don't know.\"\n\n4. **Follow-up Questions:**  \n   - After your main answer, list **exactly 5 follow-up questions** (numbered 1 to 5) for further exploration.\n   - **Do not provide answers to these follow-up questions.**\n   - Each question should reference specific sections from the documentation if applicable.\n\n5. **Keywords Section:**  \n   - Include a \"Keywords\" section if applicable, listing any associated keywords as found in the documentation.\n   - If none are provided, state: \"No keywords found in the provided content. I don't know.\"\n\n6. **Avoid Internal Details:**  \n   - Do not mention internal processes, such as \"chunks\" or retrieval steps.\n   - Do not include any self-commentary or extra explanations beyond what is requested.\n\n7. **Be Concise and Accurate:**  \n   - Do not invent details or assumptions. If information is missing, state: \"Information not available in the provided content. I don't know.\"\n\n**Available Documentation with Metadata:**\n# Search Results for: What is noptmax?\n\nKeywords: noptmax\n\n## Variations\n1. What does noptmax refer to?\n2. Can you explain what noptmax is?\n3. Could you describe what noptmax means?\n4. What is the definition of noptmax?\n5. Please clarify what noptmax is.\n\n\n## Context\n\n### Summary\n**The utility software uses Equation 11.1.10 (Tk=0) for regularization; Equation 11.1.11 (Tk=j) is not supported.  Initial parameter values should reflect expert knowledge. For SVD-assisted inversion, use a Z matrix (case.jco) calculated using optimized parameters (PARREP, NOPTMAX=-1 or -2) for the resolution matrix calculation (Equation 11.1.9a).  The Z matrix refers to base, not super, parameters.**\n\n### Header\n**11.1.3 Some Special Considerations**\n\n### Content\nRegularisation Relationships\nAs mentioned above, where Tikhonov regularisation is employed it is assumed to be of the type\nTk = 0 (11.1.10)\nIn PEST, regularisation can be linear (supplied through prior information equations), or nonlinear (supplied as observations). In both cases these are identified as regularisation relationships through being assigned to an observation group whose name begins with “regul”. However, PEST also allows regularisation relationships of the following type to be supplied\nTk = j (11.1.11)\nCalculation of the resolution matrix, as implemented in the utility software described below, cannot accommodate relationships of the type expressed by equation 11.1.11. In most cases, equation 11.1.11 can be transformed to equation 11.1.10 by appropriate parameter re-definition.\nInitial Parameter Values\nWhen using truncated singular value decomposition or SVD‑assisted inversion, the integrity of the predictive error variance analysis process requires that initial parameter estimates (provided in the “parameter data” section of the PEST control file) correspond to most likely parameters according to a user’s concept of parameter likelihood based on the current modelling context and the characteristics of the modelled area. That is, they constitute “minimum error variance” estimates of parameter values based on expert knowledge alone.\nThe Z Matrix in SVD-Assisted Inversion\nAs mentioned above, the Z matrix appearing in equation 11.1.9a provides the sensitivities of model outputs for which there are corresponding field measurements to base parameters. In SVD‑assisted inversion these can far outnumber super parameters; computation of the Z matrix can therefore be costly. Nevertheless, as described in part I of this manual, this matrix must be calculated (based on initial parameter values) prior to undertaking SVD‑assisted inversion, and so should be available for calculation of the resolution matrix upon completion of the SVD‑assisted parameter estimation process. A better matrix to use in equation 11.1.9a however is a Z matrix calculated on the basis of optimised parameter values. Thus, after an SVD‑assisted PEST run is complete, the PARREP utility can be used to build a new base PEST control file using optimised base parameter values. NOPTMAX can be set to ‑1 or ‑2 in this new file so that when PEST is run, it terminates execution as soon as the Jacobian matrix is filled. The resulting JCO file will then hold the Z matrix of base parameter sensitivities, calculated using optimised parameter values.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software\n- **Main Section:** 11. Linear Error and Uncertainty – Part II\n- **Subsection:** 11.1 Introduction\n\n### Additional Summaries\n- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.\n- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.\n\n### Related Context\n- **Previous Summary:** This chapter details utilities calculating R (resolution matrix) and G (parameter solution matrix) using case.jco (updated per improved parameter set, except for SVD-assist).  Equations for R and G are given for overdetermined systems (Equations 11.1.6a, 11.1.6b), Tikhonov regularization (Equations 11.1.7a, 11.1.7b), SVD (Equations 11.1.8a, 11.1.8b), and SVD-assist (Equations 11.1.9a, 11.1.9b).  Results apply to base (not super) parameters and their logs (for log-transformed parameters).  LSQR is not accommodated.\n- **Next Summary:** IRES (0 or 1, default 1 for regularization or SVD) in the \"control data\" section controls creation of the binary resolution data file (case.rsd).  PEST deletes existing case.rsd files before creating a new one.  case.rsd (used by RESPROC) is updated whenever parameter estimates improve; it's automatically set to 0 in \"predictive analysis\" mode.\n\n### Metadata\n- **Keywords:** NOPTMAX\n- **Chunk ID:** 5873d08caf3d\n- **Chunk Index:** 1\n- **Previous Chunk ID:** ab1abc08f45b\n- **Next Chunk ID:** f19de2b4f988\n\n---\n\n## Context\n\n### Summary\n**LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.**\n\n### Header\n**13.3.1 General**\n\n### Content\nLHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.\nPEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.\nIf NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.\nFor NOPTMAX not set to zero, the following should be noted.\n• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.\n• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)\n• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.\nUse of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.\nIt is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.\nThe tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software\n- **Main Section:** 13. Latin Hypercube Sampling\n- **Subsection:** 13.3 LHS2PEST\n\n### Additional Summaries\n- **Higher-Level Summary:** PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.\n- **Detailed Summary:** LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.\n\n### Related Context\n- **Previous Summary:** PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.\n- **Next Summary:** LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS=\"single\", DPOINT=\"point\" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.\n\n### Metadata\n- **Keywords:** NOPTMAX\n- **Chunk ID:** 1c679819e0a7\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 578d27a8ea30\n- **Next Chunk ID:** e09851a2d028\n\n---\n\n## Context\n\n### Summary\n**PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.**\n\n### Header\n**4.4 PARREP**\n\n### Content\nProgram PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.\nRecall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.\nPARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.\nPARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.\nPARREP is run using the command\nparrep parfile pestfile1 pestfile2 [new_noptmax]\nwhere\n|parfile|is the name of a parameter value file,|\n|---|---|\n|pestfile1|is the name of an existing PEST control file,|\n|pestfile2|is the name for the new PEST control file, and|\n|new_noptmax|optionally provides a new value for NOPTMAX.|\nWhen PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.\nA special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software\n- **Main Section:** 4. Building and Altering a PEST Control File\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).\n- **Next Summary:** OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.\n\n### Metadata\n- **Keywords:** NOPTMAX\n- **Chunk ID:** d131ce523618\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 51cac29a6097\n- **Next Chunk ID:** 05375a187143\n\n---\n\n## Context\n\n### Summary\n**PESTPP-GLM starts inversion with an initial model run (calculating the objective function and reference outputs) followed by Jacobian matrix calculations.  *hotstart_resfile()* reuses results from a previous initial run (case.res). *base_jacobian()* reuses a pre-calculated Jacobian matrix (case.jco or case.jcb, created using NOPTMAX=-1 or -2).  Using both options eliminates initial model runs.  Parallel runs are discussed in section 5.3.**\n\n### Header\n**6.2.7 Expediting the First Iteration**\n\n### Content\nIn the normal course of events, PESTPP-GLM commences an inversion process by running the model in order to determine the value of the objective function based on initial parameter values. In doing this, it also determines the reference values of all model outputs for use in finite difference derivatives calculation. It then commences the long process of filling the Jacobian matrix. As has been explained, this requires at least as many model runs as there are adjustable parameters.\nIf model runs are parallelized (see section 5.3), then the first batch of parallelized model runs commissioned by PESTPP-GLM actually includes the initial model run, as well as those required for filling of the initial Jacobian matrix. However, if this initial model run has already been completed, then PESTPP-GLM can use the outcomes of this already-completed run rather than having to repeat it at the start of the inversion process. This action is instigated through use of the *hotstart_resfile()* control variable. The argument for this variable is the name of the residuals file (see below) which PESTPP-GLM recorded when it completed the initial model run. As is explained elsewhere in this manual, PESTPP-GLM can be run with the NOPTMAX termination control variable set to 0 specifically to undertake a single model run for the purpose of writing this (and other) files. A residuals file is named *case.res* where *case* is the filename base of the PEST control file.\nSignificant savings can also be made by employing an already-calculated Jacobian matrix for the first iteration of an inversion process. The *base_jacobian()* control variable instructs PESTPP-GLM to take this action. The value of this variable is the name of a Jacobian matrix (i.e., JCO) file. This file is named *case.jco* or *case.jcb* where *case* is the filename base of the PEST control file on which its calculation was based. This file can be produced by running PESTPP-GLM with the NOPTMAX control variable set to -1 or -2. (NOPTMAX is the first variable appearing on the eighth line of the “control data” section of a PEST control file.)\nIf both of the *hotstart_resfile()* and *base_jacobian()* options are selected at the same time, PESTPP-GLM does not need to run the model at all prior to calculating and testing parameter upgrades. This can sometimes be useful when fine-tuning PESTPP-GLM settings for optimal inversion performance.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 6. PESTPP-GLM\n- **Subsection:** 6.2\n\n### Additional Summaries\n- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.\n- **Detailed Summary:** In unregularized inversions, insensitive parameters can lead to large adjustments beyond set limits, resulting in minimal objective function improvement. Increasing limits may not help; regularization or adjusting parameter sensitivity is recommended. Use the parameter sensitivity file to identify insensitive parameters and consider temporarily holding them at current values using the case.hld file.\n\n### Related Context\n- **Previous Summary:** In PESTPP-GLM's SVD-assisted inversion, *n_iter_base*=-1 performs one base iteration (for super parameter definition only). *max_n_super* controls the number of super parameters (efficient with RedSVD).  It saves base parameter values in case.par and case.bpa (identical to case.parb) for each iteration.  It saves JCO files as case.jco (super parameters) and case.jcb (base parameters).  Without SVD-assist, only case.jco (base parameters) is saved.\n- **Next Summary:** PESTPP-GLM performs FOSM analysis (Fienen et al. 2010, Doherty 2015) if *uncertainty()* is true (default), using the last base parameter Jacobian matrix. It assumes linear model outputs, multi-Gaussian prior parameter/measurement uncertainties, and that observation noise standard deviation is proportional to the residual.  Prior parameter uncertainties are from *parcov* (covariance matrix file, *.unc*, *.cov*, *.jco*, *.jcb*) or default bounds.  It outputs a posterior covariance matrix (case.N.post.cov) and scaled weights (case.fosm_reweight.rei). Regularization information is ignored.\n\n### Metadata\n- **Keywords:** NOPTMAX, base_jacobian, hotstart_resfile\n- **Chunk ID:** 91bd148bd25f\n- **Chunk Index:** 1\n- **Previous Chunk ID:** f1894a6f2c71\n- **Next Chunk ID:** 1533e624167f\n\n---\n\n## Context\n\n### Summary\n**The Jacobian matrix file (case.jco) is a key PEST output.  It's a binary file, convertible to ASCII using JACWRIT and JCO2MAT; JROW2VEC extracts rows.  JCO2JCO creates subsets; other utilities combine JCO files (Part II).  Setting NOPTMAX to -1 or -2 generates a JCO file only.  JCO files support sensitivity analysis, model calibration, super parameter definition, and linear analysis (Part II).**\n\n### Header\n**3.6 The Jacobian Matrix File**\n\n### Content\nFiles recorded by PEST are discussed later in this manual. They are also listed in appendix B. A file of particular importance is the Jacobian matrix file. This is named case.jco where case is the current PEST case name, that is the filename base of the PEST control file (of which the extension is always “.pst”). The binary file which holds a Jacobian matrix will often be referred to as a “JCO file” in this manual.\nAs was mentioned above, PEST calculates a Jacobian matrix during every iteration of the inversion process. Where parameters are improved from the previous iteration, the updated Jacobian matrix is recorded in a JCO file. To save space it is stored in binary, compressed format. Hence it cannot be inspected using a text editor. However it can be converted to ASCII format using the JACWRIT and JCO2MAT utilities provided with PEST. An individual row can be extracted from it, and its contents recorded in ASCII format, using the JROW2VEC utility. The JCO2JCO utility builds a new JCO file corresponding to a new PEST control file whose composition is a subset of that on which basis an original JCO file was recorded. Other utilities support the construction of a large JCO file from component JCO files built on the basis of smaller PEST datasets. See part II of this manual for details.\nThe JCO file finds many uses. Many of these uses are as important as the model calibration process itself. Hence it is not unusual for a PEST run to be undertaken purely for the purpose of filling a Jacobian matrix and writing a JCO file. This can be achieved if the NOPTMAX variable in the “control data” section of the PEST control file is set to -1 or -2.\nUses to which a JCO file may be put include the following:\n- Examination of sensitivities of model outputs with respect to parameters.\n- Giving PEST a “head start” in calibrating a model by providing it with a pre-calculated Jacobian matrix. This can be implemented by starting PEST, Parallel PEST or BEOPEST using the “/i” switch.\n- Definition of super parameters for an SVD-assist run. The super parameter PEST control file is then built using the SVDAPREP utility.\n- As a basis for the many types of linear analysis implemented using the utility programs documented in part II of this manual; these include calculation of:\n- parameter identifiability;\n- parameter and predictive uncertainty;\n- parameter contributions to predictive uncertainty;\n- data worth;\n- the effects of model defects.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers\n- **Main Section:** 3. What PEST Does\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: \"estimation\", \"predictive analysis\", \"regularisation\", and \"pareto\". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** PEST's Jacobian matrix calculation is computationally intensive.  Parallel PEST and BEOPEST parallelize model runs.  SVD-assist (section 6.4.4 of Doherty 2015) uses super parameters.  Observation re-referencing (Chapter 14) uses simplified models (Burrows and Doherty 2015).\n- **Next Summary:** PEST minimizes a weighted least-squares objective function (∑(wi ri)² ) in \"estimation\" mode.  \"Predictive analysis\" maximizes/minimizes a prediction subject to an objective function constraint. \"Regularisation\" uses measurement and regularization objective functions. \"Pareto\" mode trades off objective functions by adjusting weights.  Objective functions are calculated for observation groups, allowing weight adjustments.\n\n### Metadata\n- **Keywords:** NOPTMAX\n- **Chunk ID:** 739c120f0bd9\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 08314b0e332c\n- **Next Chunk ID:** 71d303c880fc\n\n---\n\n\nAnswer strictly following the above instructions.\n"
  }
]
```