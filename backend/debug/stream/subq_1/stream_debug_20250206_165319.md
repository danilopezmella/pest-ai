# Stream Debug - 20250206_165319

# Original Question
```
What is PEST++?
```

# Context Content
```markdown
# Search Results for: What is PEST++?

Keywords: None


## Context

### Summary
**This chapter (reproducing text from the seventh PEST manual) describes template and instruction files used by both PEST and PEST++ for non-intrusive model interfacing.**

### Header
**2.1 Introduction**

### Content
This chapter reproduces material from the seventh edition of the PEST manual. This reflects the fact that programs of both the PEST and PEST++ suites employ template and instruction files as the basis for their non-intrusive model interface.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 2.  The PEST(++) Model Interface
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** PEST software uses template, instruction, and control files for model input and output. Templates, created with text editor or software, are validated with TEMPCHEK, INSCHEK, and PESTCHEK. Parameters are replaced in templates, and model input files should match for precision. Instruction files extract model outputs. Precision is crucial for accurate derivative calculations.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST++ programs read "observations" (model outputs) from model output files.  A PEST control file provides measured counterparts ("observations" with zero weight are predictions).  Predictions are used in uncertainty analyses and data worth analyses.
- **Next Summary:** PEST and PEST++ use template files (per model input file with parameters/decision variables), instruction files (per model output file), and a control file.  These files (created via text editor or specialized software) are checked using TEMPCHEK, INSCHEK, and PESTCHEK (Part II, Doherty 2018b). "Parameter" denotes parameters/decision variables; "observation" denotes numbers from model output files (including predictions).

### Metadata
- **Keywords:** 
- **Chunk ID:** d958d12cdc96
- **Chunk Index:** 1
- **Previous Chunk ID:** 112773e58ce3
- **Next Chunk ID:** b52992d44304

---

## Context

### Summary
**PEST++ programs (Table 1.1) perform various functions (inversion, optimization, sensitivity analysis, data assimilation) using a PEST control file for parameters, observations, and algorithm control.  They use a modular parallel run manager and TCP/IP communication.  PEST++ programs use template and instruction files for non-intrusive model interaction and ignore PEST++-specific control variables (++).**

### Header
**1.1 PEST++ and PEST**

### Content
The name “PEST++” refers to a suite of programs which have some things in common but which are also very different from each other. The names of all programs which comprise the suite begin with “PESTPP”. PEST stands for “Parameter ESTimation”.
PEST was released in 1995; it has been continually improved since then. It undertakes highly parameterized inversion of environmental models. In doing so, it runs a model many times, either sequentially or in parallel. It does this in a non-intrusive manner. Before it runs a model, it records parameter values that it wishes the model to use on that particular run via input files required by the model. User-prepared template files of model input files guide it in this task. After the model run is complete, PEST reads numbers from model output files which it then compares with field measurements. User-prepared instruction files guide it in this task. All other information which PEST requires is recorded in a PEST control file.
PESTPP-GLM is the original member of the PEST++ suite; it was originally named “PEST++” itself. Like PEST, PESTPP-GLM undertakes non-intrusive, highly parameterized inversion of an environmental model. As such, it can be considered as a direct replacement for PEST. While omitting some PEST functionality, it includes significant functionality that is absent from PEST. It uses the same template and instruction files that PEST uses to interact with a model. It reads a PEST control file to acquire information on problem definition. Like PEST, it can conduct model runs in serial or in parallel.
For all members of the PEST++ suite, parallelization of model runs follows the “manager” and “agent” concept. A user must start up agents in all folders in which he/she wishes that model runs be carried out. Agents can run on the same computer as the manager, on network-connected personal computers, on nodes of a high-performance computing cluster, and on the cloud. Agents communicate with their manager using the TCP/IP protocol. If the manager’s machine can be “pinged” from the agent’s machine, and if an agent’s machine can be “pinged” from the manager’s machine, then communication channels are open for parallelization of model runs. Whenever a member of the PEST++ suite requires that a model run be undertaken, its parallel run manager chooses a agent for the task, and then sends to the agent the numbers that must be written to model input files. Using template files, the agent writes these numbers to model input files; then it commands its local operating system to run the model. When the model run is complete, it reads model output files using instruction files. It then sends the numbers which it reads from these files back to the manager using TCP/IP.
One of the original design specifications of PESTPP-GLM was that its parallel run manager be modular, and separate from PESTPP-GLM, so that it could be used by any program that conducts non-intrusive, parallelized model runs for any purpose. It is this facet of its design that has spawned the development of other members of the PEST++ suite. At the time of writing, the composition of the PEST++ suite is listed in table 1.1.
| Program Name | Function                                                                                                  |
|------------------|---------------------------------------------------------------------------------------------------------------|
| PESTPP           | Highly parameterized inversion, and global optimization using differential evolution                          |
| PESTPP-SEN       | Global sensitivity analysis using the methods of Morris and Saltelli                                          |
| PESTPP-OPT       | Decision optimization under uncertainty using sequential linear programming and linearized chance constraints |
| PESTPP-IES       | Iterative ensemble smoother for production of a suite of calibration-constrained parameter fields             |
| PESTPP-SWP       | Undertakes a suite of parallelized model runs for any reason                                                  |
| PESTPP-DA        | Iterative ensemble filter and smoother data assimilation                                                      |
| PESTPP-MOU       | Single and multiple constrained optimization under uncertainty using evolutionary heuristics                  |
Table 1.1 Programs comprising of the PEST++ suite.
As well as containing a build-in parallel run manager (and hence of template and instruction files as a mechanism for non-intrusive communication with a model), the programs listed in table 1.1 have other commonalities. They all manipulate model parameters (which sometimes play the roles of decision variables). Most of them quantify mismatch between model outputs and field data. Information on parameters and field data is obtained from a PEST control file. So too is information that controls the way in which their algorithms operate.
Use of a PEST control file for storage of parameter, observation and control data was an important design consideration for the original version of PESTPP-GLM. This allowed interchangeable use with PEST. This remains a consideration for many members of the PEST++ suite.
When reading a PEST control file, most programs of the PEST++ suite obtain the values of control variables that are unique to that program from lines within the PEST control file that begin with the “++” string. PEST, and most of its associated utility software, ignores these lines. Interoperability of the PEST and PEST++ suites is thereby maintained.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 1. Introduction
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** To install PEST, copy its executables to a folder in the PATH variable for access from any directory. The suite includes PEST, Parallel PEST, BEOPEST, SENSAN, global optimizers, and utilities. PEST calibrates models by matching outputs to measurements, handling non-uniqueness through regularization. It quantifies uncertainties and supports decision-making by identifying unlikely events.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** This document references: Belsley et al. (1980) (regression diagnostics), Cook and Weisberg (1982) (regression residuals), Doherty (2015) (calibration and uncertainty), Doherty and Hunt (2009) (parameter identifiability), Hadi (1992) (influence measure), Hill and Tiedeman (2007) (groundwater model calibration), Koch (1999) (linear models), Lima et al. (2022) (data-space inversion), Sun and Durlofsky (2017) (uncertainty quantification), White et al. (2014) (model error), and Yager (1998) (influential observations).
- **Next Summary:** PEST++ programs create PEST-compatible parameter value (PAR) and Jacobian matrix (JCO) files. This interoperability allows PEST utilities (Doherty et al. 2018c) to process PEST++ results.  The PEST control file is also compatible.

### Metadata
- **Keywords:** 
- **Chunk ID:** 00e24a2e92bb
- **Chunk Index:** 1
- **Previous Chunk ID:** 6a90459bf216
- **Next Chunk ID:** 46d56be441df

---

## Context

### Summary
**This chapter, drawing from the seventh PEST manual, describes common features of PEST and PEST++ control files to facilitate understanding of control variable settings.**

### Header
**3.1 General**

### Content
Before describing the PEST control file, certain features that programs of the PEST++ suite have in common are discussed. This will make the task of explaining the settings of PEST and PEST++ control variables somewhat easier.
As for the previous and ensuing chapters of this manual, parts of the present chapter are taken from version 7 of the PEST manual.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 3. Some Important PEST++ Features
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Instruction files are created using a text editor, model GUI, PEST utilities, or pyEMU.  Incorrect instructions may cause run-time errors or undetected issues. PEST++ programs check instruction/control file consistency (*check_tplins* disables this). PESTCHEK verifies all instruction files in a control file; INSCHEK verifies individual files and tests output reading. Observation names are limited to 20 characters.
- **Next Summary:** PEST++ programs adjust parameter values or their base-10 logarithms (specified by PARTRANS in the "parameter data" section), improving stability and speed.  Prior information must use log-transformed values for log-transformed parameters.  Programs report errors for invalid log transformations (initial value or lower bound ≤0). PAR2PAR (Part II) handles complex transformations.

### Metadata
- **Keywords:** 
- **Chunk ID:** 2a3314cb00c1
- **Chunk Index:** 1
- **Previous Chunk ID:** c6acc3e4e825
- **Next Chunk ID:** ae4f52f7b5a7

---

## Context

### Summary
**PESTPP-IES performs iterative ensemble smoothing (described by White 2018, including examples, and Chen and Oliver 2013, including theory and examples).  Refer to these sources for details.**

### Header
**9.1.1 Publications**

### Content
PESTPP-IES is described by White (2018). The reader is referred to that paper for a description of what it does and how it works, together with an example of its use. Chen and Oliver (2013) describe in detail the theory on which the iterative ensemble smoother methodology implemented by PESTPP-IES rests; they also provide deployment examples.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 9. PESTPP-IES
- **Subsection:** 9.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into "regul" groups, adjusting weights with a regularization weight factor.
- **Detailed Summary:** Tikhonov regularization enhances stability by reducing error variance and incorporating expert knowledge. To ensure stability, use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. User termination is recommended, especially in early calibration.

### Related Context
- **Previous Summary:** Table 8.2 lists optional PESTPP-OPT control variables (with defaults):  `opt_dec_var_groups`, `opt_external_dec_var_groups`, `opt_constraint_groups`, `opt_obj_func`, `opt_direction`, `opt_risk`, `opt_recalc_chance_every`, `parcov`, `par_sigma_range`, `opt_iter_tol`, `base_jacobian`, `hotstart_resfile`, `opt_coin_log`, `opt_std_weights`, `opt_skip_final`, `tie_by_group`, `enforce_tied_bounds`, `opt_stack_size`, and `opt_par_stack`/`opt_obs_stack`.  Parallel run variables are in section 5.3.6.
- **Next Summary:** PESTPP-IES quantifies model prediction uncertainties (arising from parameter uncertainty) by sampling the posterior parameter distribution (Equation 9.1: P(k\|h) = P(h\|k)P(k)), which is more useful than the prior distribution P(k) in decision-making contexts.  It uses an iterative ensemble smoother (less computationally expensive than MCMC, especially for many parameters),  handling parameter sets generated internally (using *parcov*) or externally (e.g., RANDPAR3, PyEMU, or SGEMS).  It does not assume model linearity.

### Metadata
- **Keywords:** 
- **Chunk ID:** 723c76593a2c
- **Chunk Index:** 1
- **Previous Chunk ID:** bc706cf8a1bc
- **Next Chunk ID:** 7172af38ed19

---

## Context

### Summary
**PESTPP-GLM (originally PESTPP) is a modular, object-oriented C++ program offering PEST's functionality and improved performance. It performs highly parameterized inversion and (optionally) global optimization using differential evolution, controlled by control variables. It uses a built-in parallel run manager.**

### Header
**6.1 Introduction**

### Content
PESTPP-GLM was the original member of the PEST++ suite; its original name was “PESTPP”. The intention behind its creation was to reproduce much of the functionality of PEST in code that is modular, object oriented and supportive of collaborative programming. At the same time, it was hoped that certain aspects of PEST’s performance could be improved by taking advantage of the “new slate” that was offered by PESTPP-GLM.
Like all versions of the PEST++ suite, PESTPP-GLM is written in C++. PESTPP-GLM uses a built-in parallel run manager.
Like PEST, PESTPP-GLM undertakes highly parameterized inversion. However, if requested, it can also undertake global optimization using the differential evolution (DE) method. The task that it implements on any given run is determined by the values that are supplied for pertinent control variables.
 6.2 Highly Parameterized Inversion

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 6. PESTPP-GLM
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST++ programs create temporary binary run storage files (case.rns, case.rnu, case.rnj, case=control file base name) for parallel run management and restarts. These files are deleted on graceful exit and can be processed using pyEMU.
- **Next Summary:** PESTPP-GLM uses gradient methods (repeated linearization, Doherty 2015) to calibrate models (Equation 6.1: h=Zk+ε).  Tikhonov regularization (PESTMODE="regularization", "regul" groups) adds constraints (Equation 6.2).  Parameter estimates (k) are calculated iteratively (Equation 6.3, incorporating Marquardt lambda in Equation 6.5 for nonlinear models). The objective function (Փ, Equation 6.6) sums weighted squared discrepancies,  including measurement (Փm) and regularization (Փr) components (Equation 6.7).

### Metadata
- **Keywords:** 
- **Chunk ID:** 5856de1d97ed
- **Chunk Index:** 1
- **Previous Chunk ID:** 8f7c85ac1a26
- **Next Chunk ID:** f6bcfffaff4d

---

```

# System Prompt
```

You are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:

**Direct Answer First:**
- Begin with a comprehensive answer that directly addresses the question
- Include all relevant details and context from the documentation
- Don't artificially limit the length - be as thorough as the documentation allows
- Use clear paragraphs and formatting for readability
- NEVER invent, infer, or add information not explicitly present in the documentation

Then, continue with the detailed structure:

1. **Detailed Analysis:**  
   - Use the following structure:

     **1) Definition/Overview**  
     - For technical terms: provide a complete definition with all relevant details
     - For broader questions: provide a thorough overview of the topic
     - Include all relevant context and relationships
     - Cite source(s) using the format "File: [filename], Section: [header]".

     **2) Possible Values**  
     - If applicable: describe all valid or recognized values in detail
     - Include defaults, ranges, and special cases if documented
     - If not applicable: state "Not applicable for this topic"
     - Cite source(s).

     **3) Implications**  
     - Provide a thorough explanation of all usage considerations and consequences
     - Include any relationships with other components or features
     - If not available, state: "Information not available in the provided content."

     **4) Practical Usage Notes**  
     - Include all usage notes, examples, and practical applications
     - Provide context for when and how to use the feature/component
     - Otherwise, state: "No usage notes found in the provided content."

     **5) Keywords**  
     - List ONLY keywords that are EXPLICITLY present in the provided documentation
     - Keywords must be copied EXACTLY as they appear in the documentation
     - DO NOT infer, generate, or create keywords that are not explicitly listed
     - If no keywords are found in the documentation, you MUST state EXACTLY: "No keywords found in the provided content"
     - DO NOT add any explanation or commentary about keywords

2. **Follow-up Questions:**  
   - After your main answer, list **exactly 3 follow-up questions**
   - Questions MUST:
     - If the original query was fully answered:
       - Be directly related to the original query "{query}"
       - Lead to deeper understanding of the main topic
     - If the original query was partially answered or not answered:
       - Focus on related topics found in the documentation
       - Help build context around the topic
     - In all cases:
       - Be derived from content in Additional Summaries and Related Context sections
       - ONLY ask questions that can be answered with the available content
       - Ask ONE single thing - no "if/how/why" combinations
       - Be concise and direct
       - AVOID: "if so", "and how", "under what conditions", "and why"
   - Examples of GOOD questions (one thing only and general question):
     - "What is the purpose of nonlinear penalty functions?"
     - "How does PEST handle parameter bounds during the regularization process?"
     - "How does PEST calculate parameter sensitivities?"
   - Examples of BAD questions (too compound or not answerable):
     - "Can OBS2OBS process observations directly, and if so, how?"
     - "Can PEST incorporate predictive noise in the regularization objective function, and if so, how?"
     - "What are the equations and when should they be used?"
     - "Does PEST support parallel processing and how does it work?"
     - "What are the specific roles of Cooley (1983) and Hill (1992) techniques in the development of PEST's dampening method?"
   - Before writing each question, verify that its answer exists in the documentation
   - Present as a simple numbered list (1-3)

3. **Important Instructions:**  
   - **Do not mention internal processes, "chunks," or retrieval steps.**  
   - **Do not include any self-commentary or extra explanations.**
   - Use only the documentation provided in `{context}`.

Answer strictly following the structure and rules above.

```

# Full User Message
```

Question: What is PEST++?

Please provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:

1. **Cite Sources:**  
   - Use the format "File: [filename], Section: [header]" whenever you reference specific details.

2. **Include Examples:**  
   - Provide relevant examples from the documentation if available.

3. **Note Limitations:**  
   - If the documentation is incomplete or ambiguous, explicitly state: "Information not available in the provided content."

4. **Follow-up Questions:**  
   - After your main answer, list **exactly 3 follow-up questions** based primarily on:
     - "Additional Summaries" sections
     - "Related Context" sections
   - Each question must reference its source section
   - Do not provide answers to these questions
   - Present as a simple numbered list (1-3)

5. **Keywords Section:**  
   - Include a "Keywords" section if applicable.
   - If none are provided, state: "No keywords found in the provided content."

6. **Avoid Internal Details:**  
   - Do not mention internal processes or retrieval steps.
   - Do not include self-commentary or extra explanations.

7. **Be Concise and Accurate:**  
   - NEVER invent details, assumptions, or content
   - ONLY use information EXPLICITLY stated in the provided documentation
   - If information is missing, state EXACTLY: "Information not available in the provided content"
   - DO NOT try to fill gaps or make assumptions about missing information
   - When in doubt, acknowledge the limitation of the available information

**Available Documentation with Metadata:**
# Search Results for: What is PEST++?

Keywords: None


## Context

### Summary
**This chapter (reproducing text from the seventh PEST manual) describes template and instruction files used by both PEST and PEST++ for non-intrusive model interfacing.**

### Header
**2.1 Introduction**

### Content
This chapter reproduces material from the seventh edition of the PEST manual. This reflects the fact that programs of both the PEST and PEST++ suites employ template and instruction files as the basis for their non-intrusive model interface.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 2.  The PEST(++) Model Interface
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** PEST software uses template, instruction, and control files for model input and output. Templates, created with text editor or software, are validated with TEMPCHEK, INSCHEK, and PESTCHEK. Parameters are replaced in templates, and model input files should match for precision. Instruction files extract model outputs. Precision is crucial for accurate derivative calculations.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST++ programs read "observations" (model outputs) from model output files.  A PEST control file provides measured counterparts ("observations" with zero weight are predictions).  Predictions are used in uncertainty analyses and data worth analyses.
- **Next Summary:** PEST and PEST++ use template files (per model input file with parameters/decision variables), instruction files (per model output file), and a control file.  These files (created via text editor or specialized software) are checked using TEMPCHEK, INSCHEK, and PESTCHEK (Part II, Doherty 2018b). "Parameter" denotes parameters/decision variables; "observation" denotes numbers from model output files (including predictions).

### Metadata
- **Keywords:** 
- **Chunk ID:** d958d12cdc96
- **Chunk Index:** 1
- **Previous Chunk ID:** 112773e58ce3
- **Next Chunk ID:** b52992d44304

---

## Context

### Summary
**PEST++ programs (Table 1.1) perform various functions (inversion, optimization, sensitivity analysis, data assimilation) using a PEST control file for parameters, observations, and algorithm control.  They use a modular parallel run manager and TCP/IP communication.  PEST++ programs use template and instruction files for non-intrusive model interaction and ignore PEST++-specific control variables (++).**

### Header
**1.1 PEST++ and PEST**

### Content
The name “PEST++” refers to a suite of programs which have some things in common but which are also very different from each other. The names of all programs which comprise the suite begin with “PESTPP”. PEST stands for “Parameter ESTimation”.
PEST was released in 1995; it has been continually improved since then. It undertakes highly parameterized inversion of environmental models. In doing so, it runs a model many times, either sequentially or in parallel. It does this in a non-intrusive manner. Before it runs a model, it records parameter values that it wishes the model to use on that particular run via input files required by the model. User-prepared template files of model input files guide it in this task. After the model run is complete, PEST reads numbers from model output files which it then compares with field measurements. User-prepared instruction files guide it in this task. All other information which PEST requires is recorded in a PEST control file.
PESTPP-GLM is the original member of the PEST++ suite; it was originally named “PEST++” itself. Like PEST, PESTPP-GLM undertakes non-intrusive, highly parameterized inversion of an environmental model. As such, it can be considered as a direct replacement for PEST. While omitting some PEST functionality, it includes significant functionality that is absent from PEST. It uses the same template and instruction files that PEST uses to interact with a model. It reads a PEST control file to acquire information on problem definition. Like PEST, it can conduct model runs in serial or in parallel.
For all members of the PEST++ suite, parallelization of model runs follows the “manager” and “agent” concept. A user must start up agents in all folders in which he/she wishes that model runs be carried out. Agents can run on the same computer as the manager, on network-connected personal computers, on nodes of a high-performance computing cluster, and on the cloud. Agents communicate with their manager using the TCP/IP protocol. If the manager’s machine can be “pinged” from the agent’s machine, and if an agent’s machine can be “pinged” from the manager’s machine, then communication channels are open for parallelization of model runs. Whenever a member of the PEST++ suite requires that a model run be undertaken, its parallel run manager chooses a agent for the task, and then sends to the agent the numbers that must be written to model input files. Using template files, the agent writes these numbers to model input files; then it commands its local operating system to run the model. When the model run is complete, it reads model output files using instruction files. It then sends the numbers which it reads from these files back to the manager using TCP/IP.
One of the original design specifications of PESTPP-GLM was that its parallel run manager be modular, and separate from PESTPP-GLM, so that it could be used by any program that conducts non-intrusive, parallelized model runs for any purpose. It is this facet of its design that has spawned the development of other members of the PEST++ suite. At the time of writing, the composition of the PEST++ suite is listed in table 1.1.
| Program Name | Function                                                                                                  |
|------------------|---------------------------------------------------------------------------------------------------------------|
| PESTPP           | Highly parameterized inversion, and global optimization using differential evolution                          |
| PESTPP-SEN       | Global sensitivity analysis using the methods of Morris and Saltelli                                          |
| PESTPP-OPT       | Decision optimization under uncertainty using sequential linear programming and linearized chance constraints |
| PESTPP-IES       | Iterative ensemble smoother for production of a suite of calibration-constrained parameter fields             |
| PESTPP-SWP       | Undertakes a suite of parallelized model runs for any reason                                                  |
| PESTPP-DA        | Iterative ensemble filter and smoother data assimilation                                                      |
| PESTPP-MOU       | Single and multiple constrained optimization under uncertainty using evolutionary heuristics                  |
Table 1.1 Programs comprising of the PEST++ suite.
As well as containing a build-in parallel run manager (and hence of template and instruction files as a mechanism for non-intrusive communication with a model), the programs listed in table 1.1 have other commonalities. They all manipulate model parameters (which sometimes play the roles of decision variables). Most of them quantify mismatch between model outputs and field data. Information on parameters and field data is obtained from a PEST control file. So too is information that controls the way in which their algorithms operate.
Use of a PEST control file for storage of parameter, observation and control data was an important design consideration for the original version of PESTPP-GLM. This allowed interchangeable use with PEST. This remains a consideration for many members of the PEST++ suite.
When reading a PEST control file, most programs of the PEST++ suite obtain the values of control variables that are unique to that program from lines within the PEST control file that begin with the “++” string. PEST, and most of its associated utility software, ignores these lines. Interoperability of the PEST and PEST++ suites is thereby maintained.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 1. Introduction
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** To install PEST, copy its executables to a folder in the PATH variable for access from any directory. The suite includes PEST, Parallel PEST, BEOPEST, SENSAN, global optimizers, and utilities. PEST calibrates models by matching outputs to measurements, handling non-uniqueness through regularization. It quantifies uncertainties and supports decision-making by identifying unlikely events.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** This document references: Belsley et al. (1980) (regression diagnostics), Cook and Weisberg (1982) (regression residuals), Doherty (2015) (calibration and uncertainty), Doherty and Hunt (2009) (parameter identifiability), Hadi (1992) (influence measure), Hill and Tiedeman (2007) (groundwater model calibration), Koch (1999) (linear models), Lima et al. (2022) (data-space inversion), Sun and Durlofsky (2017) (uncertainty quantification), White et al. (2014) (model error), and Yager (1998) (influential observations).
- **Next Summary:** PEST++ programs create PEST-compatible parameter value (PAR) and Jacobian matrix (JCO) files. This interoperability allows PEST utilities (Doherty et al. 2018c) to process PEST++ results.  The PEST control file is also compatible.

### Metadata
- **Keywords:** 
- **Chunk ID:** 00e24a2e92bb
- **Chunk Index:** 1
- **Previous Chunk ID:** 6a90459bf216
- **Next Chunk ID:** 46d56be441df

---

## Context

### Summary
**This chapter, drawing from the seventh PEST manual, describes common features of PEST and PEST++ control files to facilitate understanding of control variable settings.**

### Header
**3.1 General**

### Content
Before describing the PEST control file, certain features that programs of the PEST++ suite have in common are discussed. This will make the task of explaining the settings of PEST and PEST++ control variables somewhat easier.
As for the previous and ensuing chapters of this manual, parts of the present chapter are taken from version 7 of the PEST manual.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 3. Some Important PEST++ Features
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Instruction files are created using a text editor, model GUI, PEST utilities, or pyEMU.  Incorrect instructions may cause run-time errors or undetected issues. PEST++ programs check instruction/control file consistency (*check_tplins* disables this). PESTCHEK verifies all instruction files in a control file; INSCHEK verifies individual files and tests output reading. Observation names are limited to 20 characters.
- **Next Summary:** PEST++ programs adjust parameter values or their base-10 logarithms (specified by PARTRANS in the "parameter data" section), improving stability and speed.  Prior information must use log-transformed values for log-transformed parameters.  Programs report errors for invalid log transformations (initial value or lower bound ≤0). PAR2PAR (Part II) handles complex transformations.

### Metadata
- **Keywords:** 
- **Chunk ID:** 2a3314cb00c1
- **Chunk Index:** 1
- **Previous Chunk ID:** c6acc3e4e825
- **Next Chunk ID:** ae4f52f7b5a7

---

## Context

### Summary
**PESTPP-IES performs iterative ensemble smoothing (described by White 2018, including examples, and Chen and Oliver 2013, including theory and examples).  Refer to these sources for details.**

### Header
**9.1.1 Publications**

### Content
PESTPP-IES is described by White (2018). The reader is referred to that paper for a description of what it does and how it works, together with an example of its use. Chen and Oliver (2013) describe in detail the theory on which the iterative ensemble smoother methodology implemented by PESTPP-IES rests; they also provide deployment examples.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 9. PESTPP-IES
- **Subsection:** 9.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into "regul" groups, adjusting weights with a regularization weight factor.
- **Detailed Summary:** Tikhonov regularization enhances stability by reducing error variance and incorporating expert knowledge. To ensure stability, use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. User termination is recommended, especially in early calibration.

### Related Context
- **Previous Summary:** Table 8.2 lists optional PESTPP-OPT control variables (with defaults):  `opt_dec_var_groups`, `opt_external_dec_var_groups`, `opt_constraint_groups`, `opt_obj_func`, `opt_direction`, `opt_risk`, `opt_recalc_chance_every`, `parcov`, `par_sigma_range`, `opt_iter_tol`, `base_jacobian`, `hotstart_resfile`, `opt_coin_log`, `opt_std_weights`, `opt_skip_final`, `tie_by_group`, `enforce_tied_bounds`, `opt_stack_size`, and `opt_par_stack`/`opt_obs_stack`.  Parallel run variables are in section 5.3.6.
- **Next Summary:** PESTPP-IES quantifies model prediction uncertainties (arising from parameter uncertainty) by sampling the posterior parameter distribution (Equation 9.1: P(k\|h) = P(h\|k)P(k)), which is more useful than the prior distribution P(k) in decision-making contexts.  It uses an iterative ensemble smoother (less computationally expensive than MCMC, especially for many parameters),  handling parameter sets generated internally (using *parcov*) or externally (e.g., RANDPAR3, PyEMU, or SGEMS).  It does not assume model linearity.

### Metadata
- **Keywords:** 
- **Chunk ID:** 723c76593a2c
- **Chunk Index:** 1
- **Previous Chunk ID:** bc706cf8a1bc
- **Next Chunk ID:** 7172af38ed19

---

## Context

### Summary
**PESTPP-GLM (originally PESTPP) is a modular, object-oriented C++ program offering PEST's functionality and improved performance. It performs highly parameterized inversion and (optionally) global optimization using differential evolution, controlled by control variables. It uses a built-in parallel run manager.**

### Header
**6.1 Introduction**

### Content
PESTPP-GLM was the original member of the PEST++ suite; its original name was “PESTPP”. The intention behind its creation was to reproduce much of the functionality of PEST in code that is modular, object oriented and supportive of collaborative programming. At the same time, it was hoped that certain aspects of PEST’s performance could be improved by taking advantage of the “new slate” that was offered by PESTPP-GLM.
Like all versions of the PEST++ suite, PESTPP-GLM is written in C++. PESTPP-GLM uses a built-in parallel run manager.
Like PEST, PESTPP-GLM undertakes highly parameterized inversion. However, if requested, it can also undertake global optimization using the differential evolution (DE) method. The task that it implements on any given run is determined by the values that are supplied for pertinent control variables.
 6.2 Highly Parameterized Inversion

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 6. PESTPP-GLM
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST++ programs create temporary binary run storage files (case.rns, case.rnu, case.rnj, case=control file base name) for parallel run management and restarts. These files are deleted on graceful exit and can be processed using pyEMU.
- **Next Summary:** PESTPP-GLM uses gradient methods (repeated linearization, Doherty 2015) to calibrate models (Equation 6.1: h=Zk+ε).  Tikhonov regularization (PESTMODE="regularization", "regul" groups) adds constraints (Equation 6.2).  Parameter estimates (k) are calculated iteratively (Equation 6.3, incorporating Marquardt lambda in Equation 6.5 for nonlinear models). The objective function (Փ, Equation 6.6) sums weighted squared discrepancies,  including measurement (Փm) and regularization (Փr) components (Equation 6.7).

### Metadata
- **Keywords:** 
- **Chunk ID:** 5856de1d97ed
- **Chunk Index:** 1
- **Previous Chunk ID:** 8f7c85ac1a26
- **Next Chunk ID:** f6bcfffaff4d

---


Answer strictly following the above instructions.

```

# Complete Messages Array
```json
[
  {
    "role": "system",
    "content": "\nYou are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:\n\n**Direct Answer First:**\n- Begin with a comprehensive answer that directly addresses the question\n- Include all relevant details and context from the documentation\n- Don't artificially limit the length - be as thorough as the documentation allows\n- Use clear paragraphs and formatting for readability\n- NEVER invent, infer, or add information not explicitly present in the documentation\n\nThen, continue with the detailed structure:\n\n1. **Detailed Analysis:**  \n   - Use the following structure:\n\n     **1) Definition/Overview**  \n     - For technical terms: provide a complete definition with all relevant details\n     - For broader questions: provide a thorough overview of the topic\n     - Include all relevant context and relationships\n     - Cite source(s) using the format \"File: [filename], Section: [header]\".\n\n     **2) Possible Values**  \n     - If applicable: describe all valid or recognized values in detail\n     - Include defaults, ranges, and special cases if documented\n     - If not applicable: state \"Not applicable for this topic\"\n     - Cite source(s).\n\n     **3) Implications**  \n     - Provide a thorough explanation of all usage considerations and consequences\n     - Include any relationships with other components or features\n     - If not available, state: \"Information not available in the provided content.\"\n\n     **4) Practical Usage Notes**  \n     - Include all usage notes, examples, and practical applications\n     - Provide context for when and how to use the feature/component\n     - Otherwise, state: \"No usage notes found in the provided content.\"\n\n     **5) Keywords**  \n     - List ONLY keywords that are EXPLICITLY present in the provided documentation\n     - Keywords must be copied EXACTLY as they appear in the documentation\n     - DO NOT infer, generate, or create keywords that are not explicitly listed\n     - If no keywords are found in the documentation, you MUST state EXACTLY: \"No keywords found in the provided content\"\n     - DO NOT add any explanation or commentary about keywords\n\n2. **Follow-up Questions:**  \n   - After your main answer, list **exactly 3 follow-up questions**\n   - Questions MUST:\n     - If the original query was fully answered:\n       - Be directly related to the original query \"{query}\"\n       - Lead to deeper understanding of the main topic\n     - If the original query was partially answered or not answered:\n       - Focus on related topics found in the documentation\n       - Help build context around the topic\n     - In all cases:\n       - Be derived from content in Additional Summaries and Related Context sections\n       - ONLY ask questions that can be answered with the available content\n       - Ask ONE single thing - no \"if/how/why\" combinations\n       - Be concise and direct\n       - AVOID: \"if so\", \"and how\", \"under what conditions\", \"and why\"\n   - Examples of GOOD questions (one thing only and general question):\n     - \"What is the purpose of nonlinear penalty functions?\"\n     - \"How does PEST handle parameter bounds during the regularization process?\"\n     - \"How does PEST calculate parameter sensitivities?\"\n   - Examples of BAD questions (too compound or not answerable):\n     - \"Can OBS2OBS process observations directly, and if so, how?\"\n     - \"Can PEST incorporate predictive noise in the regularization objective function, and if so, how?\"\n     - \"What are the equations and when should they be used?\"\n     - \"Does PEST support parallel processing and how does it work?\"\n     - \"What are the specific roles of Cooley (1983) and Hill (1992) techniques in the development of PEST's dampening method?\"\n   - Before writing each question, verify that its answer exists in the documentation\n   - Present as a simple numbered list (1-3)\n\n3. **Important Instructions:**  \n   - **Do not mention internal processes, \"chunks,\" or retrieval steps.**  \n   - **Do not include any self-commentary or extra explanations.**\n   - Use only the documentation provided in `{context}`.\n\nAnswer strictly following the structure and rules above.\n"
  },
  {
    "role": "user",
    "content": "\nQuestion: What is PEST++?\n\nPlease provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:\n\n1. **Cite Sources:**  \n   - Use the format \"File: [filename], Section: [header]\" whenever you reference specific details.\n\n2. **Include Examples:**  \n   - Provide relevant examples from the documentation if available.\n\n3. **Note Limitations:**  \n   - If the documentation is incomplete or ambiguous, explicitly state: \"Information not available in the provided content.\"\n\n4. **Follow-up Questions:**  \n   - After your main answer, list **exactly 3 follow-up questions** based primarily on:\n     - \"Additional Summaries\" sections\n     - \"Related Context\" sections\n   - Each question must reference its source section\n   - Do not provide answers to these questions\n   - Present as a simple numbered list (1-3)\n\n5. **Keywords Section:**  \n   - Include a \"Keywords\" section if applicable.\n   - If none are provided, state: \"No keywords found in the provided content.\"\n\n6. **Avoid Internal Details:**  \n   - Do not mention internal processes or retrieval steps.\n   - Do not include self-commentary or extra explanations.\n\n7. **Be Concise and Accurate:**  \n   - NEVER invent details, assumptions, or content\n   - ONLY use information EXPLICITLY stated in the provided documentation\n   - If information is missing, state EXACTLY: \"Information not available in the provided content\"\n   - DO NOT try to fill gaps or make assumptions about missing information\n   - When in doubt, acknowledge the limitation of the available information\n\n**Available Documentation with Metadata:**\n# Search Results for: What is PEST++?\n\nKeywords: None\n\n\n## Context\n\n### Summary\n**This chapter (reproducing text from the seventh PEST manual) describes template and instruction files used by both PEST and PEST++ for non-intrusive model interfacing.**\n\n### Header\n**2.1 Introduction**\n\n### Content\nThis chapter reproduces material from the seventh edition of the PEST manual. This reflects the fact that programs of both the PEST and PEST++ suites employ template and instruction files as the basis for their non-intrusive model interface.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 2.  The PEST(++) Model Interface\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** PEST software uses template, instruction, and control files for model input and output. Templates, created with text editor or software, are validated with TEMPCHEK, INSCHEK, and PESTCHEK. Parameters are replaced in templates, and model input files should match for precision. Instruction files extract model outputs. Precision is crucial for accurate derivative calculations.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** PEST++ programs read \"observations\" (model outputs) from model output files.  A PEST control file provides measured counterparts (\"observations\" with zero weight are predictions).  Predictions are used in uncertainty analyses and data worth analyses.\n- **Next Summary:** PEST and PEST++ use template files (per model input file with parameters/decision variables), instruction files (per model output file), and a control file.  These files (created via text editor or specialized software) are checked using TEMPCHEK, INSCHEK, and PESTCHEK (Part II, Doherty 2018b). \"Parameter\" denotes parameters/decision variables; \"observation\" denotes numbers from model output files (including predictions).\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** d958d12cdc96\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 112773e58ce3\n- **Next Chunk ID:** b52992d44304\n\n---\n\n## Context\n\n### Summary\n**PEST++ programs (Table 1.1) perform various functions (inversion, optimization, sensitivity analysis, data assimilation) using a PEST control file for parameters, observations, and algorithm control.  They use a modular parallel run manager and TCP/IP communication.  PEST++ programs use template and instruction files for non-intrusive model interaction and ignore PEST++-specific control variables (++).**\n\n### Header\n**1.1 PEST++ and PEST**\n\n### Content\nThe name “PEST++” refers to a suite of programs which have some things in common but which are also very different from each other. The names of all programs which comprise the suite begin with “PESTPP”. PEST stands for “Parameter ESTimation”.\nPEST was released in 1995; it has been continually improved since then. It undertakes highly parameterized inversion of environmental models. In doing so, it runs a model many times, either sequentially or in parallel. It does this in a non-intrusive manner. Before it runs a model, it records parameter values that it wishes the model to use on that particular run via input files required by the model. User-prepared template files of model input files guide it in this task. After the model run is complete, PEST reads numbers from model output files which it then compares with field measurements. User-prepared instruction files guide it in this task. All other information which PEST requires is recorded in a PEST control file.\nPESTPP-GLM is the original member of the PEST++ suite; it was originally named “PEST++” itself. Like PEST, PESTPP-GLM undertakes non-intrusive, highly parameterized inversion of an environmental model. As such, it can be considered as a direct replacement for PEST. While omitting some PEST functionality, it includes significant functionality that is absent from PEST. It uses the same template and instruction files that PEST uses to interact with a model. It reads a PEST control file to acquire information on problem definition. Like PEST, it can conduct model runs in serial or in parallel.\nFor all members of the PEST++ suite, parallelization of model runs follows the “manager” and “agent” concept. A user must start up agents in all folders in which he/she wishes that model runs be carried out. Agents can run on the same computer as the manager, on network-connected personal computers, on nodes of a high-performance computing cluster, and on the cloud. Agents communicate with their manager using the TCP/IP protocol. If the manager’s machine can be “pinged” from the agent’s machine, and if an agent’s machine can be “pinged” from the manager’s machine, then communication channels are open for parallelization of model runs. Whenever a member of the PEST++ suite requires that a model run be undertaken, its parallel run manager chooses a agent for the task, and then sends to the agent the numbers that must be written to model input files. Using template files, the agent writes these numbers to model input files; then it commands its local operating system to run the model. When the model run is complete, it reads model output files using instruction files. It then sends the numbers which it reads from these files back to the manager using TCP/IP.\nOne of the original design specifications of PESTPP-GLM was that its parallel run manager be modular, and separate from PESTPP-GLM, so that it could be used by any program that conducts non-intrusive, parallelized model runs for any purpose. It is this facet of its design that has spawned the development of other members of the PEST++ suite. At the time of writing, the composition of the PEST++ suite is listed in table 1.1.\n| Program Name | Function                                                                                                  |\n|------------------|---------------------------------------------------------------------------------------------------------------|\n| PESTPP           | Highly parameterized inversion, and global optimization using differential evolution                          |\n| PESTPP-SEN       | Global sensitivity analysis using the methods of Morris and Saltelli                                          |\n| PESTPP-OPT       | Decision optimization under uncertainty using sequential linear programming and linearized chance constraints |\n| PESTPP-IES       | Iterative ensemble smoother for production of a suite of calibration-constrained parameter fields             |\n| PESTPP-SWP       | Undertakes a suite of parallelized model runs for any reason                                                  |\n| PESTPP-DA        | Iterative ensemble filter and smoother data assimilation                                                      |\n| PESTPP-MOU       | Single and multiple constrained optimization under uncertainty using evolutionary heuristics                  |\nTable 1.1 Programs comprising of the PEST++ suite.\nAs well as containing a build-in parallel run manager (and hence of template and instruction files as a mechanism for non-intrusive communication with a model), the programs listed in table 1.1 have other commonalities. They all manipulate model parameters (which sometimes play the roles of decision variables). Most of them quantify mismatch between model outputs and field data. Information on parameters and field data is obtained from a PEST control file. So too is information that controls the way in which their algorithms operate.\nUse of a PEST control file for storage of parameter, observation and control data was an important design consideration for the original version of PESTPP-GLM. This allowed interchangeable use with PEST. This remains a consideration for many members of the PEST++ suite.\nWhen reading a PEST control file, most programs of the PEST++ suite obtain the values of control variables that are unique to that program from lines within the PEST control file that begin with the “++” string. PEST, and most of its associated utility software, ignores these lines. Interoperability of the PEST and PEST++ suites is thereby maintained.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 1. Introduction\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** To install PEST, copy its executables to a folder in the PATH variable for access from any directory. The suite includes PEST, Parallel PEST, BEOPEST, SENSAN, global optimizers, and utilities. PEST calibrates models by matching outputs to measurements, handling non-uniqueness through regularization. It quantifies uncertainties and supports decision-making by identifying unlikely events.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** This document references: Belsley et al. (1980) (regression diagnostics), Cook and Weisberg (1982) (regression residuals), Doherty (2015) (calibration and uncertainty), Doherty and Hunt (2009) (parameter identifiability), Hadi (1992) (influence measure), Hill and Tiedeman (2007) (groundwater model calibration), Koch (1999) (linear models), Lima et al. (2022) (data-space inversion), Sun and Durlofsky (2017) (uncertainty quantification), White et al. (2014) (model error), and Yager (1998) (influential observations).\n- **Next Summary:** PEST++ programs create PEST-compatible parameter value (PAR) and Jacobian matrix (JCO) files. This interoperability allows PEST utilities (Doherty et al. 2018c) to process PEST++ results.  The PEST control file is also compatible.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 00e24a2e92bb\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 6a90459bf216\n- **Next Chunk ID:** 46d56be441df\n\n---\n\n## Context\n\n### Summary\n**This chapter, drawing from the seventh PEST manual, describes common features of PEST and PEST++ control files to facilitate understanding of control variable settings.**\n\n### Header\n**3.1 General**\n\n### Content\nBefore describing the PEST control file, certain features that programs of the PEST++ suite have in common are discussed. This will make the task of explaining the settings of PEST and PEST++ control variables somewhat easier.\nAs for the previous and ensuing chapters of this manual, parts of the present chapter are taken from version 7 of the PEST manual.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 3. Some Important PEST++ Features\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: \"estimation\", \"predictive analysis\", \"regularisation\", and \"pareto\". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** Instruction files are created using a text editor, model GUI, PEST utilities, or pyEMU.  Incorrect instructions may cause run-time errors or undetected issues. PEST++ programs check instruction/control file consistency (*check_tplins* disables this). PESTCHEK verifies all instruction files in a control file; INSCHEK verifies individual files and tests output reading. Observation names are limited to 20 characters.\n- **Next Summary:** PEST++ programs adjust parameter values or their base-10 logarithms (specified by PARTRANS in the \"parameter data\" section), improving stability and speed.  Prior information must use log-transformed values for log-transformed parameters.  Programs report errors for invalid log transformations (initial value or lower bound ≤0). PAR2PAR (Part II) handles complex transformations.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 2a3314cb00c1\n- **Chunk Index:** 1\n- **Previous Chunk ID:** c6acc3e4e825\n- **Next Chunk ID:** ae4f52f7b5a7\n\n---\n\n## Context\n\n### Summary\n**PESTPP-IES performs iterative ensemble smoothing (described by White 2018, including examples, and Chen and Oliver 2013, including theory and examples).  Refer to these sources for details.**\n\n### Header\n**9.1.1 Publications**\n\n### Content\nPESTPP-IES is described by White (2018). The reader is referred to that paper for a description of what it does and how it works, together with an example of its use. Chen and Oliver (2013) describe in detail the theory on which the iterative ensemble smoother methodology implemented by PESTPP-IES rests; they also provide deployment examples.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 9. PESTPP-IES\n- **Subsection:** 9.1 Introduction\n\n### Additional Summaries\n- **Higher-Level Summary:** Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.\n- **Detailed Summary:** Tikhonov regularization enhances stability by reducing error variance and incorporating expert knowledge. To ensure stability, use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. User termination is recommended, especially in early calibration.\n\n### Related Context\n- **Previous Summary:** Table 8.2 lists optional PESTPP-OPT control variables (with defaults):  `opt_dec_var_groups`, `opt_external_dec_var_groups`, `opt_constraint_groups`, `opt_obj_func`, `opt_direction`, `opt_risk`, `opt_recalc_chance_every`, `parcov`, `par_sigma_range`, `opt_iter_tol`, `base_jacobian`, `hotstart_resfile`, `opt_coin_log`, `opt_std_weights`, `opt_skip_final`, `tie_by_group`, `enforce_tied_bounds`, `opt_stack_size`, and `opt_par_stack`/`opt_obs_stack`.  Parallel run variables are in section 5.3.6.\n- **Next Summary:** PESTPP-IES quantifies model prediction uncertainties (arising from parameter uncertainty) by sampling the posterior parameter distribution (Equation 9.1: P(k\\|h) = P(h\\|k)P(k)), which is more useful than the prior distribution P(k) in decision-making contexts.  It uses an iterative ensemble smoother (less computationally expensive than MCMC, especially for many parameters),  handling parameter sets generated internally (using *parcov*) or externally (e.g., RANDPAR3, PyEMU, or SGEMS).  It does not assume model linearity.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 723c76593a2c\n- **Chunk Index:** 1\n- **Previous Chunk ID:** bc706cf8a1bc\n- **Next Chunk ID:** 7172af38ed19\n\n---\n\n## Context\n\n### Summary\n**PESTPP-GLM (originally PESTPP) is a modular, object-oriented C++ program offering PEST's functionality and improved performance. It performs highly parameterized inversion and (optionally) global optimization using differential evolution, controlled by control variables. It uses a built-in parallel run manager.**\n\n### Header\n**6.1 Introduction**\n\n### Content\nPESTPP-GLM was the original member of the PEST++ suite; its original name was “PESTPP”. The intention behind its creation was to reproduce much of the functionality of PEST in code that is modular, object oriented and supportive of collaborative programming. At the same time, it was hoped that certain aspects of PEST’s performance could be improved by taking advantage of the “new slate” that was offered by PESTPP-GLM.\nLike all versions of the PEST++ suite, PESTPP-GLM is written in C++. PESTPP-GLM uses a built-in parallel run manager.\nLike PEST, PESTPP-GLM undertakes highly parameterized inversion. However, if requested, it can also undertake global optimization using the differential evolution (DE) method. The task that it implements on any given run is determined by the values that are supplied for pertinent control variables.\n 6.2 Highly Parameterized Inversion\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 6. PESTPP-GLM\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** Chapter 6 discusses automatic user intervention in PEST for regularization methods in parameter estimation. It suggests identifying and temporarily fixing insensitive parameters to improve matrix condition number and objective function. Parameters like DOAUI and MAXAUI customize intervention behavior, with options for mitigating bad derivatives and improving sensitivity.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** PEST++ programs create temporary binary run storage files (case.rns, case.rnu, case.rnj, case=control file base name) for parallel run management and restarts. These files are deleted on graceful exit and can be processed using pyEMU.\n- **Next Summary:** PESTPP-GLM uses gradient methods (repeated linearization, Doherty 2015) to calibrate models (Equation 6.1: h=Zk+ε).  Tikhonov regularization (PESTMODE=\"regularization\", \"regul\" groups) adds constraints (Equation 6.2).  Parameter estimates (k) are calculated iteratively (Equation 6.3, incorporating Marquardt lambda in Equation 6.5 for nonlinear models). The objective function (Փ, Equation 6.6) sums weighted squared discrepancies,  including measurement (Փm) and regularization (Փr) components (Equation 6.7).\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 5856de1d97ed\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 8f7c85ac1a26\n- **Next Chunk ID:** f6bcfffaff4d\n\n---\n\n\nAnswer strictly following the above instructions.\n"
  }
]
```