# Stream Debug - 20250206_185221

# Original Question
```
How do I use pest-opt?
```

# Context Content
```markdown
# Search Results for: How do I use pest-opt?

Keywords: None


## Context

### Summary
**PESTPP-OPT (described by White et al. 2018, and Wagner and Gorelick 1987) performs decision optimization under uncertainty using sequential linear programming.  Examples of its use are provided in White et al. (2018).**

### Header
**8.1.1 A Publication**

### Content
PESTPP-OPT is described by White et al (2018), where examples of its use are also provided. The following description summarizes information available from this source. See also Wagner and Gorelick (1987) where a similar methodology is described.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode (Doherty 2015, section 8.4), PEST maximizes/minimizes a prediction while maintaining the objective function below a threshold, assessing post-calibration uncertainty.  This works best with few parameters and a well-posed inverse problem; otherwise, use linear analysis, Monte Carlo, or Pareto methods.  The method requires high-integrity derivatives and a prior calibration process.

### Related Context
- **Previous Summary:** PESTPP-SEN generates various output files (Table 7.3, case=control file base name):  case.msn/case.group.msn/case.mio/case.raw.csv/case.group.raw.csv (Morris method only), case.sobol.si.csv/case.sobol.sti.csv/Case.sobol.obs.csv/Case.sobol.par.csv/case.sbl (Sobol method only), case.rmr (parallel runs), and Case.sen.par.csv (Morris only).  case.rns is a binary run management file.  All files use comma-delimited data except case.rns.  If all observation weights are zero, PESTPP-SEN resets them to 1.0.
- **Next Summary:** PESTPP-OPT solves constrained optimization problems considering uncertainties in model outputs (chance constraints).  Constraints are applied to predictive values adjusted for uncertainty (often pessimistically), using a calibrated model (minimized error variance, Doherty 2015) where model outputs are near the center of their posterior distributions.  Model parameter uncertainty stems from prior uncertainty and calibration data.

### Metadata
- **Keywords:** 
- **Chunk ID:** 9eb7ce055068
- **Chunk Index:** 1
- **Previous Chunk ID:** de2e82e22185
- **Next Chunk ID:** e05099b5052d

---

## Context

### Summary
**Parallel PEST (ppest.exe, i64ppest.exe) and BEOPEST (beopest32.exe, beopest64.exe) are automatically installed.  PAGENT.exe is required for Parallel PEST on each agent machine; BEOPEST uses its own executable as the agent.  Model programs and files must also be copied to agent machines before running Parallel PEST or BEOPEST.**

### Header
**11.1.5 Installing Parallel PEST and BEOPEST**

### Content
The command line version of the Parallel PEST executable ppest.exe, and its 64 bit version i64ppest.exe, are automatically installed when you install PEST on your machine. The same applies to the BEOPEST executables beopest32.exe and beopest64.exe.
As is explained below, for Parallel PEST to run a model on another machine it must signal an agent, named PAGENT, residing on the other machine to generate the command to run the model. Thus pagent.exe must be installed on each machine engaged in the Parallel PEST parameter estimation process. To do this, copy pagent.exe (also provided with PEST) to an appropriate directory (i.e. folder) on each such machine. This folder can be the model working folder on that machine if desired; if not, it should be a folder whose name is cited in the PATH environment variable on that machine.
BEOPEST does not use a special agent program. Rather BEOPEST itself is the agent. Hence beopest32.exe or beopest64.exe must be copied to agent machines in the same way as was described above for pagent.exe.
As will be discussed below, not only PEST programs, but model programs and accompanying files must also be copied to agent machines prior to initiating a parallel PEST or BEOPEST run.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.1 General (continuación)

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** Parallel PEST's efficiency decreases with short model run times due to file I/O and message passing latency. BEOPEST, using TCP/IP, minimizes these overheads because agents perform file I/O locally.
- **Next Summary:** Parallel PEST and BEOPEST store parameter and model output values in binary, direct access files (pest###.dap, pest###.dao), reducing memory needs. These files are deleted after a run but are needed for restarting using the "/s" switch.  Parallel PEST is described below, followed by BEOPEST.

### Metadata
- **Keywords:** 
- **Chunk ID:** 3de0f3c0071a
- **Chunk Index:** 1
- **Previous Chunk ID:** cb0f0bfcff07
- **Next Chunk ID:** d5b1ed60ac37

---

## Context

### Summary
**PESTPP-OPT uses a PEST control file (Chapter 5) defining parameters, calibration data (with noise), decision variables, constraints, objective function, and optimization control variables (keyword-value pairs, "++" prefix).  It requires a calibrated model.  The details of each of these are discussed below.**

### Header
**8.2.1The PEST Control File **

### Content
Like other members of the PEST++ suite, execution of PESTPP-OPT is initiated using a command line that references a PEST control file. See chapter 5 of this manual for details. The PEST control file supplied to PESTPP-OPT must define the optimization problem that it must solve. In particular, this PEST control file must inform it of the following:
- model parameters whose post-calibration uncertainties are responsible for the uncertainties of model outputs;
- model outputs for which there are counterparts in the calibration dataset;
- the noise associated with members of the calibration dataset;
- decision variables that must be optimized;
- model outputs to which constraints are applied during the optimization process;
- constraints that are exerted on linear combinations of parameters that do not require a model run to calculate;
- how the decision objective function is defined;
- the values of control variables that govern the constrained optimization process.
As is the normal protocol for members of the PEST++ suite, variables which control the optimization process that is implemented by PESTPP-OPT are supplied through keywords that can be placed anywhere within a PEST control file on lines that begin with the “++” string.
Each of the above issues is now discussed in detail.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.2 Using PESTPP-OPT

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode, PEST maximizes/minimizes a prediction (in the "predict" group) while keeping the objective function ≤ Φ0 (requires a prior "estimation" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.

### Related Context
- **Previous Summary:** PESTPP-OPT handles chance constraints (risk neutral, averse, or tolerant) by shifting constraint values based on a user-specified risk value (0.0-1.0) and the model output's standard deviation (σo).  A value of 0.5 ignores uncertainty; 0.95 applies constraints to the upper 95% confidence level.  This is based on chance-constraint programming (Charnes and Cooper 1959, etc.).
- **Next Summary:** In PESTPP-OPT, parameter groups define decision variables (*opt_dec_var_groups*) and model parameters.  *opt_external_dev_var_groups* (subset of *opt_dec_var_groups*) specifies external decision variables (requiring template files).  Finite-difference derivatives (using parameter group settings) may be needed for calculating the response matrix. Decision variables cannot be log-transformed but can be tied or fixed;  FACPARMAX and RELPARMAX limits do not apply.

### Metadata
- **Keywords:** 
- **Chunk ID:** 1eb4698ae37e
- **Chunk Index:** 1
- **Previous Chunk ID:** 135c3f141f17
- **Next Chunk ID:** 48b7d94626ad

---

## Context

### Summary
**PESTPP-OPT uses a PEST control file  (section 5.3 details parallel run management variables) to manage parallel model runs, similar to other PEST++ suite programs.**

### Header
**8.2.11 Other Control Variables**

### Content
In common with all other members of the PEST++ suite, a PEST control file used by PESTPP-OPT can include variables that govern parallel run management. See section 5.3 of this manual.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.2 Using PESTPP-OPT

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode, PEST maximizes/minimizes a prediction (in the "predict" group) while keeping the objective function ≤ Φ0 (requires a prior "estimation" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.

### Related Context
- **Previous Summary:** PESTPP-OPT uses sequential linear programming (SLP), iteratively solving a linearized problem.  Termination occurs when objective function/decision variable changes are ≤ *opt_iter_tol* (default 0.001).  *opt_coin_log* (1-4) controls the verbosity of the SLP solution history (case.coin_log).  J and y matrices are recalculated every *opt_recalc_fosm_every* iterations to partially accommodate nonlinearities.
- **Next Summary:** After optimization, PESTPP-OPT performs a final model run using optimized decision variables unless *opt_skip_final()* is used.  Optimized decision variable values remain in model input files.

### Metadata
- **Keywords:** 
- **Chunk ID:** 878845b6c3b0
- **Chunk Index:** 1
- **Previous Chunk ID:** ec6be79c7073
- **Next Chunk ID:** 2c0a945abae1

---

## Context

### Summary
**For large problems, use 64-bit versions of PEST, Parallel PEST, BEOPEST, and their utilities for faster execution and increased memory capacity.**

### Header
**15.3 Versions of PEST**

### Content
Where problem sizes are large, use 64 bit versions of PEST, Parallel PEST and BEOPEST (and of PEST support utilities for which 64 bit versions are provided). Execution is generally faster. Much more memory can be addressed.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 15. Large Numbers of Parameters
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter discusses efficient calibration methods for models with tens of thousands of parameters using PEST. Adjoint techniques are recommended for highly parameterized models. Use compressed binary external derivatives files, 64-bit versions of PEST for large problems, and optimize Jacobian matrix storage. Prioritize linearity of regularization constraints and activate memory conservation for improved efficiency.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** For highly parameterized models (tens of thousands), model-calculated derivatives (adjoint techniques, Chapter 12) are necessary due to the excessive number of model runs and imprecision of finite differences.  Compressed binary external derivatives files are recommended; elements should be ordered by observation then parameter for optimal efficiency.
- **Next Summary:** In highly parameterized inversions, Jacobian matrix storage (dimensions (no+np)×m) can be excessive.  Many sensitivities and Tikhonov regularization elements are often zero. A data storage mechanism that omits zero-valued elements significantly reduces PEST's memory requirements.

### Metadata
- **Keywords:** 
- **Chunk ID:** 99e9db574a30
- **Chunk Index:** 1
- **Previous Chunk ID:** 5d358602f4e2
- **Next Chunk ID:** 8c1f42813f75

---

```

# System Prompt
```

You are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:

**Direct Answer First:**
- Begin with a comprehensive answer that directly addresses the question
- Include all relevant details and context from the documentation
- Don't artificially limit the length - be as thorough as the documentation allows
- Use clear paragraphs and formatting for readability
- NEVER invent, infer, or add information not explicitly present in the documentation

Then, continue with the detailed structure:

1. **Detailed Analysis:**  
   - Use the following structure:

     **1) Definition/Overview**  
     - For technical terms: provide a complete definition with all relevant details
     - For broader questions: provide a thorough overview of the topic
     - Include all relevant context and relationships
     - Cite source(s) using the format "File: [filename], Section: [header]".

     **2) Possible Values**  
     - If applicable: describe all valid or recognized values in detail
     - Include defaults, ranges, and special cases if documented
     - If not applicable: state "Not applicable for this topic"
     - Cite source(s).

     **3) Implications**  
     - Provide a thorough explanation of all usage considerations and consequences
     - Include any relationships with other components or features
     - If not available, state: "Information not available in the provided content."

     **4) Practical Usage Notes**  
     - Include all usage notes, examples, and practical applications
     - Provide context for when and how to use the feature/component
     - Otherwise, state: "No usage notes found in the provided content."

     **5) Keywords**  
     - List ONLY keywords that are EXPLICITLY present in the provided documentation
     - Keywords must be copied EXACTLY as they appear in the documentation
     - DO NOT infer, generate, or create keywords that are not explicitly listed
     - If no keywords are found in the documentation, you MUST state EXACTLY: "No keywords found in the provided content"
     - DO NOT add any explanation or commentary about keywords

2. **Follow-up Questions:**  
   - After your main answer, list **exactly 3 follow-up questions**
   - Questions MUST:
     - If the original query was fully answered:
       - Be directly related to the original query "{query}"
       - Lead to deeper understanding of the main topic
     - If the original query was partially answered or not answered:
       - Focus on related topics found in the documentation
       - Help build context around the topic
     - In all cases:
       - Be derived from content in Additional Summaries and Related Context sections
       - ONLY ask questions that can be answered with the available content
       - Ask ONE single thing - no "if/how/why" combinations
       - Be concise and direct
       - AVOID: "if so", "and how", "under what conditions", "and why"
   - Examples of GOOD questions (one thing only and general question):
     - "What is the purpose of nonlinear penalty functions?"
     - "How does PEST handle parameter bounds during the regularization process?"
     - "How does PEST calculate parameter sensitivities?"
   - Examples of BAD questions (too compound or not answerable):
     - "Can OBS2OBS process observations directly, and if so, how?"
     - "Can PEST incorporate predictive noise in the regularization objective function, and if so, how?"
     - "What are the equations and when should they be used?"
     - "Does PEST support parallel processing and how does it work?"
     - "What are the specific roles of Cooley (1983) and Hill (1992) techniques in the development of PEST's dampening method?"
   - Before writing each question, verify that its answer exists in the documentation
   - Present as a simple numbered list (1-3)

3. **Important Instructions:**  
   - **Do not mention internal processes, "chunks," or retrieval steps.**  
   - **Do not include any self-commentary or extra explanations.**
   - Use only the documentation provided in `{context}`.

Answer strictly following the structure and rules above.

```

# Full User Message
```

Question: How do I use pest-opt?

Please provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:

1. **Cite Sources:**  
   - Use the format "File: [filename], Section: [header]" whenever you reference specific details.

2. **Include Examples:**  
   - Provide relevant examples from the documentation if available.

3. **Note Limitations:**  
   - If the documentation is incomplete or ambiguous, explicitly state: "Information not available in the provided content."

4. **Follow-up Questions:**  
   - After your main answer, list **exactly 3 follow-up questions** based primarily on:
     - "Additional Summaries" sections
     - "Related Context" sections
   - Each question must reference its source section
   - Do not provide answers to these questions
   - Present as a simple numbered list (1-3)

5. **Keywords Section:**  
   - Include a "Keywords" section if applicable.
   - If none are provided, state: "No keywords found in the provided content."

6. **Avoid Internal Details:**  
   - Do not mention internal processes or retrieval steps.
   - Do not include self-commentary or extra explanations.

7. **Be Concise and Accurate:**  
   - NEVER invent details, assumptions, or content
   - ONLY use information EXPLICITLY stated in the provided documentation
   - If information is missing, state EXACTLY: "Information not available in the provided content"
   - DO NOT try to fill gaps or make assumptions about missing information
   - When in doubt, acknowledge the limitation of the available information

**Available Documentation with Metadata:**
# Search Results for: How do I use pest-opt?

Keywords: None


## Context

### Summary
**PESTPP-OPT (described by White et al. 2018, and Wagner and Gorelick 1987) performs decision optimization under uncertainty using sequential linear programming.  Examples of its use are provided in White et al. (2018).**

### Header
**8.1.1 A Publication**

### Content
PESTPP-OPT is described by White et al (2018), where examples of its use are also provided. The following description summarizes information available from this source. See also Wagner and Gorelick (1987) where a similar methodology is described.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.1 Introduction

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode (Doherty 2015, section 8.4), PEST maximizes/minimizes a prediction while maintaining the objective function below a threshold, assessing post-calibration uncertainty.  This works best with few parameters and a well-posed inverse problem; otherwise, use linear analysis, Monte Carlo, or Pareto methods.  The method requires high-integrity derivatives and a prior calibration process.

### Related Context
- **Previous Summary:** PESTPP-SEN generates various output files (Table 7.3, case=control file base name):  case.msn/case.group.msn/case.mio/case.raw.csv/case.group.raw.csv (Morris method only), case.sobol.si.csv/case.sobol.sti.csv/Case.sobol.obs.csv/Case.sobol.par.csv/case.sbl (Sobol method only), case.rmr (parallel runs), and Case.sen.par.csv (Morris only).  case.rns is a binary run management file.  All files use comma-delimited data except case.rns.  If all observation weights are zero, PESTPP-SEN resets them to 1.0.
- **Next Summary:** PESTPP-OPT solves constrained optimization problems considering uncertainties in model outputs (chance constraints).  Constraints are applied to predictive values adjusted for uncertainty (often pessimistically), using a calibrated model (minimized error variance, Doherty 2015) where model outputs are near the center of their posterior distributions.  Model parameter uncertainty stems from prior uncertainty and calibration data.

### Metadata
- **Keywords:** 
- **Chunk ID:** 9eb7ce055068
- **Chunk Index:** 1
- **Previous Chunk ID:** de2e82e22185
- **Next Chunk ID:** e05099b5052d

---

## Context

### Summary
**Parallel PEST (ppest.exe, i64ppest.exe) and BEOPEST (beopest32.exe, beopest64.exe) are automatically installed.  PAGENT.exe is required for Parallel PEST on each agent machine; BEOPEST uses its own executable as the agent.  Model programs and files must also be copied to agent machines before running Parallel PEST or BEOPEST.**

### Header
**11.1.5 Installing Parallel PEST and BEOPEST**

### Content
The command line version of the Parallel PEST executable ppest.exe, and its 64 bit version i64ppest.exe, are automatically installed when you install PEST on your machine. The same applies to the BEOPEST executables beopest32.exe and beopest64.exe.
As is explained below, for Parallel PEST to run a model on another machine it must signal an agent, named PAGENT, residing on the other machine to generate the command to run the model. Thus pagent.exe must be installed on each machine engaged in the Parallel PEST parameter estimation process. To do this, copy pagent.exe (also provided with PEST) to an appropriate directory (i.e. folder) on each such machine. This folder can be the model working folder on that machine if desired; if not, it should be a folder whose name is cited in the PATH environment variable on that machine.
BEOPEST does not use a special agent program. Rather BEOPEST itself is the agent. Hence beopest32.exe or beopest64.exe must be copied to agent machines in the same way as was described above for pagent.exe.
As will be discussed below, not only PEST programs, but model programs and accompanying files must also be copied to agent machines prior to initiating a parallel PEST or BEOPEST run.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)
- **Subsection:** 11.1 General (continuación)

### Additional Summaries
- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.
- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.

### Related Context
- **Previous Summary:** Parallel PEST's efficiency decreases with short model run times due to file I/O and message passing latency. BEOPEST, using TCP/IP, minimizes these overheads because agents perform file I/O locally.
- **Next Summary:** Parallel PEST and BEOPEST store parameter and model output values in binary, direct access files (pest###.dap, pest###.dao), reducing memory needs. These files are deleted after a run but are needed for restarting using the "/s" switch.  Parallel PEST is described below, followed by BEOPEST.

### Metadata
- **Keywords:** 
- **Chunk ID:** 3de0f3c0071a
- **Chunk Index:** 1
- **Previous Chunk ID:** cb0f0bfcff07
- **Next Chunk ID:** d5b1ed60ac37

---

## Context

### Summary
**PESTPP-OPT uses a PEST control file (Chapter 5) defining parameters, calibration data (with noise), decision variables, constraints, objective function, and optimization control variables (keyword-value pairs, "++" prefix).  It requires a calibrated model.  The details of each of these are discussed below.**

### Header
**8.2.1The PEST Control File **

### Content
Like other members of the PEST++ suite, execution of PESTPP-OPT is initiated using a command line that references a PEST control file. See chapter 5 of this manual for details. The PEST control file supplied to PESTPP-OPT must define the optimization problem that it must solve. In particular, this PEST control file must inform it of the following:
- model parameters whose post-calibration uncertainties are responsible for the uncertainties of model outputs;
- model outputs for which there are counterparts in the calibration dataset;
- the noise associated with members of the calibration dataset;
- decision variables that must be optimized;
- model outputs to which constraints are applied during the optimization process;
- constraints that are exerted on linear combinations of parameters that do not require a model run to calculate;
- how the decision objective function is defined;
- the values of control variables that govern the constrained optimization process.
As is the normal protocol for members of the PEST++ suite, variables which control the optimization process that is implemented by PESTPP-OPT are supplied through keywords that can be placed anywhere within a PEST control file on lines that begin with the “++” string.
Each of the above issues is now discussed in detail.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.2 Using PESTPP-OPT

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode, PEST maximizes/minimizes a prediction (in the "predict" group) while keeping the objective function ≤ Φ0 (requires a prior "estimation" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.

### Related Context
- **Previous Summary:** PESTPP-OPT handles chance constraints (risk neutral, averse, or tolerant) by shifting constraint values based on a user-specified risk value (0.0-1.0) and the model output's standard deviation (σo).  A value of 0.5 ignores uncertainty; 0.95 applies constraints to the upper 95% confidence level.  This is based on chance-constraint programming (Charnes and Cooper 1959, etc.).
- **Next Summary:** In PESTPP-OPT, parameter groups define decision variables (*opt_dec_var_groups*) and model parameters.  *opt_external_dev_var_groups* (subset of *opt_dec_var_groups*) specifies external decision variables (requiring template files).  Finite-difference derivatives (using parameter group settings) may be needed for calculating the response matrix. Decision variables cannot be log-transformed but can be tied or fixed;  FACPARMAX and RELPARMAX limits do not apply.

### Metadata
- **Keywords:** 
- **Chunk ID:** 1eb4698ae37e
- **Chunk Index:** 1
- **Previous Chunk ID:** 135c3f141f17
- **Next Chunk ID:** 48b7d94626ad

---

## Context

### Summary
**PESTPP-OPT uses a PEST control file  (section 5.3 details parallel run management variables) to manage parallel model runs, similar to other PEST++ suite programs.**

### Header
**8.2.11 Other Control Variables**

### Content
In common with all other members of the PEST++ suite, a PEST control file used by PESTPP-OPT can include variables that govern parallel run management. See section 5.3 of this manual.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis
- **Main Section:** 8. PESTPP-OPT
- **Subsection:** 8.2 Using PESTPP-OPT

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** In "predictive analysis" mode, PEST maximizes/minimizes a prediction (in the "predict" group) while keeping the objective function ≤ Φ0 (requires a prior "estimation" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.

### Related Context
- **Previous Summary:** PESTPP-OPT uses sequential linear programming (SLP), iteratively solving a linearized problem.  Termination occurs when objective function/decision variable changes are ≤ *opt_iter_tol* (default 0.001).  *opt_coin_log* (1-4) controls the verbosity of the SLP solution history (case.coin_log).  J and y matrices are recalculated every *opt_recalc_fosm_every* iterations to partially accommodate nonlinearities.
- **Next Summary:** After optimization, PESTPP-OPT performs a final model run using optimized decision variables unless *opt_skip_final()* is used.  Optimized decision variable values remain in model input files.

### Metadata
- **Keywords:** 
- **Chunk ID:** 878845b6c3b0
- **Chunk Index:** 1
- **Previous Chunk ID:** ec6be79c7073
- **Next Chunk ID:** 2c0a945abae1

---

## Context

### Summary
**For large problems, use 64-bit versions of PEST, Parallel PEST, BEOPEST, and their utilities for faster execution and increased memory capacity.**

### Header
**15.3 Versions of PEST**

### Content
Where problem sizes are large, use 64 bit versions of PEST, Parallel PEST and BEOPEST (and of PEST support utilities for which 64 bit versions are provided). Execution is generally faster. Much more memory can be addressed.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 15. Large Numbers of Parameters
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter discusses efficient calibration methods for models with tens of thousands of parameters using PEST. Adjoint techniques are recommended for highly parameterized models. Use compressed binary external derivatives files, 64-bit versions of PEST for large problems, and optimize Jacobian matrix storage. Prioritize linearity of regularization constraints and activate memory conservation for improved efficiency.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** For highly parameterized models (tens of thousands), model-calculated derivatives (adjoint techniques, Chapter 12) are necessary due to the excessive number of model runs and imprecision of finite differences.  Compressed binary external derivatives files are recommended; elements should be ordered by observation then parameter for optimal efficiency.
- **Next Summary:** In highly parameterized inversions, Jacobian matrix storage (dimensions (no+np)×m) can be excessive.  Many sensitivities and Tikhonov regularization elements are often zero. A data storage mechanism that omits zero-valued elements significantly reduces PEST's memory requirements.

### Metadata
- **Keywords:** 
- **Chunk ID:** 99e9db574a30
- **Chunk Index:** 1
- **Previous Chunk ID:** 5d358602f4e2
- **Next Chunk ID:** 8c1f42813f75

---


Answer strictly following the above instructions.

```

# Complete Messages Array
```json
[
  {
    "role": "system",
    "content": "\nYou are a **PEST Documentation Expert**. Your task is to answer questions about PEST documentation using only the provided documentation (in `{context}`). Follow these rules strictly:\n\n**Direct Answer First:**\n- Begin with a comprehensive answer that directly addresses the question\n- Include all relevant details and context from the documentation\n- Don't artificially limit the length - be as thorough as the documentation allows\n- Use clear paragraphs and formatting for readability\n- NEVER invent, infer, or add information not explicitly present in the documentation\n\nThen, continue with the detailed structure:\n\n1. **Detailed Analysis:**  \n   - Use the following structure:\n\n     **1) Definition/Overview**  \n     - For technical terms: provide a complete definition with all relevant details\n     - For broader questions: provide a thorough overview of the topic\n     - Include all relevant context and relationships\n     - Cite source(s) using the format \"File: [filename], Section: [header]\".\n\n     **2) Possible Values**  \n     - If applicable: describe all valid or recognized values in detail\n     - Include defaults, ranges, and special cases if documented\n     - If not applicable: state \"Not applicable for this topic\"\n     - Cite source(s).\n\n     **3) Implications**  \n     - Provide a thorough explanation of all usage considerations and consequences\n     - Include any relationships with other components or features\n     - If not available, state: \"Information not available in the provided content.\"\n\n     **4) Practical Usage Notes**  \n     - Include all usage notes, examples, and practical applications\n     - Provide context for when and how to use the feature/component\n     - Otherwise, state: \"No usage notes found in the provided content.\"\n\n     **5) Keywords**  \n     - List ONLY keywords that are EXPLICITLY present in the provided documentation\n     - Keywords must be copied EXACTLY as they appear in the documentation\n     - DO NOT infer, generate, or create keywords that are not explicitly listed\n     - If no keywords are found in the documentation, you MUST state EXACTLY: \"No keywords found in the provided content\"\n     - DO NOT add any explanation or commentary about keywords\n\n2. **Follow-up Questions:**  \n   - After your main answer, list **exactly 3 follow-up questions**\n   - Questions MUST:\n     - If the original query was fully answered:\n       - Be directly related to the original query \"{query}\"\n       - Lead to deeper understanding of the main topic\n     - If the original query was partially answered or not answered:\n       - Focus on related topics found in the documentation\n       - Help build context around the topic\n     - In all cases:\n       - Be derived from content in Additional Summaries and Related Context sections\n       - ONLY ask questions that can be answered with the available content\n       - Ask ONE single thing - no \"if/how/why\" combinations\n       - Be concise and direct\n       - AVOID: \"if so\", \"and how\", \"under what conditions\", \"and why\"\n   - Examples of GOOD questions (one thing only and general question):\n     - \"What is the purpose of nonlinear penalty functions?\"\n     - \"How does PEST handle parameter bounds during the regularization process?\"\n     - \"How does PEST calculate parameter sensitivities?\"\n   - Examples of BAD questions (too compound or not answerable):\n     - \"Can OBS2OBS process observations directly, and if so, how?\"\n     - \"Can PEST incorporate predictive noise in the regularization objective function, and if so, how?\"\n     - \"What are the equations and when should they be used?\"\n     - \"Does PEST support parallel processing and how does it work?\"\n     - \"What are the specific roles of Cooley (1983) and Hill (1992) techniques in the development of PEST's dampening method?\"\n   - Before writing each question, verify that its answer exists in the documentation\n   - Present as a simple numbered list (1-3)\n\n3. **Important Instructions:**  \n   - **Do not mention internal processes, \"chunks,\" or retrieval steps.**  \n   - **Do not include any self-commentary or extra explanations.**\n   - Use only the documentation provided in `{context}`.\n\nAnswer strictly following the structure and rules above.\n"
  },
  {
    "role": "user",
    "content": "\nQuestion: How do I use pest-opt?\n\nPlease provide a clear and concise answer using only the information from the documentation below. Follow these rules strictly:\n\n1. **Cite Sources:**  \n   - Use the format \"File: [filename], Section: [header]\" whenever you reference specific details.\n\n2. **Include Examples:**  \n   - Provide relevant examples from the documentation if available.\n\n3. **Note Limitations:**  \n   - If the documentation is incomplete or ambiguous, explicitly state: \"Information not available in the provided content.\"\n\n4. **Follow-up Questions:**  \n   - After your main answer, list **exactly 3 follow-up questions** based primarily on:\n     - \"Additional Summaries\" sections\n     - \"Related Context\" sections\n   - Each question must reference its source section\n   - Do not provide answers to these questions\n   - Present as a simple numbered list (1-3)\n\n5. **Keywords Section:**  \n   - Include a \"Keywords\" section if applicable.\n   - If none are provided, state: \"No keywords found in the provided content.\"\n\n6. **Avoid Internal Details:**  \n   - Do not mention internal processes or retrieval steps.\n   - Do not include self-commentary or extra explanations.\n\n7. **Be Concise and Accurate:**  \n   - NEVER invent details, assumptions, or content\n   - ONLY use information EXPLICITLY stated in the provided documentation\n   - If information is missing, state EXACTLY: \"Information not available in the provided content\"\n   - DO NOT try to fill gaps or make assumptions about missing information\n   - When in doubt, acknowledge the limitation of the available information\n\n**Available Documentation with Metadata:**\n# Search Results for: How do I use pest-opt?\n\nKeywords: None\n\n\n## Context\n\n### Summary\n**PESTPP-OPT (described by White et al. 2018, and Wagner and Gorelick 1987) performs decision optimization under uncertainty using sequential linear programming.  Examples of its use are provided in White et al. (2018).**\n\n### Header\n**8.1.1 A Publication**\n\n### Content\nPESTPP-OPT is described by White et al (2018), where examples of its use are also provided. The following description summarizes information available from this source. See also Wagner and Gorelick (1987) where a similar methodology is described.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 8. PESTPP-OPT\n- **Subsection:** 8.1 Introduction\n\n### Additional Summaries\n- **Higher-Level Summary:** In \"predictive analysis\" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.\n- **Detailed Summary:** In \"predictive analysis\" mode (Doherty 2015, section 8.4), PEST maximizes/minimizes a prediction while maintaining the objective function below a threshold, assessing post-calibration uncertainty.  This works best with few parameters and a well-posed inverse problem; otherwise, use linear analysis, Monte Carlo, or Pareto methods.  The method requires high-integrity derivatives and a prior calibration process.\n\n### Related Context\n- **Previous Summary:** PESTPP-SEN generates various output files (Table 7.3, case=control file base name):  case.msn/case.group.msn/case.mio/case.raw.csv/case.group.raw.csv (Morris method only), case.sobol.si.csv/case.sobol.sti.csv/Case.sobol.obs.csv/Case.sobol.par.csv/case.sbl (Sobol method only), case.rmr (parallel runs), and Case.sen.par.csv (Morris only).  case.rns is a binary run management file.  All files use comma-delimited data except case.rns.  If all observation weights are zero, PESTPP-SEN resets them to 1.0.\n- **Next Summary:** PESTPP-OPT solves constrained optimization problems considering uncertainties in model outputs (chance constraints).  Constraints are applied to predictive values adjusted for uncertainty (often pessimistically), using a calibrated model (minimized error variance, Doherty 2015) where model outputs are near the center of their posterior distributions.  Model parameter uncertainty stems from prior uncertainty and calibration data.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 9eb7ce055068\n- **Chunk Index:** 1\n- **Previous Chunk ID:** de2e82e22185\n- **Next Chunk ID:** e05099b5052d\n\n---\n\n## Context\n\n### Summary\n**Parallel PEST (ppest.exe, i64ppest.exe) and BEOPEST (beopest32.exe, beopest64.exe) are automatically installed.  PAGENT.exe is required for Parallel PEST on each agent machine; BEOPEST uses its own executable as the agent.  Model programs and files must also be copied to agent machines before running Parallel PEST or BEOPEST.**\n\n### Header\n**11.1.5 Installing Parallel PEST and BEOPEST**\n\n### Content\nThe command line version of the Parallel PEST executable ppest.exe, and its 64 bit version i64ppest.exe, are automatically installed when you install PEST on your machine. The same applies to the BEOPEST executables beopest32.exe and beopest64.exe.\nAs is explained below, for Parallel PEST to run a model on another machine it must signal an agent, named PAGENT, residing on the other machine to generate the command to run the model. Thus pagent.exe must be installed on each machine engaged in the Parallel PEST parameter estimation process. To do this, copy pagent.exe (also provided with PEST) to an appropriate directory (i.e. folder) on each such machine. This folder can be the model working folder on that machine if desired; if not, it should be a folder whose name is cited in the PATH environment variable on that machine.\nBEOPEST does not use a special agent program. Rather BEOPEST itself is the agent. Hence beopest32.exe or beopest64.exe must be copied to agent machines in the same way as was described above for pagent.exe.\nAs will be discussed below, not only PEST programs, but model programs and accompanying files must also be copied to agent machines prior to initiating a parallel PEST or BEOPEST run.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers\n- **Main Section:** 11. Parallel PEST and BEOPEST (continuación)\n- **Subsection:** 11.1 General (continuación)\n\n### Additional Summaries\n- **Higher-Level Summary:** Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.\n- **Detailed Summary:** Parallel PEST and BEOPEST parallelize model runs, reducing PEST run time. Parallel PEST requires a run management file, while BEOPEST's is optional. They distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Both store data in binary files for reduced memory needs.\n\n### Related Context\n- **Previous Summary:** Parallel PEST's efficiency decreases with short model run times due to file I/O and message passing latency. BEOPEST, using TCP/IP, minimizes these overheads because agents perform file I/O locally.\n- **Next Summary:** Parallel PEST and BEOPEST store parameter and model output values in binary, direct access files (pest###.dap, pest###.dao), reducing memory needs. These files are deleted after a run but are needed for restarting using the \"/s\" switch.  Parallel PEST is described below, followed by BEOPEST.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 3de0f3c0071a\n- **Chunk Index:** 1\n- **Previous Chunk ID:** cb0f0bfcff07\n- **Next Chunk ID:** d5b1ed60ac37\n\n---\n\n## Context\n\n### Summary\n**PESTPP-OPT uses a PEST control file (Chapter 5) defining parameters, calibration data (with noise), decision variables, constraints, objective function, and optimization control variables (keyword-value pairs, \"++\" prefix).  It requires a calibrated model.  The details of each of these are discussed below.**\n\n### Header\n**8.2.1The PEST Control File **\n\n### Content\nLike other members of the PEST++ suite, execution of PESTPP-OPT is initiated using a command line that references a PEST control file. See chapter 5 of this manual for details. The PEST control file supplied to PESTPP-OPT must define the optimization problem that it must solve. In particular, this PEST control file must inform it of the following:\n- model parameters whose post-calibration uncertainties are responsible for the uncertainties of model outputs;\n- model outputs for which there are counterparts in the calibration dataset;\n- the noise associated with members of the calibration dataset;\n- decision variables that must be optimized;\n- model outputs to which constraints are applied during the optimization process;\n- constraints that are exerted on linear combinations of parameters that do not require a model run to calculate;\n- how the decision objective function is defined;\n- the values of control variables that govern the constrained optimization process.\nAs is the normal protocol for members of the PEST++ suite, variables which control the optimization process that is implemented by PESTPP-OPT are supplied through keywords that can be placed anywhere within a PEST control file on lines that begin with the “++” string.\nEach of the above issues is now discussed in detail.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 8. PESTPP-OPT\n- **Subsection:** 8.2 Using PESTPP-OPT\n\n### Additional Summaries\n- **Higher-Level Summary:** In \"predictive analysis\" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.\n- **Detailed Summary:** In \"predictive analysis\" mode, PEST maximizes/minimizes a prediction (in the \"predict\" group) while keeping the objective function ≤ Φ0 (requires a prior \"estimation\" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.\n\n### Related Context\n- **Previous Summary:** PESTPP-OPT handles chance constraints (risk neutral, averse, or tolerant) by shifting constraint values based on a user-specified risk value (0.0-1.0) and the model output's standard deviation (σo).  A value of 0.5 ignores uncertainty; 0.95 applies constraints to the upper 95% confidence level.  This is based on chance-constraint programming (Charnes and Cooper 1959, etc.).\n- **Next Summary:** In PESTPP-OPT, parameter groups define decision variables (*opt_dec_var_groups*) and model parameters.  *opt_external_dev_var_groups* (subset of *opt_dec_var_groups*) specifies external decision variables (requiring template files).  Finite-difference derivatives (using parameter group settings) may be needed for calculating the response matrix. Decision variables cannot be log-transformed but can be tied or fixed;  FACPARMAX and RELPARMAX limits do not apply.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 1eb4698ae37e\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 135c3f141f17\n- **Next Chunk ID:** 48b7d94626ad\n\n---\n\n## Context\n\n### Summary\n**PESTPP-OPT uses a PEST control file  (section 5.3 details parallel run management variables) to manage parallel model runs, similar to other PEST++ suite programs.**\n\n### Header\n**8.2.11 Other Control Variables**\n\n### Content\nIn common with all other members of the PEST++ suite, a PEST control file used by PESTPP-OPT can include variables that govern parallel run management. See section 5.3 of this manual.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis\n- **Main Section:** 8. PESTPP-OPT\n- **Subsection:** 8.2 Using PESTPP-OPT\n\n### Additional Summaries\n- **Higher-Level Summary:** In \"predictive analysis\" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.\n- **Detailed Summary:** In \"predictive analysis\" mode, PEST maximizes/minimizes a prediction (in the \"predict\" group) while keeping the objective function ≤ Φ0 (requires a prior \"estimation\" run).  It uses the same parameters, transformations, and observations as the estimation run.  Restarting uses `/r`, `/j`, `/d`, or `/s` (parallel runs).  Change limits remain important.  Screen output shows prediction values per iteration.  Results include the optimal prediction and parameter values.\n\n### Related Context\n- **Previous Summary:** PESTPP-OPT uses sequential linear programming (SLP), iteratively solving a linearized problem.  Termination occurs when objective function/decision variable changes are ≤ *opt_iter_tol* (default 0.001).  *opt_coin_log* (1-4) controls the verbosity of the SLP solution history (case.coin_log).  J and y matrices are recalculated every *opt_recalc_fosm_every* iterations to partially accommodate nonlinearities.\n- **Next Summary:** After optimization, PESTPP-OPT performs a final model run using optimized decision variables unless *opt_skip_final()* is used.  Optimized decision variable values remain in model input files.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 878845b6c3b0\n- **Chunk Index:** 1\n- **Previous Chunk ID:** ec6be79c7073\n- **Next Chunk ID:** 2c0a945abae1\n\n---\n\n## Context\n\n### Summary\n**For large problems, use 64-bit versions of PEST, Parallel PEST, BEOPEST, and their utilities for faster execution and increased memory capacity.**\n\n### Header\n**15.3 Versions of PEST**\n\n### Content\nWhere problem sizes are large, use 64 bit versions of PEST, Parallel PEST and BEOPEST (and of PEST support utilities for which 64 bit versions are provided). Execution is generally faster. Much more memory can be addressed.\n\n### Source\n- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers\n- **Main Section:** 15. Large Numbers of Parameters\n- **Subsection:** \n\n### Additional Summaries\n- **Higher-Level Summary:** This chapter discusses efficient calibration methods for models with tens of thousands of parameters using PEST. Adjoint techniques are recommended for highly parameterized models. Use compressed binary external derivatives files, 64-bit versions of PEST for large problems, and optimize Jacobian matrix storage. Prioritize linearity of regularization constraints and activate memory conservation for improved efficiency.\n- **Detailed Summary:** \n\n### Related Context\n- **Previous Summary:** For highly parameterized models (tens of thousands), model-calculated derivatives (adjoint techniques, Chapter 12) are necessary due to the excessive number of model runs and imprecision of finite differences.  Compressed binary external derivatives files are recommended; elements should be ordered by observation then parameter for optimal efficiency.\n- **Next Summary:** In highly parameterized inversions, Jacobian matrix storage (dimensions (no+np)×m) can be excessive.  Many sensitivities and Tikhonov regularization elements are often zero. A data storage mechanism that omits zero-valued elements significantly reduces PEST's memory requirements.\n\n### Metadata\n- **Keywords:** \n- **Chunk ID:** 99e9db574a30\n- **Chunk Index:** 1\n- **Previous Chunk ID:** 5d358602f4e2\n- **Next Chunk ID:** 8c1f42813f75\n\n---\n\n\nAnswer strictly following the above instructions.\n"
  }
]
```