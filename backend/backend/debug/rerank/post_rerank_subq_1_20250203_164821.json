{
  "subquestion": "What is noptmax?",
  "variations": [
    "What does noptmax mean?",
    "Can you explain what noptmax is?",
    "What is the definition of noptmax?",
    "Could you clarify what noptmax refers to?",
    "Please describe what noptmax is."
  ],
  "keywords": [
    "noptmax"
  ],
  "top_results": [
    {
      "chunk_id": "1c679819e0a7",
      "chunk_index": 1,
      "content": "LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.\nPEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.\nIf NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.\nFor NOPTMAX not set to zero, the following should be noted.\n• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.\n• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)\n• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.\nUse of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.\nIt is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.\nThe tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.",
      "header": "13.3.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "578d27a8ea30",
      "next_id": "e09851a2d028",
      "summary_self": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.",
      "summary_prev": "PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.",
      "summary_next": "LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS=\"single\", DPOINT=\"point\" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.",
      "header_level_1": "13. Latin Hypercube Sampling",
      "header_level_2": "13.3 LHS2PEST",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.740065069190857,
      "normalized_semantic": 0.740065069190857,
      "normalized_keyword": 2,
      "combined_score": 1.622019520757257,
      "reranked_score": 1.622019520757257,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 3500,
        "semantic_score": 0.740065069190857,
        "keyword_score": 2,
        "combined_score": 1.622019520757257,
        "final_score": 1.622019520757257
      }
    },
    {
      "chunk_id": "d131ce523618",
      "chunk_index": 1,
      "content": "Program PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.\nRecall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.\nPARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.\nPARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.\nPARREP is run using the command\nparrep parfile pestfile1 pestfile2 [new_noptmax]\nwhere\n|parfile|is the name of a parameter value file,|\n|---|---|\n|pestfile1|is the name of an existing PEST control file,|\n|pestfile2|is the name for the new PEST control file, and|\n|new_noptmax|optionally provides a new value for NOPTMAX.|\nWhen PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.\nA special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.",
      "header": "4.4 PARREP",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "51cac29a6097",
      "next_id": "05375a187143",
      "summary_self": "PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.",
      "summary_prev": "Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).",
      "summary_next": "OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.",
      "header_level_1": "4. Building and Altering a PEST Control File",
      "header_level_2": "",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.724614815436922,
      "normalized_semantic": 0.724614815436922,
      "normalized_keyword": 2,
      "combined_score": 1.6173844446310766,
      "reranked_score": 1.6173844446310766,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 3055,
        "semantic_score": 0.724614815436922,
        "keyword_score": 2,
        "combined_score": 1.6173844446310766,
        "final_score": 1.6173844446310766
      }
    },
    {
      "chunk_id": "3e78a19f3d34",
      "chunk_index": 1,
      "content": "Like PEST and PESTPP-GLM, PESTPP-IES reads termination criteria from the eighth line of the “control data” section of a PEST control file.\nPESTPP-IES ceases execution after NOPTMAX iterations have elapsed. However, during these NOPTMAX iterations it applies the PHIREDSTP, NPHISTP and NPHINORED termination criteria to the mean objective function calculated using all realizations of the ensemble over successive smoother iterations. If the relative reduction in the mean objective function is less than PHIREDSTP over NPHISTP iterations, or if NPHINORED iterations have elapsed since the last reduction in the mean objective function has occurred, PESTPP-IES ceases execution.\nNote that, as described above, PESTPP-IES also ceases execution if, during any particular iteration of the smoother process, it cannot find in successive NPHINORED iterations, a lambda and scale factor that allows it to calculate parameter upgrades for which the objective function is less than *ies_accept_phi_fac()*. If the results of a particular iteration’s solution process do not meet the acceptable phi criteria (the previous iteration’s mean composite phi time *ies_accept_phi_fac*), then a “partial upgrade” is performed, where only realizations that have yield a phi meeting this criteria are updated. After this partial upgrade, the full ensemble phi statistics are recalculated to determine if the lambda value for the next iteration. If after a partial upgrade, the acceptable phi criteria is still not met, PESTPP-IES will return to upgrade calculations with an increased lambda. In this situation, PESTPP-IES will save “rejected” parameter and observation ensembles in case users want to inspect these quantities.\nSpecial values of NOPTMAX can instigate special PESTPP-IES behaviour. If NOPTMAX is set to -1, PESTPP-IES does not upgrade random parameter sets which comprise an ensemble. It simply runs the model once for each parameter set, records model output values, and then ceases execution, thereby effective undertaking unconstrained Monte Carlo analysis. If NOPTMAX is set to zero, execution of PESTPP-IES is even shorter. It evaluates only the parameter values listed in the control file­ – replicating the behaviour of PESTPP-GLM and PEST. If NOPTMAX is supplied as -2, then PESTPP-IES will calculate the mean value of the initial parameter ensemble, evaluate it (by running the model once) and record the results.\nPESTPP-IES reports several different objective functions, namely “composite”, “measurement”, “regularization”, and “actual”, depending on the mode of operation. The “measurement” objective function is calculated using the current simulated outputs and the observations values in the pest control combined with realizations of additive measurement noise (described elsewhere in this manual). The measurement objective function is calculated using the weights in the pest control file (unless an *obscov* is supplied, described elsewhere, or unless a user-generated observations plus noise ensemble is supplied, described elsewhere). Note that if the *ies_no_noise* option is activated, the “measurement” and “actual” objective functions are the same and only the “actual” is reported to the screen and record file.\nThe “regularization” objective function is calculated as parameter value deviations from the initial (stochastic) realized values–this objective function is scaled by the diagonal of the prior parameter covariance matrix. Note the “regularization” objective function is only used and reported if the value of *ies_reg_factor* is supplied with a value greater than 0.0.\nThe “composite” objective function is simply the combination of the measurement and regularization objective functions. Note the regularization objective function is reported in the phi summary but the contribution to the composite objective function is controlled by *ies_reg_factor,* which is 0.0 by default. Note the composite objective function is used to select lambda-scale factor pairs and to control termination criteria. Similar to the “regularization” objective function, the “composite” objective function is only used and reported if *ies_reg_factor* is greater than 0.0.\nThe “actual” objective function is calculated using the current simulated outputs and the observation values in the control file (that is, without measurement noise realizations). Through the *ies_no_noise* option, users can make the “measurement” and “actual” objective functions one in the same. This is an important consideration when subjective weighting is used to balance the contribution of several types of observations to the objective function–a process that can result in very small weights, which implies very large measurement noise.",
      "header": "9.2.9 Termination Criteria, Objective Functions, and Upgrade Acceptance ",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "15858d119534",
      "next_id": "2fbe597b07b9",
      "summary_self": "PESTPP-IES uses termination criteria (NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP, NRELPAR) applied to the mean objective function across realizations.  NOPTMAX=0/-1/-2 triggers special behavior.  It reports \"composite,\" \"measurement,\" \"regularization,\" and \"actual\" objective functions (*ies_reg_factor*>0 for regularization and composite terms).  The  *ies_accept_phi_fac* criterion and partial upgrades handle unsuccessful iterations.  A final model run is performed unless stopped via PSTOPST (in parallel mode).",
      "summary_prev": "PESTPP-IES generates multiple output files (detailed in the next section), controlled by *ies_verbose_level* (default 1).  It saves parameter and observation ensembles in CSV or JCB files (iteration-specific) and, optionally (*save_lambda_ensembles*=true), lambda-testing parameter sets.  These files are used to diagnose numerical instability issues.",
      "summary_next": "PESTPP-IES balances objective function contributions from observation groups internally (*ies_phi_factor_file*,  two-column file: tag, phi factor) at runtime.  Tags identify groups; phi factors set group contributions (maintaining the mean measurement phi).  *ies_phi_factors_by_real*=true enables per-realization weighting (using a table of realization and tag-based phi factors).  pyEMU and PEST utilities offer more granular control.",
      "header_level_1": "9. PESTPP-IES",
      "header_level_2": "9.2 Using PESTPP-IES",
      "header_summary_1": "Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.",
      "header_summary_2": "To use PEST's \"regularisation\" mode, set PESTMODE to \"regularisation\" in the control data section. This mode categorizes observations into \"regul\" groups and others. Regularization weights are adjusted by the regularization weight factor. Key variables in the \"regularisation\" section include PHIMLIM, PHIMACCEPT, WFINIT, and others. PEST aims to minimize the regularization objective function while iterating until PHIMLIM is reached. Adjusting PHIMACCEPT, FRACPHIM, and other parameters influences optimization.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "PHIREDSTP",
        "ies_accept_phi_fac",
        "ies_no_noise",
        "ies_reg_factor"
      ],
      "similarity": 0.715564003783942,
      "normalized_semantic": 0.715564003783942,
      "normalized_keyword": 1.80000007152557,
      "combined_score": 1.4746692512030817,
      "reranked_score": 1.4746692512030817,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 4731,
        "semantic_score": 0.715564003783942,
        "keyword_score": 1.80000007152557,
        "combined_score": 1.4746692512030817,
        "final_score": 1.4746692512030817
      }
    },
    {
      "chunk_id": "cbb14971764f",
      "chunk_index": 1,
      "content": "The eighth line of the “control data” section of a PEST control file holds variables which control termination of an inversion process. These are NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP and NRELPAR. Suitable (PESTCHEK-friendly) values for these variables are provided in figure 4.2, namely 50, 0.005, 4, 4, 0.005 and 4. PESTPP-GLM uses all of these variables; PESTPP-IES uses all except RELPARSTP and NRELPAR. Other programs of the PEST++ suite use only NOPTMAX.\nNOPTMAX, an integer variable, sets the maximum number of iterations that an inversion or optimization process is allowed to run. However, values of 0, -1 and -2 trigger behaviour that is dependent on the PEST++ program that reads the PEST control file.\nIf NOPTMAX is set to 0, PESTPP-GLM does not estimate parameters. Instead it completes one model run using parameter values supplied in the “parameter data” section of the PEST control file. It computes objective function components based on the result of this single model run. This can be used to ensure that PESTPP-GLM setup is correct, and that weights assigned to observations in the “observation data” section of the PEST control file are suitable.\nIf NOPTMAX is set to -1 or -2, PESTPP-GLM calculates a Jacobian matrix and stores it in a Jacobian matrix file (i.e., a JCO file). If asked to do so, it also calculates linear statistics based on that Jacobian matrix. It then ceases execution. The same Jacobian matrix is available for more complex linear analysis using pertinent PEST utilities, as well as PyEMU. The Jacobian matrix that is stored in the JCO file can also be put to other uses; see section 3.4.\nPHIREDSTP is a real variable whereas NPHISTP is an integer variable. If, in the course of a PESTPP-GLM inversion process, there have been NPHISTP optimization iterations for which (Φ*i* - Φ*min* )/Φ*i* ≤ PHIREDSTP (Φ*i* being the objective function value at the end of the *i*th optimization iteration and Φmin being the lowest objective function achieved to date), PESTPP-GLM considers that the inversion process is at an end. Alternatively, if PESTPP-GLM has failed to lower the objective function over NPHINORED successive iterations, it ceases execution. PESTPP-IES supplies these same termination criteria to ensemble-mean objective functions.\nIf the magnitude of the maximum relative parameter change is less than RELPARSTP over NRELPAR successive iterations, then PESTPP-GLM ceases execution. The relative parameter change between iterations for any parameter is calculated using equation 3.2. PESTPP-GLM evaluates this change for all adjustable parameters at the end of all iterations, and determines the relative parameter change with the highest magnitude. If this maximum relative change is less than RELPARSTP, a counter is advanced by one; if it is greater than RELPARSTP, the counter is zeroed.",
      "header": "4.6.9 Eighth Line",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "e113dd2e0863",
      "next_id": "e93b50160cd8",
      "summary_self": "NOPTMAX (integer, 50 recommended) sets maximum iterations; 0 runs one model; -1 or -2 generates a JCO file.  PESTPP-GLM uses PHIREDSTP (real, 0.005), NPHISTP (integer, 4), NPHINORED (integer, 4), RELPARSTP (real, 0.005), and NRELPAR (integer, 4) for termination; PESTPP-IES uses all except RELPARSTP and NRELPAR. Other PEST++ programs use only NOPTMAX.",
      "summary_prev": "PHIREDSWH (real, often 0.1) in the \"control data\" section controls switching from forward to central differences in PESTPP-GLM (FORCEN=\"switch\") if the relative objective function reduction between iterations is ≤ PHIREDSWH.  It's ignored if differential evolution is used.  Equation 4.1 shows the condition for switching.",
      "summary_next": "ICOV, ICOR, and IEIG (integers) in the \"control data\" section are not used by PESTPP-GLM. Set them to 0 for PESTCHEK compatibility.",
      "header_level_1": "4. The PEST Control File",
      "header_level_2": "4.6 Control Data Section",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "The optional \"automatic user intervention\" section (section 6.3) governs automatic user intervention, activated by setting DOAUI to \"doaui\" in the \"control data\" section.  If omitted, default values are used.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "NRELPAR",
        "PHIREDSTP",
        "RELPARSTP"
      ],
      "similarity": 0.761933383480696,
      "normalized_semantic": 0.761933383480696,
      "normalized_keyword": 1.70000004768372,
      "combined_score": 1.4185800484228128,
      "reranked_score": 1.4185800484228128,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 2852,
        "semantic_score": 0.761933383480696,
        "keyword_score": 1.70000004768372,
        "combined_score": 1.4185800484228128,
        "final_score": 1.4185800484228128
      }
    },
    {
      "chunk_id": "734edcaf1ca7",
      "chunk_index": 1,
      "content": "PESTPP-DA is run exactly like all other tools in the PEST++ suite – See section 5 of this manual for how to run the tools in the PEST++ suite. As is described in that section, model runs can be undertaken in series or in parallel. In either case, a prematurely terminated PESTPP-DA run can be restarted by supplying the requisite global parameter and observation ensemble files (described below).\nTo restart at a given cycle number, users can supply the optional *da_hotstart_cycle* argument along with the requisite parameter, observation and noise ensemble files. To ensure a proper restart (especially if realizations have failed during evaluation), users should supply the corresponding files written by PESTPP-DA.\nThe version 2 pest control file format is required to specify cycle numbers. If no cycle numbers are found, then PESTPP-DA proceeds with a batch assimilation (e.g., smoother) assuming all parameters and observations are in cycle 0.\nAs previously discussed, if NOPTMAX is set to zero, PESTPP-DA will run the model once for each cycle using the values listed in the parameter data section of the control file, updating dynamic states and recording simulated outputs along the way. Furthermore, if NOPTMAX is set to -1, PESTPP-DA will evaluate the prior parameter ensemble for each cycle, updating dynamic states and recording simulated output along the way.\nOne important note related to the PEST control and parallel run management: because the template and/or instruction files may vary depending on the cycle number, the PESTPP-DA master instance passes the cycle number to the agents at run time so that the agents know what parameter and observation control file quantities are being used and which template and instruction files are in use. So, it is important that the agents are populated with a control file that lists the same cycles information as the control file that the master is using.\nGiven the complexity of cycle-dependent interface (parameters, observations, template files, instruction files), users may wish to “debug” or test this interface by setting *debug_parse_only* equal to “true” in the control file. With this option, PESTPP-DA will process each listed cycle, checking the parameters and observations against the templates and instruction files to ensure they agree. After this checking, PESTPP-DA will exit.\nNote that comprehensive interface checking is also made during the initialization of each PESTPP-DA analysis if NOPTMAX is not equal to zero because it can be quickest to check the cycles first, rather than start the PESTPP-DA process only to discover a cycle is not defined properly. However, for high dimensional problems, this checking can take significant time. Therefore, users can disable this interface checking by setting *check_tplins* to “false” in the control file.\nThe “cycle” values assigned to the various components in the control file can be assigned as integers or as a string. The string is colon-delimited, zero-based, start-stop-stride quantity. For example, if users want to have the same recharge multiplier parameter applied every March of a monthly-based simulation that simulates several years of time, the cycle value for the march recharge multiplier could be specified as “2::12”, which reads “starting with the 3rd cycle and every 12th cycle through the end of the cycles”. If users wanted a parameter to apply every cycle from the 4th to the 15th, the cycle string value would be “3:16”. A few more examples of string-based cycle values:\n- “::2” – every other cycle starting with the first\n- “1:5:2” - every other cycle from the 2nd up to the 6th\n- “1::3” – every third cycle starting with the 2nd cycle through the end of the cycles\nIn this way, the string-based cycle values allow users to apply sophisticated rules about how parameters and/or observations are used across multiple cycles.",
      "header": "12.2.12 Running PESTPP-DA",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "a264ecd76e04",
      "next_id": "9a878768d62e",
      "summary_self": "PESTPP-DA (like other PEST++ tools, Section 5) restarts using parameter/observation/noise ensemble files and optionally *da_hotstart_cycle*. Version 2 control files are needed for cycle specification; otherwise, it defaults to batch assimilation. NOPTMAX=0 runs one model per cycle; NOPTMAX=-1 runs a prior Monte Carlo analysis.  The master instance passes cycle numbers to agents. *debug_parse_only*=true checks the interface. *check_tplins*=false disables this checking.  Cycle values are integers or colon-delimited strings (start-stop-stride).",
      "summary_prev": "Data assimilation in PESTPP-DA involves: 1) choosing a scheme (sequential or batch); 2) defining assimilation cycles; 3) assigning cycle numbers to parameters, states, and observations; 4) creating template files for parameters/states; 5) creating instruction files for outputs/states; 6) creating template files for other input files; 7) generating prior ensembles (100-500 realizations); 8) generating observation noise ensembles; 9) identifying dynamic states (identical names or \"state_par_link\" column); and 10) considering localization for large datasets/small ensembles.  11) Choose the solution method.",
      "summary_next": "PESTPP-DA's cycle concept facilitates direct predictive hypothesis testing (Moore et al., 2010).  A weight cycle table gradually increases the weight of a prediction (e.g., surface-water/groundwater exchange) across cycles, testing its compatibility with historical observations (Figure 12.XXX).  Maintaining fit while achieving the prediction supports the hypothesis;  this resembles PEST's Pareto mode but uses PESTPP-DA's efficiency.",
      "header_level_1": "12. PESTPP-DA",
      "header_level_2": "12.2 Theory",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "PEST sends messages (pest.mmf) to the model before each run.  The first line (\"forward_model_run\", \"derivative_increment\", or \"external_derivatives\") indicates the run type.  For \"derivative_increment\", the second line specifies the incremented parameter. Subsequent lines list parameter names, values, and status codes (0=adjustable untransformed, 1=adjustable log-transformed, -n=tied to parameter n, -1000000=fixed).  The message file is written to the working directory (or agent directory for Parallel PEST/BEOPEST).",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.71596947718031,
      "normalized_semantic": 0.71596947718031,
      "normalized_keyword": 1.5,
      "combined_score": 1.2647908431540928,
      "reranked_score": 1.2647908431540928,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 3878,
        "semantic_score": 0.71596947718031,
        "keyword_score": 1.5,
        "combined_score": 1.2647908431540928,
        "final_score": 1.2647908431540928
      }
    }
  ],
  "metrics": {
    "raw_results_count": 10,
    "unique_results_count": 10,
    "variations_count": 5
  }
}