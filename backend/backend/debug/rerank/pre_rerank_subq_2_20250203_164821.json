{
  "subquestion": "How does noptmax work?",
  "variations": [
    "What is the function of noptmax?",
    "Can you explain how noptmax operates?",
    "Could you describe the working mechanism of noptmax?",
    "How is noptmax utilized?",
    "What processes are involved in noptmax’s operation?"
  ],
  "keywords": [
    "noptmax"
  ],
  "raw_results": [
    {
      "chunk_id": "1c679819e0a7",
      "chunk_index": 1,
      "content": "LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.\nPEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.\nIf NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.\nFor NOPTMAX not set to zero, the following should be noted.\n• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.\n• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)\n• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.\nUse of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.\nIt is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.\nThe tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.",
      "header": "13.3.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "578d27a8ea30",
      "next_id": "e09851a2d028",
      "summary_self": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.",
      "summary_prev": "PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.",
      "summary_next": "LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS=\"single\", DPOINT=\"point\" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.",
      "header_level_1": "13. Latin Hypercube Sampling",
      "header_level_2": "13.3 LHS2PEST",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.75907053215574,
      "normalized_semantic": 0.75907053215574,
      "normalized_keyword": 0.421325594186783,
      "combined_score": 0.5226490755774701
    },
    {
      "chunk_id": "3e78a19f3d34",
      "chunk_index": 1,
      "content": "Like PEST and PESTPP-GLM, PESTPP-IES reads termination criteria from the eighth line of the “control data” section of a PEST control file.\nPESTPP-IES ceases execution after NOPTMAX iterations have elapsed. However, during these NOPTMAX iterations it applies the PHIREDSTP, NPHISTP and NPHINORED termination criteria to the mean objective function calculated using all realizations of the ensemble over successive smoother iterations. If the relative reduction in the mean objective function is less than PHIREDSTP over NPHISTP iterations, or if NPHINORED iterations have elapsed since the last reduction in the mean objective function has occurred, PESTPP-IES ceases execution.\nNote that, as described above, PESTPP-IES also ceases execution if, during any particular iteration of the smoother process, it cannot find in successive NPHINORED iterations, a lambda and scale factor that allows it to calculate parameter upgrades for which the objective function is less than *ies_accept_phi_fac()*. If the results of a particular iteration’s solution process do not meet the acceptable phi criteria (the previous iteration’s mean composite phi time *ies_accept_phi_fac*), then a “partial upgrade” is performed, where only realizations that have yield a phi meeting this criteria are updated. After this partial upgrade, the full ensemble phi statistics are recalculated to determine if the lambda value for the next iteration. If after a partial upgrade, the acceptable phi criteria is still not met, PESTPP-IES will return to upgrade calculations with an increased lambda. In this situation, PESTPP-IES will save “rejected” parameter and observation ensembles in case users want to inspect these quantities.\nSpecial values of NOPTMAX can instigate special PESTPP-IES behaviour. If NOPTMAX is set to -1, PESTPP-IES does not upgrade random parameter sets which comprise an ensemble. It simply runs the model once for each parameter set, records model output values, and then ceases execution, thereby effective undertaking unconstrained Monte Carlo analysis. If NOPTMAX is set to zero, execution of PESTPP-IES is even shorter. It evaluates only the parameter values listed in the control file­ – replicating the behaviour of PESTPP-GLM and PEST. If NOPTMAX is supplied as -2, then PESTPP-IES will calculate the mean value of the initial parameter ensemble, evaluate it (by running the model once) and record the results.\nPESTPP-IES reports several different objective functions, namely “composite”, “measurement”, “regularization”, and “actual”, depending on the mode of operation. The “measurement” objective function is calculated using the current simulated outputs and the observations values in the pest control combined with realizations of additive measurement noise (described elsewhere in this manual). The measurement objective function is calculated using the weights in the pest control file (unless an *obscov* is supplied, described elsewhere, or unless a user-generated observations plus noise ensemble is supplied, described elsewhere). Note that if the *ies_no_noise* option is activated, the “measurement” and “actual” objective functions are the same and only the “actual” is reported to the screen and record file.\nThe “regularization” objective function is calculated as parameter value deviations from the initial (stochastic) realized values–this objective function is scaled by the diagonal of the prior parameter covariance matrix. Note the “regularization” objective function is only used and reported if the value of *ies_reg_factor* is supplied with a value greater than 0.0.\nThe “composite” objective function is simply the combination of the measurement and regularization objective functions. Note the regularization objective function is reported in the phi summary but the contribution to the composite objective function is controlled by *ies_reg_factor,* which is 0.0 by default. Note the composite objective function is used to select lambda-scale factor pairs and to control termination criteria. Similar to the “regularization” objective function, the “composite” objective function is only used and reported if *ies_reg_factor* is greater than 0.0.\nThe “actual” objective function is calculated using the current simulated outputs and the observation values in the control file (that is, without measurement noise realizations). Through the *ies_no_noise* option, users can make the “measurement” and “actual” objective functions one in the same. This is an important consideration when subjective weighting is used to balance the contribution of several types of observations to the objective function–a process that can result in very small weights, which implies very large measurement noise.",
      "header": "9.2.9 Termination Criteria, Objective Functions, and Upgrade Acceptance ",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "15858d119534",
      "next_id": "2fbe597b07b9",
      "summary_self": "PESTPP-IES uses termination criteria (NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP, NRELPAR) applied to the mean objective function across realizations.  NOPTMAX=0/-1/-2 triggers special behavior.  It reports \"composite,\" \"measurement,\" \"regularization,\" and \"actual\" objective functions (*ies_reg_factor*>0 for regularization and composite terms).  The  *ies_accept_phi_fac* criterion and partial upgrades handle unsuccessful iterations.  A final model run is performed unless stopped via PSTOPST (in parallel mode).",
      "summary_prev": "PESTPP-IES generates multiple output files (detailed in the next section), controlled by *ies_verbose_level* (default 1).  It saves parameter and observation ensembles in CSV or JCB files (iteration-specific) and, optionally (*save_lambda_ensembles*=true), lambda-testing parameter sets.  These files are used to diagnose numerical instability issues.",
      "summary_next": "PESTPP-IES balances objective function contributions from observation groups internally (*ies_phi_factor_file*,  two-column file: tag, phi factor) at runtime.  Tags identify groups; phi factors set group contributions (maintaining the mean measurement phi).  *ies_phi_factors_by_real*=true enables per-realization weighting (using a table of realization and tag-based phi factors).  pyEMU and PEST utilities offer more granular control.",
      "header_level_1": "9. PESTPP-IES",
      "header_level_2": "9.2 Using PESTPP-IES",
      "header_summary_1": "Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.",
      "header_summary_2": "To use PEST's \"regularisation\" mode, set PESTMODE to \"regularisation\" in the control data section. This mode categorizes observations into \"regul\" groups and others. Regularization weights are adjusted by the regularization weight factor. Key variables in the \"regularisation\" section include PHIMLIM, PHIMACCEPT, WFINIT, and others. PEST aims to minimize the regularization objective function while iterating until PHIMLIM is reached. Adjusting PHIMACCEPT, FRACPHIM, and other parameters influences optimization.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "PHIREDSTP",
        "ies_accept_phi_fac",
        "ies_no_noise",
        "ies_reg_factor"
      ],
      "similarity": 0.745495527445758,
      "normalized_semantic": 0.745495527445758,
      "normalized_keyword": 0.267425388097763,
      "combined_score": 0.4108464299021615
    },
    {
      "chunk_id": "ff1b7fa73d29",
      "chunk_index": 1,
      "content": "Use of PESTLIN assumes that a complete PEST input dataset exists for parameter estimation (regularised or otherwise), or predictive uncertainty analysis. It also assumes that a Jacobian matrix file exists for this dataset, together with a run record file in which parameter values pertinent to this Jacobian matrix are recorded. On the basis of this Jacobian matrix PESTLIN writes a GENLIN (see above) input dataset, encapsulating a linearised form of the model. It also writes a new PEST control file so that (regularised) inversion or predictive uncertainty analysis can be undertaken on the basis of the linearised model. Because this linearised model will generally run much faster than the real model, concepts can be tested and/or approximate solutions to these types of problems can be obtained, very quickly indeed.\nIn most cases the easiest way to build a linearised equivalent of a PEST input dataset (including a linearised equivalent of the model) is as follows.\n1. As stated above, build an entire PEST input dataset based on the real model. Ensure that this dataset is correct and consistent using the PESTCHEK utility.\n2. Set NOPTMAX to ‑1 in the pertinent PEST control file.\n3. Run PEST. PEST will undertake enough model runs to calculate the Jacobian matrix. Then it will cease execution, recording initial parameter values, together with uncertainty statistics (if these are calculable), on its run record file.\n4. Run PESTLIN.\nAlternatively, PESTLIN can be run at the end of an entire parameter estimation process. In this case the Jacobian matrix file will contain sensitivities with respect to optimised parameter values (or, if a minor improvement in parameter estimates occurred on the last iteration, with respect to near‑optimised parameter values). Meanwhile the run record file will record optimised parameter values, together with model‑generated counterparts to measurements comprising the calibration dataset calculated on the basis of these optimised parameter values (unless PEST is run using SVD‑assist, in which case the PARREP utility should be employed to construct such a run record file by first constructing a new PEST control file on the basis of optimised parameters and then running PEST in the manner described above).",
      "header": "14.5.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "9993028820b6",
      "next_id": "fe9c86ccbde4",
      "summary_self": "PESTLIN creates a linearized model from an existing PEST dataset (control and JCO files, requiring a PEST run with NOPTMAX=-1). It generates a GENLIN input file and a new PEST control file for faster linearized inversion or predictive uncertainty analysis.  Alternatively, it can be run after parameter estimation to use optimized parameter sensitivities.",
      "summary_prev": "GENLIN optionally creates a derivatives file (for use with PEST, Chapter 12, Part I) containing derivatives with respect to native (not log-transformed) parameters. This file can replace finite-difference derivatives, reducing PEST's computational burden.  Log-transformed parameters require additional calculations.",
      "summary_next": "PESTLIN linearizes a PEST dataset (pestincase.pst, .jco, .rec), creating a GENLIN dataset (linbasename.in, .out, .ins, .tpl) and a new PEST control file (pestoutcase.pst).  The `/d` switch enables external derivatives.  It handles tied parameters. Use `pestlin pestincase pestoutcase linbasename [/d]`.",
      "header_level_1": "14. Miscellaneous Utilities",
      "header_level_2": "14.5 PESTLIN",
      "header_summary_1": "Observation re-referencing simplifies derivative calculations by adjusting initial model conditions based on upgraded parameters, improving solver convergence time. It involves creating reference model outputs for accurate derivatives, with specific commands and activation steps. SVDAPREP and BEOPEST support this feature, enhancing model accuracy and efficiency.",
      "header_summary_2": "SVDAPREP supports observation re-referencing (mode 1 only) by creating r_svdabatch.bat and d_svdabatch.bat from existing \"r_\" and \"d_\" prefixed files (adding PARCALC and PICALC commands). The new control file activates observation re-referencing and is ready for use.  Mode 2 is not supported with SVD-assisted parameter estimation.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.774541749087469,
      "normalized_semantic": 0.774541749087469,
      "normalized_keyword": 0.232209324836731,
      "combined_score": 0.39490905211195243
    },
    {
      "chunk_id": "7882ba27349c",
      "chunk_index": 1,
      "content": "SENSAN allows you to undertake many model runs without user intervention. The sensitivity of certain model outputs to certain parameters can be tested. However SENSAN does not compute an objective function because it does not read an observation dataset, and hence cannot compare model outputs with corresponding observations to calculate residuals.\nHowever once all PEST input files have been prepared for a particular case, SENSAN can be used in conjunction with PEST to study the dependence of the objective function (or any components thereof) on certain parameters. Where there are only two parameters, this can be used to contour the objective function in parameter value space.\nA SENSAN control file implementing this is shown in figure 17.6.\nscf\n* control data\nverbose\n6 1\n1 1 single point\n* sensan files\nparvar.dat\nout1.txt\nout2.txt\nout3.txt\n* model command line\npest ves4\n* model input/output\npst.tpl ves4.pst\nrec.ins ves4.rec\nFigure 17.6 A SENSAN control file with PEST as the model.\nNote the following points.\n- In the PEST control file the value of NOPTMAX should be set to zero. Hence PEST runs the model only once before it terminates execution.\n- There is only one template file and one instruction file.\n- The template file is built from the PEST control file. Parameters adjusted by SENSAN are initial parameter values as listed on the PEST control file.\n- SENSAN’s observation file is the run record file for the PEST case.\n- As in normal SENSAN operation, supply parameter values to be used by SENSAN through a parameter variation file.\nThe instruction set by which the PEST control file may be read is shown below (the observation name is “phi”).\npif $\n$(ie phi)$ $=$ !phi!\nThis instruction set simply instructs SENSAN to read the PEST run record file until it encounters the string “(ie phi)” followed by “=”, and then to read the observation named “phi” as a non-fixed observation following that. More complex instruction sets are required where multiple objective function components must be read.",
      "header": "17.5 Sensitivity of the Objective Function",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "5ab5473f2398",
      "next_id": "81126e43e397",
      "summary_self": "SENSAN, combined with PEST (NOPTMAX=0), analyzes objective function dependence on parameters.  A SENSAN control file (Figure 17.6) uses a PEST control file as a template, and the PEST run record file as the observation file.  A parameter variation file provides parameter values;  an instruction file extracts the objective function.",
      "summary_prev": "SENSAN uses TEMPCHEK and INSCHEK (Part II).  SENSAN creates a parameter value file (t###.par), so avoid using this filename. INSCHEK saves read observation values to instruct.obf; avoid filename conflicts by using unique names for instruction files.",
      "summary_next": "SENSCHEK (Part II) thoroughly checks SENSAN input data.  SENSAN reports parameter variation file errors to the screen and continues;  it handles model and INSCHEK errors similarly, reporting to the screen and continuing.  Check for matching parameter names in template and parameter variation files;  use \"verbose\" mode for initial runs to detect errors, then switch to \"noverbose\".",
      "header_level_1": "17. SENSAN (continuación)",
      "header_level_2": "",
      "header_summary_1": "SENSAN uses control, parameter variation, and PEST template and instruction files. It runs system commands post-model runs, with options for OS commands or executables. PEST templates generate model inputs, instructions read outputs. Run with `sensan infile`, using tempchek.exe and inschek.exe. Outputs include ABSFLE, RELFLE, SENSFLE. SENSCHEK checks input data.",
      "header_summary_2": "",
      "keywords": [
        "* control data",
        "* model command line",
        "* model input/output",
        "NOPTMAX"
      ],
      "similarity": 0.743044999734759,
      "normalized_semantic": 0.743044999734759,
      "normalized_keyword": 0.220296368002892,
      "combined_score": 0.3771209575224521
    },
    {
      "chunk_id": "1fd4a5136d77",
      "chunk_index": 1,
      "content": "CALMAINTAIN prompts the user for its input data as this is more convenient than supplying these data on the command line. Its first prompt is\nEnter name of PEST control file:\nCALMAINTAIN opens the PEST control file. At the same time it ensures that a corresponding JCO file exists. (The contents of this file become the Z matrix of the above equations). Next it asks\nEnter name of parameter adjustment file:\nAn example of a parameter adjustment file follows.\nExample of a parameter adjustment file\nk_ppt30           0.8\nk_ppt31           2.6\nk_ppt32           0.8\nk_ppt33           1.0\nk_ppt34           0.8\nk_ppt35           0.8\nk_ppt36           0.5\nk_ppt37           1.8\nFigure 14.2 Example of a parameter adjustment file.\nEach line of a parameter adjustment file must have two entries. The first entry is the name of a parameter. The second entry is the new value of that parameter. Blank lines are ignored. Comment lines (which begin with the “#” character) are also ignored.\nCALMAINTAIN will object if you attempt to adjust the value of a fixed or tied parameter. However, it is acceptable to adjust the value of a parent parameter to which other parameters are tied; the child parameters are automatically adjusted if this is the case.\nCALMAINTAIN next asks for the name of the parameter value file that it must write. The prompt is:\nEnter name for output parameter value file:\nIt then asks the following three questions:\n- Use SVD or LSQR to solve equation? [l/s]:\n- Truncate at how many singular values:\n- Adopt what fraction of upgrade vector:\nAs is apparent from the first of the above questions, you have the choice of using either LSQR or singular value decomposition to solve equation 14.3.3. LSQR is faster than singular value decomposition where parameter numbers are high, but can sometimes be less precise.\nThe second of the above prompts allows you to limit the propensity for numerical noise to contaminate the solution of equation 14.3.3. The best response to this question varies with context. Based on limited experience at the time of writing, it is suggested that a value equal to the number of adjusted parameters featured in the parameter adjustment file may work well. “Damping” of parameter compensation can also be used to limit contamination of the solution to equation 14.3.3 by numerical noise; therefore a value of between 0.0 and 1.0 is a suitable answer to the third of the above questions (normally closer to 1.0 than 0.0). Some trial and error may be necessary to find the best response to the second and third of the above questions in any particular modelling context.\nOnce all of the above questions have been answered, CALMAINTAIN performs the calculations indicated above, and then writes the requested parameter value file. The values assigned to parameters in this file are the user‑adjusted values (for those parameters which are cited in the parameter adjustment file), together with values for other parameters which are altered in such a way as to maintain the model in as much of a calibrated state as possible.\nIf desired, the PARREP utility can be used to insert parameter values recorded in this file into a PEST control file. If NOPTMAX is set to zero in this file, PEST can be used to run the model and calculate an objective function. In this way adherence to calibration constraints can be tested.",
      "header": "14.3.3 Using CALMAINTAIN",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "91cc4af72d4e",
      "next_id": "bea21df90035",
      "summary_self": "CALMAINTAIN adjusts parameters to maintain calibration after changes (specified in a parameter adjustment file, Figure 14.2) to other parameters. It prompts for a PEST control file (with JCO file), parameter adjustment file, output parameter value file, solution method (\"l\" or \"s\"), number of singular values, and upgrade vector fraction (0.0-1.0).  It uses linear theory (Equation 14.3.3).  Use PARREP and set NOPTMAX=0 to test calibration.",
      "summary_prev": "CALMAINTAIN compensates for changes (δk₂) in a subset of parameters (k₂) by adjusting another subset (k₁), aiming to maintain calibration (Equation 14.3.3: Z₁δk₁=-Z₂δk₂). It solves exactly if possible; otherwise, it minimizes the right side of Equation 14.3.4.  It uses Equation 14.3.5 (Q<sup>1/2</sup>h=Q<sup>1/2</sup>Zk+Q<sup>1/2</sup>ε) instead of Equation 14.3.1.",
      "summary_next": "GENLIN, a linear model calculator, uses Equation 14.4.1 (h=h₀+M(k-k₀)) or 14.4.2 (h=h₀+M(log₁₀(k)-log₁₀(k₀)) for log-transformed parameters) to compute outputs (h) from inputs (k). M is a sensitivity/Jacobian matrix. It can be used independently or with PESTLIN.",
      "header_level_1": "14. Miscellaneous Utilities",
      "header_level_2": "14.3 CALMAINTAIN",
      "header_summary_1": "Observation re-referencing simplifies derivative calculations by adjusting initial model conditions based on upgraded parameters, improving solver convergence time. It involves creating reference model outputs for accurate derivatives, with specific commands and activation steps. SVDAPREP and BEOPEST support this feature, enhancing model accuracy and efficiency.",
      "header_summary_2": "Observation re-referencing with NUMCOM=1, DERCOM=1 involves three commands: main model command for objective function calculations and parameter upgrades, \"d_\" command for derivatives, and \"r_\" command for reference model outputs. For NUMCOM > 1, additional \"r_\" commands are needed before derivative calculations, except for the first command (index 1). Users create these \"r_\" commands.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.759939267638967,
      "normalized_semantic": 0.759939267638967,
      "normalized_keyword": 0.201133787631989,
      "combined_score": 0.36877543163408244
    },
    {
      "chunk_id": "f1e149007e9e",
      "chunk_index": 1,
      "content": "Parameter values recorded in parameter value files generated by PNULPAR can be PARREPed into a PEST control file. NOPTMAX can be set to zero in this file and the objective function computed in each case. If the model is linear, this objective function should be similar to that achieved during the previous calibration exercise.\nWhere a model is nonlinear, the use of PNULPAR‑generated parameters will probably not result in a calibrated model. In many cases, however, parameter values can be adjusted back into calibration with very little effort, this often requiring only one PEST iteration. (If desired, set NOPTMAX to 1 in the governing PEST control file to ensure that only one iteration actually takes place.) Furthermore, this process can be made even more inexpensive by employing sensitivities residing in an existing JCO file (for example, the same JCO file as that read by PNULPAR). This can be achieved by starting PEST with the “/i” switch and providing the name of the pertinent JCO file when prompted accordingly.\nWhen undertaking a single‑iteration PEST run under these conditions, the following may help.\n1. Set the BROYDEN update parameter JACUPDATE to 999. Thus on the second and further attempts to upgrade parameter values during this single iteration, PEST will have improved the Jacobian matrix on whose basis these upgrades are computed, this resulting (hopefully) in a lower objective function.\n2. Set the PHIRATSUF control variable very low (for example 0.001) and RLAMFAC to ‑4. Thus PEST will be forced to test a number of different Marquardt lambdas before the end of the iteration.\nHopefully, with the help of these strategies, an objective function can then be found which is as low as it can possibly be based on current sensitivities.\nIf the calibration null space is relatively large, then use of SVD‑assist for calibration adjustment of each PNULPAR‑generated parameter set can be achieved with a high level of model run efficiency, even if more than one iteration is required to reduce the objective function to a level at which the model is deemed to be “calibrated”. See section 10.6.3 of part I of this manual for details.\nWhichever of the above methods is chosen to enforce calibration constraints on PNULPAR‑modified parameter sets, the higher that you inform PNULPAR is the dimensionality of the calibration solution space, the less work will be required to enforce these constraints. This is because the higher that PNULPAR believes the dimensions of the calibration solution space to be, the greater is the contribution made by the parameter field calculated during the previous calibration process to each PNULPAR‑generated parameter field. The user‑supplied solution space dimensionality therefore provides a “lever” through which you can increase the efficiency of attainment of parameter fields which respect calibration constraints (as embodied in respect for an objective function that is deemed to “calibrate” the model). The cost of such a speed‑up strategy is, of course, some reduction in the diversity of the calibration‑adjusted random parameter sets thus obtained.",
      "header": "12.7.3 What to do Next",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "f00fef629bff",
      "next_id": "15d6e85d239c",
      "summary_self": "PNULPAR-modified parameter sets can be used in a PEST run (NOPTMAX=0) to calculate objective functions.  For nonlinear models, a single iteration (NOPTMAX=1, using a JCO file with the `/i` switch,  JACUPDATE=999, PHIRATSUF=0.001, RLAMFAC=-4) may suffice.  For large null spaces, use SVD-assist (section 10.6.3, Part I). Increasing the solution space dimensionality increases efficiency but reduces diversity.",
      "summary_prev": "PNULPAR modifies RANDPAR parameter sets to meet calibration constraints. It prompts for a post-calibration PEST control file (with JCO file),  confirmation of calibrated parameters (\"y\" or \"n\"), solution space dimensionality, optional Q<sup>1/2</sup>J matrix storage, input and output filename bases. It then modifies parameter sets based on null-space projection (Equation 12.7.2), preserving tied parameter ratios.  It halts if PESTMODE is not \"estimation\".",
      "summary_next": "RDMULRES reads data from multiple files (e.g., model1.out, model2.out, etc., from a batch file, Figure 12.2, or PEST runs using parval1.par, parval2.par, etc., and pestcase_svda.pst, Figure 12.3).  File names use an indicial integer.  -1.1E35 in model outputs indicates model failure; -1.22E35 indicates an abandoned run. A global record file (record.dat) can track results across multiple PEST runs.",
      "header_level_1": "12. Nonlinear Error and Uncertainty",
      "header_level_2": "12.7 PNULPAR",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "For SVD-assisted inversion in PEST with SVDA_EXTSUPER≠1, use model-provided base parameter derivatives. Set JACFILE=1 and DERCOM=0 for super parameters. External derivatives file must be uncompressed ASCII; JUPITER format and -1.11e33 values not supported. Base parameter JCO file needed for initial super parameter definition. SVDAPREP creates batch files if JACFILE=1.",
      "keywords": [
        "JACUPDATE",
        "NOPTMAX",
        "PHIRATSUF",
        "RLAMFAC",
        "lambdas"
      ],
      "similarity": 0.775661249577043,
      "normalized_semantic": 0.775661249577043,
      "normalized_keyword": 0.151205778121948,
      "combined_score": 0.3385424195584765
    },
    {
      "chunk_id": "ebdde2847310",
      "chunk_index": 1,
      "content": "To activate LHS2PEST level 3 functionality, it must be run using the following command.\nlhs2pest lhsoutfile parfilebase pestfile batchfile\nIn this case LHS2PEST does everything that level 2 functionality requires. However it also writes a batch file through which PEST can be run repeatedly based on the parameter value file sequence that LHS2PEST also generates. An example batch file is shown below.\n@echo off\nrem ############################################################\nrem Delete an existing record file.\nrem ############################################################\ndel /P record.dat\necho > record.dat\nrem ############################################################\nrem Do all the PEST runs.\nrem ############################################################\nfor /L %%i in (1,1,100) do (\nparrep random%%i.par temp1.pst t###.pst\ndel t###.rec\npest t###.pst\ncopy t###.res t###%%i.res\nphistats t###.rec %%i >> record.dat\n)\nFigure 13.1 A batch file written by LHS2PEST.\nThe batch file written by LHS2PEST runs PEST repeatedly through a processing loop. This loop is traversed as many times are there are Latin hypercube samples provided in the LHS output file. On each occasion on which PEST is run, the PARREP utility is first run in order to write a new PEST control file which is identical to the PEST control file nominated on the LHS2PEST command line except for the fact that its initial parameter values are those provided by the respective parameter value file, and hence constitute LHS‑generated Latin hypercube parameter sample values. This PEST control file is named t###.pst. After each PEST run, the PEST residuals file (named t###.res) is copied to file t###N.res) where N is the run index. Hence you can inspect the details of model‑to‑measurement fit calculated on the basis of all Latin hypercube parameter sets. If you do not want these files saved, comment out or delete the respective line from the batch file. Alternatively, request that other PEST files be saved by adding other commands of a similar type within the processing loop provided in the batch file.\nEach PEST run is followed by a PHISTATS run. This provides you with the opportunity to inspect a file named record.dat (rename this file in the batch file if you wish) at any loop count, and at the end of the loop altogether when all PEST runs have been completed. This file lists the sequence of objective functions that have been calculated on the basis of the different Latin hypercube sample sets that have been used until the time of inspection. At the start of the loop an existing file of this name (i.e. record.dat) is deleted. The batch file prompts for permission to delete this file before it actually does this.\nWhen run in level 3 mode, LHS2PEST writes the following message to the screen just before it terminates execution.\nThe value for NOPTMAX for all PEST runs initiated through the batch file will be 0.\nIf this is not your intention, alter NOPTMAX to an appropriate value in the PEST control file supplied in the command line.\nFigure 13.2 Warning written to screen by LHS2PEST on cessation of level 3 execution. See the discussion of the NOPTMAX variable earlier in this section (and in part I of this manual). NOPTMAX is an integer; it is the first variable on the 9th line of the PEST control file.",
      "header": "13.3.4 LHS2PEST - Level 3",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "2a3c5fc9e1ba",
      "next_id": "0771e20849b6",
      "summary_self": "LHS2PEST (level 3: lhs2pest lhsoutfile parfilebase pestfile batchfile) generates a batch file (Figure 13.1) running PEST repeatedly (using PARREP for each LHS sample set) and saving residuals (t###N.res). PHISTATS is run after each PEST run, appending objective function values to record.dat.  NOPTMAX is 0 by default; change it in pestfile if needed (Figure 13.2).",
      "summary_prev": "LHS2PEST (lhs2pest lhsoutfile parfilebase pestfile) reconciles LHS output (lhsoutfile) and PEST control file (pestfile) parameters.  It creates parameter value files (parfilebaseN.par) containing parameters from pestfile, using LHS samples where available, initial values otherwise, and clipping values exceeding bounds. Tied parameters adjust according to parent parameter values (with warnings for bound transgressions).  SCALEs and OFFSETs, and PRECIS/DPOINT values from pestfile are used.",
      "summary_next": "PEST2LHS creates a simplified LHS input file from a PEST control file and optional parameter uncertainty file (section 2.5).  It supports limited LHS options; users should manually modify the output file for more complex functionality.  The LHS output can then be used to create a PEST input dataset (using LHS2PEST).",
      "header_level_1": "13. Latin Hypercube Sampling",
      "header_level_2": "13.3 LHS2PEST",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.759968922136395,
      "normalized_semantic": 0.759968922136395,
      "normalized_keyword": 0.118555717170238,
      "combined_score": 0.31097967866008513
    },
    {
      "chunk_id": "1720c041e020",
      "chunk_index": 1,
      "content": "When running in “regularisation” mode, PEST will cease execution if the following conditions are met.\n1. NOPTMAX iterations have elapsed.\n2. The measurement objective function falls below the user-supplied target measurement.\nObjective function and the REGCONTINUE regularisation variable is missing or set to “nocontinue”.\n1. The measurement objective function falls below the value of the optional PHISTOPTHRESH variable supplied in the “control data” section of the PEST control file, regardless of the setting of the REGCONTINUE variable.\n2. Parameter changes between iterations are minimal as assessed through reference to the RELPARSTP and NRELPAR variables provided in the “control data” section of the PEST control file.\n3. The measurement objective function is greater than PHIMLIM but is falling very slowly as assessed through reference to the PHIREDSTP, NPHISTP and NPHINORED variables provided in the “control data” section of the PEST control file.\n4. The measurement objective function is lower than PHIMLIM, REGCONTINUE has been set to “continue” and the regularisation objective function is falling very slowly as assessed through reference to the PHIREDSTP, NPHISTP and NPHINORED variables provided in the “control data” section of the PEST control file.\nIn practice, it is often best for a user to terminate PEST execution him/herself, especially during an early calibration attempt of a new model where the target measurement objective function may be set very low in an attempt to find out just how good a fit with the calibration dataset PEST can actually achieve.",
      "header": "9.1.6 Termination Criteria",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "72454911513c",
      "next_id": "213e5751269f",
      "summary_self": "In \"regularisation\" mode, PEST stops if NOPTMAX iterations elapse, the measurement objective function reaches the target (PHIMLIM, REGCONTINUE=\"nocontinue\"), PHISTOPTHRESH is reached, parameter changes are minimal (RELPARSTP, NRELPAR), or objective function improvement is slow (PHIREDSTP, NPHISTP, NPHINORED, REGCONTINUE=\"continue\").  User termination is often preferable, especially during early calibration attempts.",
      "summary_prev": "Tikhonov regularization minimizes error variance and improves numerical stability by incorporating expert knowledge.  A low target objective function may cause instability; IREGADJ helps but SVD or LSQR (with MAXSING and EIGTHRESH settings or, for many parameters, LSQR) ensures stability.",
      "summary_next": "To use PEST's \"regularisation\" mode, set the PESTMODE variable in the \"control data\" section to \"regularisation\".",
      "header_level_1": "9. Tikhonov Regularisation (continuación)",
      "header_level_2": "9.1 General (continuación)",
      "header_summary_1": "Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.",
      "header_summary_2": "Tikhonov regularization enhances stability by reducing error variance and incorporating expert knowledge. To ensure stability, use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. User termination is recommended, especially in early calibration.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "NRELPAR",
        "PHIMLIM",
        "PHIREDSTP",
        "PHISTOPTHRESH",
        "REGCONTINUE",
        "RELPARSTP"
      ],
      "similarity": 0.756799401473862,
      "normalized_semantic": 0.756799401473862,
      "normalized_keyword": 0.0896696522831917,
      "combined_score": 0.2898085770403928
    },
    {
      "chunk_id": "9a71b3411681",
      "chunk_index": 1,
      "content": "JCB2PAR reads a JCB file written by PESTPP‑IES or RSI_HP containing parameter values comprising parameter ensembles. Normally the name of this file is case.N.par.jcb where the history‑matching process is based on file case.pst, and N is the iteration number.\nJCB2PAR operates in two ways, depending on the way that it is run. In the first of these ways it extracts a single row of the JCB file (this pertaining to a realization) and records parameter values comprising the nominated realization in a single parameter value file named according to the user’s choice. Alternatively, it can extract data comprising all rows of this file, and then write a series of parameter value files, one for each realization, thus collectively listing the contents of all parameter ensembles.\nTo extract a single ensemble from a JCB file, run JCB2PAR as follows.\njcb2par jcbfile realname parfile\nwhere\n- jcbfile is the name of a JCB file (for which a filename extension of “.jcb” is required),\n- realname is the name of a realization, and\n- parfile is the name of a parameter value file (for which an extension of “.par” is required).\nNote that realization names are integers, starting at zero, or “base”. Alternatively, JCB2PAR can be run using the following command.\njcb2par jcbfile all parfilebase\nwhere\n- jcbfile is the name of a JCB file (for which a filename extension of “.jcb” is required),\n- all must be written as “all”, and\n- parfilebase is a filename base.\nIn this latter case JCB2PAR writes a series of PAR files, one for each realization recorded in the JCB file. These parameter value files are named parfilebase_realname.par where parfilebase is the user-supplied filename base of the parameter value files, and realname is a realization name which, as stated above, is either an integer or “base”.\nAs is described elsewhere in this manual, parameter values recorded in a parameter value file can be inserted into a PEST control file using the PARREP utility. If NOPTMAX is set to zero in this PEST control file, the model can be run using these parameter values.",
      "header": "17.9 JCB2PAR",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "1c0a3902dce7",
      "next_id": "e471c04fff9e",
      "summary_self": "JCB2PAR extracts parameter sets from a JCB file (jcbfile.jcb).  `jcb2par jcbfile realname parfile` extracts a single realization (realname) to parfile.par; `jcb2par jcbfile all parfilebase` extracts all realizations to parfilebase_realname.par files.  These parameter value files can be used with PARREP to run PEST (NOPTMAX=0).",
      "summary_prev": "CSV2JCB converts a PESTPP-IES CSV file (csvfile.csv) to a JCB file (jcbfile.jcb) for processing by JCB-compatible utilities. Use `csv2jcb csvfile jcbfile`.",
      "summary_next": "JCB2AVEPAR creates a parameter value file (parfile.par) containing average parameter values (native or log-transformed, based on pestfile.pst) from a JCB file (jcbfile.jcb). Fixed/tied parameters use values from pestfile. Use `jcb2par jcbfile pestfile parfile`.",
      "header_level_1": "17. Support for the PEST++ Suite",
      "header_level_2": "",
      "header_summary_1": "SENSAN uses control, parameter variation, and PEST template and instruction files. It runs system commands post-model runs, with options for OS commands or executables. PEST templates generate model inputs, instructions read outputs. Run with `sensan infile`, using tempchek.exe and inschek.exe. Outputs include ABSFLE, RELFLE, SENSFLE. SENSCHEK checks input data.",
      "header_summary_2": "",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.758272902656729,
      "normalized_semantic": 0.758272902656729,
      "normalized_keyword": 0.0679183155298233,
      "combined_score": 0.27502469166789506
    },
    {
      "chunk_id": "739c120f0bd9",
      "chunk_index": 1,
      "content": "Files recorded by PEST are discussed later in this manual. They are also listed in appendix B. A file of particular importance is the Jacobian matrix file. This is named case.jco where case is the current PEST case name, that is the filename base of the PEST control file (of which the extension is always “.pst”). The binary file which holds a Jacobian matrix will often be referred to as a “JCO file” in this manual.\nAs was mentioned above, PEST calculates a Jacobian matrix during every iteration of the inversion process. Where parameters are improved from the previous iteration, the updated Jacobian matrix is recorded in a JCO file. To save space it is stored in binary, compressed format. Hence it cannot be inspected using a text editor. However it can be converted to ASCII format using the JACWRIT and JCO2MAT utilities provided with PEST. An individual row can be extracted from it, and its contents recorded in ASCII format, using the JROW2VEC utility. The JCO2JCO utility builds a new JCO file corresponding to a new PEST control file whose composition is a subset of that on which basis an original JCO file was recorded. Other utilities support the construction of a large JCO file from component JCO files built on the basis of smaller PEST datasets. See part II of this manual for details.\nThe JCO file finds many uses. Many of these uses are as important as the model calibration process itself. Hence it is not unusual for a PEST run to be undertaken purely for the purpose of filling a Jacobian matrix and writing a JCO file. This can be achieved if the NOPTMAX variable in the “control data” section of the PEST control file is set to -1 or -2.\nUses to which a JCO file may be put include the following:\n- Examination of sensitivities of model outputs with respect to parameters.\n- Giving PEST a “head start” in calibrating a model by providing it with a pre-calculated Jacobian matrix. This can be implemented by starting PEST, Parallel PEST or BEOPEST using the “/i” switch.\n- Definition of super parameters for an SVD-assist run. The super parameter PEST control file is then built using the SVDAPREP utility.\n- As a basis for the many types of linear analysis implemented using the utility programs documented in part II of this manual; these include calculation of:\n- parameter identifiability;\n- parameter and predictive uncertainty;\n- parameter contributions to predictive uncertainty;\n- data worth;\n- the effects of model defects.",
      "header": "3.6 The Jacobian Matrix File",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "08314b0e332c",
      "next_id": "71d303c880fc",
      "summary_self": "The Jacobian matrix file (case.jco) is a key PEST output.  It's a binary file, convertible to ASCII using JACWRIT and JCO2MAT; JROW2VEC extracts rows.  JCO2JCO creates subsets; other utilities combine JCO files (Part II).  Setting NOPTMAX to -1 or -2 generates a JCO file only.  JCO files support sensitivity analysis, model calibration, super parameter definition, and linear analysis (Part II).",
      "summary_prev": "PEST's Jacobian matrix calculation is computationally intensive.  Parallel PEST and BEOPEST parallelize model runs.  SVD-assist (section 6.4.4 of Doherty 2015) uses super parameters.  Observation re-referencing (Chapter 14) uses simplified models (Burrows and Doherty 2015).",
      "summary_next": "PEST minimizes a weighted least-squares objective function (∑(wi ri)² ) in \"estimation\" mode.  \"Predictive analysis\" maximizes/minimizes a prediction subject to an objective function constraint. \"Regularisation\" uses measurement and regularization objective functions. \"Pareto\" mode trades off objective functions by adjusting weights.  Objective functions are calculated for observation groups, allowing weight adjustments.",
      "header_level_1": "3. What PEST Does",
      "header_level_2": "",
      "header_summary_1": "This chapter introduces PEST, a tool for solving inverse problems in four modes: \"estimation\", \"predictive analysis\", \"regularisation\", and \"pareto\". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.",
      "header_summary_2": "",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.746879935264587,
      "normalized_semantic": 0.746879935264587,
      "normalized_keyword": 0.0594345256686211,
      "combined_score": 0.2656681485474109
    }
  ]
}