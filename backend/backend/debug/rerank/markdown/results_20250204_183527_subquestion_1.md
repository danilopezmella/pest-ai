# Search Results for: what is noptmax

Keywords: noptmax


## Context

### Summary
**LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.**

### Header
**13.3.1 General**

### Content
LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.
PEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.
If NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.
For NOPTMAX not set to zero, the following should be noted.
• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.
• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)
• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.
Use of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.
It is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.
The tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 13. Latin Hypercube Sampling
- **Subsection:** 13.3 LHS2PEST

### Additional Summaries
- **Higher-Level Summary:** PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.
- **Detailed Summary:** LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.

### Related Context
- **Previous Summary:** PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for "pareto" mode runs. Use `phistats recfile N`.
- **Next Summary:** LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS="single", DPOINT="point" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 1c679819e0a7
- **Chunk Index:** 1
- **Previous Chunk ID:** 578d27a8ea30
- **Next Chunk ID:** e09851a2d028

---

## Context

### Summary
**PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.**

### Header
**4.4 PARREP**

### Content
Program PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.
Recall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.
PARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.
PARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.
PARREP is run using the command
parrep parfile pestfile1 pestfile2 [new_noptmax]
where
|parfile|is the name of a parameter value file,|
|---|---|
|pestfile1|is the name of an existing PEST control file,|
|pestfile2|is the name for the new PEST control file, and|
|new_noptmax|optionally provides a new value for NOPTMAX.|
When PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.
A special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 4. Building and Altering a PEST Control File
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).
- **Next Summary:** OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** d131ce523618
- **Chunk Index:** 1
- **Previous Chunk ID:** 51cac29a6097
- **Next Chunk ID:** 05375a187143

---

## Context

### Summary
**IDENTPAR calculates parameter identifiability from a PEST control file and JCO file. Use `identpar case N vecfilebase matfile identfile [/s or /r]`.  It performs SVD on JtQJ (default) or Q1/2J, outputs eigenvector sensitivity vectors (vecfilebase), V1 matrix (matfile), and identifiability (identfile, sum of eigencomponent squared cosines).  Regularization groups are ignored in "regularization" mode.**

### Header
**8.7.2 Using IDENTPAR**

### Content
IDENTPAR is run using the command
identpar case N vecfilebase matfile identfile [/s or /r]
where
- case is the filename base of a PEST control file,
- N is the number of dimensions comprising the calibration solution space,
- vecfilebase is the filename base to which eigencomponent sensitivity vectors are to be written (supply this as “null” if these are not to be written),
- matfile is the name of a matrix file to which the V1 matrix is to be written (supply this as “null” if this is not to be written),
- identfile is the name of a file to which parameter identifiability data is to be written (supply this as “null” if this file is not to be written),
- /s (optional) instructs IDENTPAR to undertake singular value decomposition of JtQJ, (the default), while
- /r (optional) instructs IDENTPAR to undertake singular value decomposition of Q1/2J.
IDENTPAR begins execution by reading the PEST control file corresponding to the user-supplied filename base. It reads parameter data and observation weights from this file (and any observation covariance matrices cited in the “observation groups” section of the PEST control file if these are employed for any observation groups instead of weights). It then reads the Jacobian matrix corresponding to this PEST control file. As usual, this file is assumed to
have the same filename base as the PEST control file but to possess an extension of “.jco”; it is thus assumed that this file exists and has been computed either on the basis of initial parameter values recorded in the PEST control file (set NOPTMAX to ‑1 or ‑2 to do this) or during a prior parameter estimation process.
IDENTPAR next forms the JtQJ matrix (or Q1/2J matrix depending on the user’s choice of the “/s” or “/r” switch – where “s” stands for “square matrix” and “r” stands for “rectangular matrix”) and carries out singular value decomposition of the chosen matrix. On the basis of N as supplied by the user on the IDENTPAR command line, it then records the following information. Note however, that any of the following three tasks can be disabled by providing a name of “null” for the pertinent filename base or filename in the IDENTPAR command line.
First IDENTPAR writes a series of “vector files” containing the columns of V1 (see Doherty, 2015). Suppose that the user‑supplied basename for these files is vfile. Then the files will be named vfile1.vec, vfile2.vec…..vfileN.vec. Any of these files can be used as a predictive sensitivity file by any of the PREDVAR‑suite or PREDUNC‑suite utilities described elsewhere in this manual.
If matfile in the IDENTPAR command line is set to a value other than “null”, IDENTPAR writes the columns of V1 to a single file in PEST matrix file format.
If identfile in the IDENTPAR command line is set to a value other than “null”, IDENTPAR computes the identifiability of each parameter and records it to the nominated file. It also records the square of the magnitude of the projection of each unit parameter vector onto each eigencomponent comprising columns of the V1 matrix. These are the eigencomponent squared cosines defined by equation 7.2.5 of Doherty (2015). The pertinent element in the “identifiabililty” column in this same file is the square of the magnitude of the projection of each unit parameter vector onto the totality of this space as spanned by all solution space eigencomponent vectors. It is thus the sum of the preceding columns.
Interesting and informative plots can be produced by importing identfile into a spreadsheet or graphing program. For example figure 8.3 shows a bar chart of parameter identifiabilities, with the contribution from each solution space eigencomponent demarcated by colour within each parameter‑specific bar. It is apparent that some parameters (such as par3, par8, par9 and par11 are very identifiable, whereas others (such as par13 to par17) are not.
Figure 8.3 Bar chart of parameter identifiabilities coloured by contributions made to total identifiability by different solution space eigencomponents.
Plots such as that provided in figure 8.3 can be made even more informative if warmer colours (reds and yellows) are ascribed to projections onto eigencomponent vectors (i.e. unit vectors v comprising columns of the V matrix) associated with high singular values and cooler colours (blues and greens) are ascribed to projections onto eigencomponent vectors associated with low singular values. As discussed by Doherty (2015), measurement‑noise‑induced errors associated with estimated values of parameter eigencomponent projections increase as singular values associated with eigencomponents decrease. Warmer colours may therefore be indicative of smaller post‑calibration error variance.
The following should be noted.
1. Weights used in computation of Q1/2J (or JtQJ) are those provided in the cited PEST control file.
2. Use of the Q1/2J and JQJ matrices should lead to identical identifiabilities. However if many parameters and/or observations are featured in the inversion process then the “/r” option should be used in running IDENTPAR as its execution will probably then be faster.
3. If PEST is run in “regularisation” mode, observations and prior information equations belonging to regularisation groups are ignored by IDENTPAR.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software
- **Main Section:** 8. PEST Statistical Postprocessing
- **Subsection:** 8.7 IDENTPAR

### Additional Summaries
- **Higher-Level Summary:** In "predictive analysis" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.
- **Detailed Summary:** Parameter identifiability quantifies estimability from the calibration dataset on a scale of 0.0 to 1.0. It depends on solution space dimensionality and can be calculated using IDENTPAR from a PEST control file and JCO file. The tool performs SVD on JtQJ or Q1/2J and outputs sensitivity vectors, matrices, and identifiability information.

### Related Context
- **Previous Summary:** Parameter identifiability (Doherty 2015, section 7.2.1),  between 0.0 and 1.0, quantifies estimability from the calibration dataset (1.0=completely estimable, 0.0=completely insensitive).  It may depend on solution space dimensionality (SUPCALC, SSSTAT, PREDVAR1);  GENLINPRED's relative uncertainty reduction may be superior.  Identifiability provides information on data flow to the solution space.
- **Next Summary:** PARAMID (not recommended) analyzes PEST's SVD file (requires PESTMODE="estimation", EIGWRITE=1, RLAMBDA1=0, NUMLAM=1, NOPTMAX≥1), listing parameter contributions to calibration solution space eigenvectors. A full PEST run is unnecessary if a JCO file exists; use the `/i` switch.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 654fc3edf762
- **Chunk Index:** 1
- **Previous Chunk ID:** abf89191b536
- **Next Chunk ID:** 0b264bcf7a9c

---

## Context

### Summary
**The Jacobian matrix file (case.jco) is a key PEST output.  It's a binary file, convertible to ASCII using JACWRIT and JCO2MAT; JROW2VEC extracts rows.  JCO2JCO creates subsets; other utilities combine JCO files (Part II).  Setting NOPTMAX to -1 or -2 generates a JCO file only.  JCO files support sensitivity analysis, model calibration, super parameter definition, and linear analysis (Part II).**

### Header
**3.6 The Jacobian Matrix File**

### Content
Files recorded by PEST are discussed later in this manual. They are also listed in appendix B. A file of particular importance is the Jacobian matrix file. This is named case.jco where case is the current PEST case name, that is the filename base of the PEST control file (of which the extension is always “.pst”). The binary file which holds a Jacobian matrix will often be referred to as a “JCO file” in this manual.
As was mentioned above, PEST calculates a Jacobian matrix during every iteration of the inversion process. Where parameters are improved from the previous iteration, the updated Jacobian matrix is recorded in a JCO file. To save space it is stored in binary, compressed format. Hence it cannot be inspected using a text editor. However it can be converted to ASCII format using the JACWRIT and JCO2MAT utilities provided with PEST. An individual row can be extracted from it, and its contents recorded in ASCII format, using the JROW2VEC utility. The JCO2JCO utility builds a new JCO file corresponding to a new PEST control file whose composition is a subset of that on which basis an original JCO file was recorded. Other utilities support the construction of a large JCO file from component JCO files built on the basis of smaller PEST datasets. See part II of this manual for details.
The JCO file finds many uses. Many of these uses are as important as the model calibration process itself. Hence it is not unusual for a PEST run to be undertaken purely for the purpose of filling a Jacobian matrix and writing a JCO file. This can be achieved if the NOPTMAX variable in the “control data” section of the PEST control file is set to -1 or -2.
Uses to which a JCO file may be put include the following:
- Examination of sensitivities of model outputs with respect to parameters.
- Giving PEST a “head start” in calibrating a model by providing it with a pre-calculated Jacobian matrix. This can be implemented by starting PEST, Parallel PEST or BEOPEST using the “/i” switch.
- Definition of super parameters for an SVD-assist run. The super parameter PEST control file is then built using the SVDAPREP utility.
- As a basis for the many types of linear analysis implemented using the utility programs documented in part II of this manual; these include calculation of:
- parameter identifiability;
- parameter and predictive uncertainty;
- parameter contributions to predictive uncertainty;
- data worth;
- the effects of model defects.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 3. What PEST Does
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** This chapter introduces PEST, a tool for solving inverse problems in four modes: "estimation", "predictive analysis", "regularisation", and "pareto". It uses control files with specific sections and options for parameter adjustments, transformations, and derivative calculations. PEST generates Jacobian matrices and offers utilities for file manipulation and sensitivity analysis.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** PEST's Jacobian matrix calculation is computationally intensive.  Parallel PEST and BEOPEST parallelize model runs.  SVD-assist (section 6.4.4 of Doherty 2015) uses super parameters.  Observation re-referencing (Chapter 14) uses simplified models (Burrows and Doherty 2015).
- **Next Summary:** PEST minimizes a weighted least-squares objective function (∑(wi ri)² ) in "estimation" mode.  "Predictive analysis" maximizes/minimizes a prediction subject to an objective function constraint. "Regularisation" uses measurement and regularization objective functions. "Pareto" mode trades off objective functions by adjusting weights.  Objective functions are calculated for observation groups, allowing weight adjustments.

### Metadata
- **Keywords:** NOPTMAX
- **Chunk ID:** 739c120f0bd9
- **Chunk Index:** 1
- **Previous Chunk ID:** 08314b0e332c
- **Next Chunk ID:** 71d303c880fc

---

## Context

### Summary
**For SVD-assisted Pareto analysis, perform a standard Pareto run (NOPTMAX=-1 or -2), generate a JCO file, then use SVDAPREP to create a super-parameter control file.  SVDA_MULBPA=1 automatically saves multiple case.bpa.N files.  case.svda.ppd contains base parameter values. SVDA_PAR_EXCL (0, 1, or -1) controls super parameter definition; 1 is recommended for manual regularization.  To reduce parameter variability, use expert knowledge observations as PARETO_OBSGROUP and run from overfit parameters. JCO2JCO adds prior information sensitivities to a JCO file.**

### Header
**12.8 An Example**

### Content
3. Run PEST. The information in the case.pod, case.ppd and case.par files produced on this new run then supplements information contained in files of similar name produced on the previous run.
13.4.3 Special Considerations for SVD-Assist
If you wish to use SVD-assist for exploration of the Pareto front, this is easily accomplished. As is normal protocol for SVD-assisted inversion, the following steps should be taken.
1. Set up a Pareto run in the manner described above.
2. Set NOPTMAX to -1 or -2 in the PEST control file.
3. Run PEST to produce a JCO file.
4. Run SVDAPREP in order to produce a PEST control file for SVD-assisted Pareto front exploration.
When PEST is run in “pareto” mode when undertaking SVD-assisted inversion, the SVDA_MULBPA variable is automatically set to 1. Thus multiple case.bpa.N files are saved – one at the end of each iteration. As usual, these are named after the base parameter PEST control file; they contain base parameter values corresponding to points along the Pareto front as defined in file case-svda.pod; note how the filename base of the “.pod” file corresponds to that of the super parameter PEST control file, this being the PEST control file that is actually used for Pareto front traversal. Under these circumstances, PEST does not leave a succession of “.par” files, as the super parameter values that would be recorded in files case-svda.par.N are of no real use to the modeller.
When undertaken SVD-assisted traversal of the Pareto front, parameter values recorded in the “.ppd” file (i.e. in file case-svda.ppd) are actually base parameter values. This makes it easy for the user to link points on the Pareto front (as defined by objective functions listed in file case-svda.pod) to parameter values as actually used by the model.
An extra setting is available when implementing SVD-assisted exploration of the Pareto front. This is supplied through the SVDA_PAR_EXCL control variable which resides in the “svd assist” section of the PEST control file immediately following the SVDA_SUPDERCALC variable. SVDA_PAR_EXCL must be set to 0, 1 or -1. If it is set to 1, super parameters are defined using only sensitivities of model outputs that comprise the observation group whose weight factor is adjusted during the Pareto front exploration process; this is the observation group whose name is provided as the PARETO_OBSGROUP variable in the “pareto” section of the PEST control file. In the regularisation context, members of this observation group are the measurements that are fitted during the calibration process. Prior information equations and observations which express expert knowledge are thus ignored in defining super parameters. Limited experience to date suggests that SVDA_PAR_EXCL is best set to 1 when using the Pareto process as a manual regularization device.
If SVDA_PAR_EXCL is set to 0, super parameter definition is based on all observations and prior information equations cited in the base PEST control file (using the weights provided in that file).
If SVDA_PAR_EXCL is set to -1, then super parameters are computed on the basis of all observation groups in the PEST control file other than that named as the Pareto-adjustable group in the super parameter PEST control file. This is useful if traversal of the Pareto front takes place in the opposite direction – that is, from a fit which is initially too good (based on parameters which are too heterogeneous) to a fit which is not as good but which is based on more acceptable parameters (see below).
When SVDAPREP is used in order to build a super parameter PEST control file, it checks the setting of the PESTMODE variable in the base parameter PEST control file. If this is set to “pareto” SVDAPREP asks the user for an appropriate setting for SVDA_PAR_EXCL. Its prompt (SVDAPREP’s final prompt) is:
Provide setting for SVDA_PAR_EXCL [0, 1, or -1] (&lt;Enter&gt; if 0):
The default is 0 (for this is the best setting to use when using the Pareto concept to explore predictive uncertainty). Respond with “1” to set SVDA_PAR_EXCL to 1 in the super PEST control file written by SVDAPREP, “0” to set SVDA_PAR_EXCL to 0 in this file, or “-1” to set it to -1.
13.4.4 Going the Other Way
Suppose that you have just calibrated a model and that the calibrated parameter field contains too much variability. Suppose that you would like to remove some of this variability by slowly introducing stronger and stronger enforcement of regularisation constraints, thereby maintaining as good a fit with measurements as possible while removing some of the more unsightly aspects of the calibrated parameter field. This is easily achieved by assigning all expert knowledge prior information equations and expert knowledge observations to a single observation group, and assigning the name of that group to the PARETO_OBSGROUP variable in the “pareto” section of the PEST control file. Initial parameter values should be those that provided “too good a fit” with the data. PEST can then reduce variability of this parameter field by moving towards the end-point of the Pareto front where expert knowledge observations dominate measurement observations.
In doing this, it may be helpful to remember that if prior information is added to a PEST control file after a JCO file has been computed for that file, the JCO2JCO utility will automatically include the sensitivities for the additional prior information in the new JCO file which it constructs for the new PEST control file.

### Source
- **File Name:** PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers
- **Main Section:** 12. Model-Calculated Derivatives (continuación)
- **Subsection:** 

### Additional Summaries
- **Higher-Level Summary:** PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.
- **Detailed Summary:** 

### Related Context
- **Previous Summary:** In Pareto mode (PESTMODE="pareto"),  assign all observations to one group (PARETO_OBSGROUP) and set initial parameters to achieve a zero expert knowledge objective function.  Use weights inversely proportional to parameter standard deviations or covariance matrices.  Set PARETO_WTFAC_START to 0, PARETO_WTFAC_FIN to 1.5-2.0, NUM_WTFAC_INC to 15-20, NUM_ITER_START to 0, NUM_ITER_GEN to 2, and NUM_ITER_FIN to 2.  Plot case.pod to visualize the Pareto front; case.ppd and case.par.N contain parameter values.  Parallel PEST and BEOPEST are supported;  normal restart functionality applies.
- **Next Summary:** In Pareto mode, PEST reports the current PARETO_OBSGROUP weight factor per iteration.  Unlike other modes, it produces multiple parameter files (case.par.N), omits case.res, case.rsr, and case.rei (unless REISAVEITN="reisaveitn"), and saves the JCO file only after the first iteration.  Termination criteria are from the "pareto" section;  NOPTMAX still applies.  FORCEN cannot be "switch" or "switch_5".  SVD, LSQR, and AUI are supported.

### Metadata
- **Keywords:** NOPTMAX, PARETO_OBSGROUP, PESTMODE, SVDA_MULBPA, SVDA_PAR_EXCL, SVDA_SUPDERCALC
- **Chunk ID:** 27a8375f23d2
- **Chunk Index:** 9
- **Previous Chunk ID:** 32d7e046d625
- **Next Chunk ID:** 68e82e019e36

---
