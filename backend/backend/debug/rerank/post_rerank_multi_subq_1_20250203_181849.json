{
  "subquestion": "How can I use NUMLAM?",
  "variations": [],
  "keywords": [
    "numlam"
  ],
  "top_results": [
    {
      "chunk_id": "bdc8c3cc13a0",
      "chunk_index": 2,
      "content": "In response to this imperative, PARLAM can be set to a negative number. As long as it is non-zero, partial parallelisation of the lambda search procedure is activated. However the number of agents involved in this lambda search procedure is limited to the absolute value of PARLAM. Thus, for example, if parallelisation is being undertaken using 50 agents, and if PARLAM is set to -4, then Parallel PEST involves only 4 agents in the partial parallelisation of lambda testing.\nA PARLAM setting of -9999 however has special significance. This setting should only be employed where a user has access to a relatively large number of computing nodes of equal power. If PARLAM is set to -9999, the parallel lambda testing procedure follows the strategy set out below.\n1. Only one cycle of parallel runs is devoted to testing Marquardt lambdas; PEST will not commit to a second cycle, irrespective of results forthcoming from the first cycle.\n2. The maximum number of parallel runs constituting this cycle is set to NUMLAM, the variable in the “control data” section of the PEST control file which sets the\nmaximum number of lambda-testing runs undertaken per iteration. However if there are less agents than NUMLAM available at the time that lambda testing is required, NUMLAM is temporarily reduced to the number of available agents.\n1. If it is not supplied as a negative number, RLAMFAC (the lambda multiplier employed in lambda testing) is set internally to the negative of its supplied value. Hence, as described in section 4.2.6 of this manual, a much wider range of lambda values is tested than would be the case if a value-independent multiplier were employed.\n2. Tested lambda values (on different agent machines) are disposed in equal numbers above and below the current value of the Marquardt lambda.\n3. The outcomes of all such runs are read, irrespective of “trends” discovered from the processing of early returns. Thus if the dependence of the objective function on the Marquardt lambda is irregular (such as can occur if finite-difference derivatives are compromised as a result of model output granularity), an “accidental” low objective function corresponding to a random lambda will not be missed.\nUse of a PARLAM setting of -9999 is recommended where a user has access to a large number of computing nodes, many of which would be standing idle while implementing a partially parallelised lambda testing strategy. The user must remember however, that the number of model runs employed for lambda testing is set by NUMLAM, and not by the number of agents/nodes available. Hence NUMLAM may need to be set higher than normal. Note also that, as stated above, only one round of lambda-testing runs is undertaken.\nIt is important to note that for all PARLAM settings other than -9999 Parallel PEST will serialize the lambda testing procedure if any parameter hits its bound, even though it may have commenced the lambda testing procedure as a parallelised process. As stated above, this is because it reformulates the inverse problem to accommodate the fact that the parameter is temporarily non-adjustable.\nDespite its advantages, caution should be exercised when setting PARLAM to -9999. If a model is susceptible to crashing when it is supplied with parameter values that it finds unpalatable, this is most likely to occur during the lambda testing procedure, for this is the part of the parameter estimation process where parameter values are most different from those that have been employed previously. Testing of a wide range of lambda values in this parallel fashion can increase the chances of model run failure. Note, however, that PEST failure can be prevented through an appropriate setting of the LAMFORGIVE control variable. This can reduce some of the risks associated with setting PARLAM to -9999.\nAnother negative feature of a -9999 PARLAM setting is that PEST’s ability to sequentially and temporarily freeze parameters that have hit their bounds (and re-formulate the inverse problem accordingly) is compromised to some extent. Nevertheless the methodology for partially parallelised lambda testing supported by a PARLAM value of -9999 can be of great use where, as stated above, model derivatives are compromised because of model numerical imperfections, and/or the number of processors to which Parallel PEST has access is high.\nIf setting PARLAM to -9999, it is a good idea to set RLAMFAC to a higher negative value than normal (for example a value of -4 rather than the recommended values of -2 or -3) so that it can sample the objective function vs. lambda curve in greater detail (perchance to fall into objective function crevices in a possibly noisy relationship between Marquardt lambda and the objective function).",
      "header": "11.2.6 Alternative PARLAM Settings",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "e4b1d5dd3fcb",
      "next_id": "c666fa5fe8ca",
      "summary_self": "PARLAM (non-zero negative integer) limits agents in parallel lambda testing; -9999 runs one cycle (NUMLAM runs), using a wider range of lambdas (RLAMFAC becomes its negative), and processes all results regardless of trends. This is recommended with many nodes but may increase model failure risk (mitigated by LAMFORGIVE); parameter freezing is also affected.",
      "summary_prev": "Parallel PEST partially parallelizes Marquardt lambda testing.  It runs models with multiple lambdas concurrently; however, runs exceeding 1.8 times the fastest run are excluded.  The \"packet\" size equals the number of fast agents.  Decision-making occurs after each packet, potentially wasting some runs. The process differs from serial lambda testing, potentially leading to different paths to the solution.  Limiting the number of agents is recommended to prevent problems from widely varying lambdas.",
      "summary_next": "In Parallel PEST, a negative NUMLAM value in the PEST control file automatically sets PARLAM to -9999, overriding the run management file's PARLAM value. The number of parallel model runs then equals the absolute value of NUMLAM.",
      "header_level_1": "11. Parallel PEST and BEOPEST (continuación)",
      "header_level_2": "11.2 Parallel PEST – Concepts and Specifications",
      "header_summary_1": "Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.",
      "header_summary_2": "Parallel PEST distributes model runs across networked machines, using a PAGENT agent program on each machine. It requires separate folders for agents to avoid file conflicts and uses shared signal files for communication. The run management file lists agents, runtimes, and filenames. Parallel PEST partially parallelizes Marquardt lambda testing, potentially leading to different solution paths.",
      "keywords": [
        "LAMFORGIVE",
        "NUMLAM",
        "RLAMFAC",
        "lambdas"
      ],
      "similarity": 0.743155925650116,
      "normalized_semantic": 0.743155925650116,
      "normalized_keyword": 0.20746223628521,
      "combined_score": 0.36817034309468183,
      "reranked_score": 0.36817034309468183,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 4752,
        "semantic_score": 0.743155925650116,
        "keyword_score": 0.20746223628521,
        "combined_score": 0.36817034309468183,
        "final_score": 0.36817034309468183
      }
    },
    {
      "chunk_id": "d693b4aa5fb9",
      "chunk_index": 1,
      "content": "Unlike Parallel PEST, BEOPEST does not need to read a run management file. Recall that this file has the same filename base as the PEST control file, but has an extension of “.rmf”. As the agents, and not the manager, write model input files and read model output files, the manager does not need to know the names and locations of agent working folders. Nor does it need to know in advance of a BEOPEST run how many agents are at its disposal. It will simply add agents to its register as they open communications with the BEOPEST manager through the TCP/IP protocol, and allocate them runs as long as they are still prepared to implement these runs.\nNevertheless, if a run management file is present within the directory from which the manager is launched, the BEOPEST manager will read the first two lines of this file. Actually it will only read two variables from this file. The first is PARLAM; the second is the optional RUN_SLOW_FAC variable. PARLAM is the fourth variable on the second line of the run management file, while RUN_SLOW_FAC can be placed anywhere on this line. Note that BEOPEST will not read the WAIT variable. Hence BEOPEST cannot be instructed to temporarily pause its run management at critical moments so that the operating system can catch up with it; this is unnecessary.\nPARLAM\nRecall from section 11.2.6 above that PARLAM settings are as follows.\n|PARLAM setting|PEST action|\n|---|---|\n|0|Do not parallelise model runs when testing different parameter upgrades calculated on the basis of different Marquardt lambdas.|\n|1|Parallelise the lambda search procedure. Use all available agents in this process. Return to serial processing if a parameter hits its bound.|\n|-N|Parallelise the lambda search procedure. Use a maximum of N agents in this process. Return to serial processing if a parameter hits its bound.|\n|-9999|Parallelise the lambda search procedure. Use a maximum of NUMLAM agents, and undertake only one round of lambda testing.|\nAs is explained above, a setting of -9999 is the best to use where model run times are long.\nand where a user has access to a moderate to high number of agents whose run times are similar. In that case it may be wise to set the NUMLAM variable in the “control data” section of the PEST control file to a higher-than-normal value if it would otherwise be smaller than the number of available agents. (Recall that the NUMLAM variable governs the maximum number of model runs that PEST will commit to the testing of different Marquardt lambdas.) However a value of 15 is normally high enough.\nAs was stated above, it is important to note that for all PARLAM settings other than -9999, PEST abandons parallelisation of the lambda search procedure if any parameter encounters its bounds. Traditional lambda-based upgrading then becomes a serial procedure as the parameter upgrade direction is re-calculated in a manner that is dependent on the number of parameters that have not yet encountered their bounds. However with PARLAM set to -9999, PEST will, under no circumstances, undertake a second set of model runs during the lambda testing procedure pertaining to any one iteration of the inversion process; nor will it serialize the lambda search procedure. This ensures that no processors are idle during the lambda testing procedure. Where a user has many processors at his/her disposal, some lack of efficiency in conducting the lambda search that is incurred through failure to serialize this search as parameters encounter their bounds, may be more than compensated by efficiencies gained through keeping all processors busy.\nIf you wish, you can provide BEOPEST with a PARLAM setting of -9999 without having to provide a run management file. If NUMLAM is set to a negative number in the PEST control file, then if PEST is run as Parallel PEST or BEOPEST, the PARLAM variable will automatically be set to -9999. The number of parallel model runs used in the Marquardt lambda testing procedure is then equal to the absolute value of NUMLAM. If a run management file is present, a negative NUMLAM value overrides the PARLAM value setting provided in that file.\nRUN_SLOW_FAC\nIf you wish to provide BEOPEST with a value for RUN_SLOW_FAC then a run management file must be present in the folder in which the BEOPEST manager is run. Recall from section 11.2.5 that this variable is optional and can be placed anywhere on the second line of this file. In fact, if supplied to BEOPEST, all other variables can be missing from this line and BEOPEST will not care. Figure 11.7 shows a run management file suitable for the use of BEOPEST in which RUN_SLOW_FAC is assigned a value of 5.0. Because all other variables are missing from this line PARLAM is assigned a default value of 1; alternatively it may have been assigned a value of -9999 through a negative NUMLAM setting in the PEST control file.\nprf\nrun_slow_fac = 5.0\nFigure 11.7 A run management file for the use of BEOPEST in which it is supplied a value for RUN_SLOW_FAC.\nBEOPEST will also accept a run management file such as that depicted in figure 11.5 in which other variables are represented on its second line.",
      "header": "11.4.10 The Run Management File, PARLAM and RUN_SLOW_FAC",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "d535c6f4c51d",
      "next_id": "fa495ccc2398",
      "summary_self": "BEOPEST does not require a run management file but will read PARLAM and RUN_SLOW_FAC from it if present. PARLAM settings (0, 1, -N, -9999) control parallel lambda searching; -9999 is best for many agents with similar runtimes and long model run times. A negative NUMLAM in the control file sets PARLAM to -9999, overriding the run management file. RUN_SLOW_FAC (real, >1.0) sets the threshold for considering a run overdue.",
      "summary_prev": "BEOPEST supports multiple model command lines (NUMCOM > 1 in the \"control data\" section), sending the command index to each agent.  All necessary files must be accessible from all agent folders.  Parameter-specific command indices are set using DERCOM in the \"parameter data\" section.",
      "summary_next": "BEOPEST's run management record file (case.rmr) logs communication between the manager and agents; it uses the same filename base as the PEST control file.",
      "header_level_1": "11. Parallel PEST and BEOPEST (continuación)",
      "header_level_2": "11.4 BEOPEST",
      "header_summary_1": "Parallel PEST and BEOPEST parallelize model runs to reduce run time. Parallel PEST needs a run management file, while BEOPEST's is optional. Both distribute runs to available machines, with BEOPEST using faster TCP/IP communication. Parallel PEST uses PAGENT agents, requires separate folders for agents, and shared signal files for communication. BEOPEST offers ease of use, faster communication, flexibility, and support for multiple command lines and surrogate models.",
      "header_summary_2": "BEOPEST, a preferred option over Parallel PEST, offers ease of use, faster communication via TCP/IP, flexibility, and support for multiple command lines and surrogate models. It does not require a run management file but can read certain settings from it. Agents are \"smart,\" handling input and output files locally.",
      "keywords": [
        "NUMLAM",
        "lambdas"
      ],
      "similarity": 0.716249002404244,
      "normalized_semantic": 0.716249002404244,
      "normalized_keyword": 0.0706726908683777,
      "combined_score": 0.26434558432913763,
      "reranked_score": 0.26434558432913763,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 5139,
        "semantic_score": 0.716249002404244,
        "keyword_score": 0.0706726908683777,
        "combined_score": 0.26434558432913763,
        "final_score": 0.26434558432913763
      }
    },
    {
      "chunk_id": "ec39245ac93b",
      "chunk_index": 1,
      "content": "If you wish to provide REGPRED with an SVD file instead of a resolution data file and you don’t already have one, then follow these steps. It is assumed that you have a PEST control\nfile in which optimised parameter values are initial values, and that you have run PEST to produce a corresponding JCO file.\n1. Set NUMLAM to 1 and RLAMBDA1 to zero in the PEST control file.\n2. Remove all regularisation observations and prior information from this file; this can be facilitated using the SUBREG1 utility.\n3. Add a “singular value decomposition” section to this file. Be sure to set EIGWRITE to 1.\n4. Set NOPTMAX to 1.\n5. Use the JCO2JCO utility to create a JCO file corresponding to this new PEST control file.\n6. Start PEST on the basis of the new PEST control file using the “/i” switch. When prompted for the name of a JCO file, supply the name of the JCO file that was just written by JCO2JCO. PEST will then undertake three model runs – one to compute the objective function, one to test an upgrade vector, and one on the basis of “best fit parameters”. However no model runs will be required for calculation of the Jacobian matrix, as this is read from the existing JCO file.",
      "header": "12.12.6 Using the SVD Matrix Option",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "c0a8e6ba741f",
      "next_id": "3048746834e9",
      "summary_self": "To generate an SVD file for REGPRED,  modify the PEST control file: set NUMLAM=1, RLAMBDA1=0, remove regularization (SUBREG1), add an \"SVD\" section (EIGWRITE=1), set NOPTMAX=1, create a new JCO file (JCO2JCO), and run PEST using the `/i` switch (supplying the new JCO filename).  This generates an SVD file containing the V matrix.",
      "summary_prev": "REGPRED creates a predictive analysis PEST control file.  It prompts for a PEST control file (with optimized parameters/outputs) and requires a resolution or SVD matrix. It removes regularization information, sets NOPTMAX=50, and uses conservative predictive analysis settings.  It checks for a \"predict\" group (one observation only), otherwise prompts the user to add one.  Observation weights are assigned based on uncertainty; zero-weighted observations remain zero-weighted.",
      "summary_next": "ASSESSPAR assesses parameter reasonableness in model-based hypothesis testing (e.g.,  \"pareto\" mode). It compares calibrated parameter values to prior expected values (from the PEST control file), calculating chi-square and normal variates (assuming multi-Gaussian prior parameter probabilities). An optional prediction-specific normal variate is computed (requires prediction sensitivities from a JCO file).  Results are tabulated, including eigenparameters (standard deviation=1.0).",
      "header_level_1": "12. Nonlinear Error and Uncertainty",
      "header_level_2": "12.12 REGPRED",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "REGPRED is an older utility for predictive uncertainty analysis, requiring a prior regularized inversion. It uses a predictive approach considering calibration data and expert knowledge. Less efficient than Monte Carlo methods, it sets up PEST predictive runs, calculating null-space deviations and constraints for parameter realism. It prompts for solution space dimensions and requires an optimized PEST control file with calibrated parameters and model outputs.",
      "keywords": [
        "EIGWRITE",
        "NOPTMAX",
        "NUMLAM",
        "RLAMBDA1"
      ],
      "similarity": 0.716136294413677,
      "normalized_semantic": 0.716136294413677,
      "normalized_keyword": 0.0538739785552025,
      "combined_score": 0.2525526733127449,
      "reranked_score": 0.2525526733127449,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 1180,
        "semantic_score": 0.716136294413677,
        "keyword_score": 0.0538739785552025,
        "combined_score": 0.2525526733127449,
        "final_score": 0.2525526733127449
      }
    },
    {
      "chunk_id": "0b264bcf7a9c",
      "chunk_index": 1,
      "content": "PARAMID is an old program whose use is no longer recommended. However it is still retained in the PEST suite as it may be useful to some.\nPARAMID stands for “parameter identifiability analysis”. It performs simple analysis of the contents of an “SVD file” written by PEST, listing the contributions made by adjustable parameters involved in the current inversion process to the eigenvectors spanning the calibration solution space. (The eigenvectors are the columns of the V matrix emerging from\nsingular value decomposition of the weighted Jacobian Q1/2J matrix.)\nUse of PARAMID is based on the following premises.\n1. A PEST run has just been carried out in which singular value decomposition was employed for solution of the inverse problem.\n2. The EIGWRITE variable was set to 1 in the “singular value decomposition” section of the PEST control file, thus ensuring that the full eigenvector matrix was recorded in the SVD file generated by PEST under these circumstances.\n3. The initial Marquardt lambda was set to zero (and NUMLAM set to 1) in the “control data” section of the PEST control file.\n4. At least one iteration was carried out before termination of PEST execution. Thus NOPTMAX was set to 1 or greater in the “control data” section of the PEST control file.\nNote that if model run times are long and a Jacobian matrix file already exists based on a PEST run in which a strategy other than singular value decomposition was used to solve the inverse problem, then there is no need to undertake a full PEST run in order to obtain the SVD file. Simply alter the PEST control file so that the above conditions are met (after using the PARREP utility to place optimised parameter values into this file). Then start PEST using the “/i” switch. PEST will then prompt the user for the name of an existing Jacobian matrix file rather than calculating the Jacobian matrix itself.",
      "header": "8.8.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "654fc3edf762",
      "next_id": "307b4c0c896d",
      "summary_self": "PARAMID (not recommended) analyzes PEST's SVD file (requires PESTMODE=\"estimation\", EIGWRITE=1, RLAMBDA1=0, NUMLAM=1, NOPTMAX≥1), listing parameter contributions to calibration solution space eigenvectors. A full PEST run is unnecessary if a JCO file exists; use the `/i` switch.",
      "summary_prev": "IDENTPAR calculates parameter identifiability from a PEST control file and JCO file. Use `identpar case N vecfilebase matfile identfile [/s or /r]`.  It performs SVD on JtQJ (default) or Q1/2J, outputs eigenvector sensitivity vectors (vecfilebase), V1 matrix (matfile), and identifiability (identfile, sum of eigencomponent squared cosines).  Regularization groups are ignored in \"regularization\" mode.",
      "summary_next": "PARAMID analyzes PEST's SVD file (requires singular value decomposition, EIGWRITE=1, RLAMBDA1=0, NUMLAM=1, NOPTMAX≥1), outputting maximum and minimum parameter contributions to each eigenvector to outfile. Use `paramid case outfile`.  High contributions to low-numbered eigenvectors indicate good estimability.",
      "header_level_1": "8. PEST Statistical Postprocessing",
      "header_level_2": "8.8 PARAMID",
      "header_summary_1": "In \"predictive analysis\" mode, PEST optimizes predictions while maintaining the objective function below a threshold, considering post-calibration uncertainty. It requires accurate derivatives, a prior calibration process, and parameter consistency with the estimation run. Users can adjust Marquardt lambda, search parameters, and incorporate predictive noise for improved analysis.",
      "header_summary_2": "PARAMID analyzes PEST's SVD file with specific settings, listing parameter contributions to calibration solution space eigenvectors. A full PEST run is not needed if a JCO file is present; use the `/i` switch. High contributions to low-numbered eigenvectors suggest good estimability. Use `paramid case outfile` for analysis.",
      "keywords": [
        "EIGWRITE",
        "NOPTMAX",
        "NUMLAM"
      ],
      "similarity": 0.703581167548125,
      "normalized_semantic": 0.703581167548125,
      "normalized_keyword": 0.0528908930718899,
      "combined_score": 0.24809797541476047,
      "reranked_score": 0.24809797541476047,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 1884,
        "semantic_score": 0.703581167548125,
        "keyword_score": 0.0528908930718899,
        "combined_score": 0.24809797541476047,
        "final_score": 0.24809797541476047
      }
    },
    {
      "chunk_id": "2995daaa6e7c",
      "chunk_index": 2,
      "content": "The first lambda that PEST employs in calculating the parameter upgrade vector during any particular iteration is the lambda inherited from the previous iteration, possibly reduced by a factor of RLAMFAC (unless it is the first iteration, in which case RLAMBDA1 is used). Unless, through the use of this lambda, the objective function is reduced to less than PHIRATSUF of its value at the beginning of the iteration, PEST then tries another lambda,\nless by a factor of RLAMFAC than the first. If the objective function is lower than for the first lambda (and still above PHIRATSUF of the starting objective function), PEST reduces lambda yet again; otherwise it increases lambda to a value greater by a factor of RLAMFAC than the first lambda for the iteration. If, in its attempts to find a more effective lambda by lowering and/or raising lambda in this fashion, the objective function begins to rise, PEST accepts the lambda and the corresponding parameter set giving rise to the lowest objective function for that iteration, and moves on to the next iteration. Alternatively if the relative reduction in the objective function between the use of two consecutive lambdas is less than PHIREDLAM, PEST takes this as an indication that it is probably more efficient to begin the next iteration than to continue testing the effect of new Marquardt lambdas. Thus if\n(j-1 - j)/j-1 ≤ PHIREDLAMi i i (4.2.3)\nwhere ij is the objective function value calculated during optimisation iteration i using the j’th trial lambda, PEST moves on to iteration i+1.\nA suitable value for PHIREDLAM is between 0.01 and 0.05. If it is set too large, the criterion for moving on to the next iteration is too easily met and PEST is not given the opportunity of adjusting lambda to its optimal value for that particular stage of the parameter estimation process. On the other hand if PHIREDLAM is set too low, PEST will test too many Marquardt lambdas on each iteration of the inversion process when it would be better off starting a new iteration. (Note that where model runs are parallelised, the testing of too many Marquardt lambdas may not be so much of an issue as it keeps otherwise idle processors busy.)\nNUMLAM\nThis integer variable places an upper limit on the number of lambdas that PEST will test during any one iteration. It should normally be set between 5 and 10 (normally closer to 10); however if RLAMBDA1 is set to zero (which is not recommended) it must be set to 1.\nJACUPDATE\nThe Broyden Jacobian update procedure is described in section 5.4.2 of Doherty (2015). It provides a mechanism for improving the Jacobian matrix based on model outputs calculated during model runs undertaken for the purpose of testing parameter upgrades calculated using different values of the Marquardt lambda.\nIf JACUPDATE is omitted from the fifth line of the “control data” section of the PEST control file, or if it is set to zero, Broyden updating of the Jacobian matrix does not occur. However if it is set to n, where n is a positive integer, Broyden updating will be undertaken during the second part of every PEST iteration following the first n attempts to upgrade parameters using n different values of the Marquardt lambdas. Alternatively, it can be set to 999. In this case the Jacobian matrix is updated after the first parameter upgrade attempt, and every parameter upgrade attempt thereafter.\nExperience indicates that Broyden Jacobian updating can work well on most occasions, but on some occasions does not. At the time of writing it is difficult to predict when it is likely to work well and when the opposite is likely to occur. The “safest” option is not to activate it as it can, under some circumstances, actually hinder the progress of the inversion process. Still, these occasions appear to be relatively rare, and in the majority of cases it is worth a try.\nLAMFORGIVE\nSometimes, when a model is provided with a particular set of parameters, it fails to run to completion. Its output file is not then written. PEST reports this error condition and ceases execution with an appropriate error message. This situation is most likely to arise during those phases of the parameter estimation process where PEST is altering the value of the Marquardt lambda and testing new upgraded parameter values; this is the stage of the inversion process where parameters provided to the model are most different from their predecessors, and hence where model run failure is most likely to occur.\nIn most deployment contexts, a better course of action for PEST to take is to ignore the failed model run and attempt calculation of further parameter upgrades using other values of the Marquardt lambda. This response to model run failure can be instigated using the LAMFORGIVE variable.\nLAMFORGIVE should be placed on the fifth line of the “control data” section of the PEST control file following the JACUPDATE variable if it is present, or the NUMLAM variable if JACUPDATE is absent. (Actually LAMFORGIVE can be placed in front of the JACUPDATE variable if desired.) It must be supplied as “lamforgive” (to activate model run failure forgiveness) or “nolamforgive” (to de-activate model run failure forgiveness). If it is omitted, a default value of “nolamforgive” is used by PEST.",
      "header": "4.2.6 Fifth Line",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "9b975b5255bb",
      "next_id": "9173261c3d0a",
      "summary_self": "PEST iteratively adjusts Marquardt lambda (RLAMBDA1, RLAMFAC) to minimize the objective function.  It stops when the objective function reduction is less than PHIRATSUF or PHIREDLAM (Equation 4.2.3). NUMLAM limits lambda tests per iteration.  JACUPDATE (optional) enables Broyden Jacobian updates. LAMFORGIVE (\"lamforgive\" or \"nolamforgive\") handles model run failures.",
      "summary_prev": "RLAMBDA1 (initial Marquardt lambda, ~10.0) and RLAMFAC (Marquardt lambda adjustment factor, ~2.0 or -3.0) control lambda adjustments during iterations.  PHIRATSUF (objective function reduction ratio, ~0.3) determines iteration completion; if not met, PHIREDLAM is used.",
      "summary_next": "If LAMFORGIVE is \"lamforgive\", PEST switches to central derivatives or stops if no lambda produces a successful model run.  Failed parameter sets are saved in ###error.par files. DERFORGIVE (\"derforgive\" or \"noderforgive\") handles derivative calculation failures; \"derforgive\" sets derivatives to zero and reports missing files.",
      "header_level_1": "4. The PEST Control File",
      "header_level_2": "4.2 Control Data Section",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "Figure 4.2 shows \"control data\" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be \"* control data\";  some variables are optional (in brackets).",
      "keywords": [
        "JACUPDATE",
        "LAMFORGIVE",
        "NUMLAM",
        "PHIRATSUF",
        "PHIREDLAM",
        "RLAMBDA1",
        "RLAMFAC",
        "lambdas"
      ],
      "similarity": 0.737066319147697,
      "normalized_semantic": 0.737066319147697,
      "normalized_keyword": 0.0216077715158463,
      "combined_score": 0.23624533580540155,
      "reranked_score": 0.23624533580540155,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 5268,
        "semantic_score": 0.737066319147697,
        "keyword_score": 0.0216077715158463,
        "combined_score": 0.23624533580540155,
        "final_score": 0.23624533580540155
      }
    }
  ],
  "metrics": {
    "raw_results_count": 10,
    "unique_results_count": 10,
    "variations_count": 0
  }
}