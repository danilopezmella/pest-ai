{
  "subquestion": "How does noptmax work?",
  "variations": [
    "What is the function of noptmax?",
    "Can you explain how noptmax operates?",
    "Could you describe the working mechanism of noptmax?",
    "How is noptmax utilized?",
    "What processes are involved in noptmax’s operation?"
  ],
  "keywords": [
    "noptmax"
  ],
  "top_results": [
    {
      "chunk_id": "1c679819e0a7",
      "chunk_index": 1,
      "content": "LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.\nPEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.\nIf NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.\nFor NOPTMAX not set to zero, the following should be noted.\n• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.\n• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)\n• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.\nUse of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.\nIt is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.\nThe tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.",
      "header": "13.3.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "578d27a8ea30",
      "next_id": "e09851a2d028",
      "summary_self": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.",
      "summary_prev": "PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.",
      "summary_next": "LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS=\"single\", DPOINT=\"point\" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.",
      "header_level_1": "13. Latin Hypercube Sampling",
      "header_level_2": "13.3 LHS2PEST",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.75907053215574,
      "normalized_semantic": 0.75907053215574,
      "normalized_keyword": 0.421325594186783,
      "combined_score": 0.5226490755774701,
      "reranked_score": 0.5226490755774701,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 3500,
        "semantic_score": 0.75907053215574,
        "keyword_score": 0.421325594186783,
        "combined_score": 0.5226490755774701,
        "final_score": 0.5226490755774701
      }
    },
    {
      "chunk_id": "3e78a19f3d34",
      "chunk_index": 1,
      "content": "Like PEST and PESTPP-GLM, PESTPP-IES reads termination criteria from the eighth line of the “control data” section of a PEST control file.\nPESTPP-IES ceases execution after NOPTMAX iterations have elapsed. However, during these NOPTMAX iterations it applies the PHIREDSTP, NPHISTP and NPHINORED termination criteria to the mean objective function calculated using all realizations of the ensemble over successive smoother iterations. If the relative reduction in the mean objective function is less than PHIREDSTP over NPHISTP iterations, or if NPHINORED iterations have elapsed since the last reduction in the mean objective function has occurred, PESTPP-IES ceases execution.\nNote that, as described above, PESTPP-IES also ceases execution if, during any particular iteration of the smoother process, it cannot find in successive NPHINORED iterations, a lambda and scale factor that allows it to calculate parameter upgrades for which the objective function is less than *ies_accept_phi_fac()*. If the results of a particular iteration’s solution process do not meet the acceptable phi criteria (the previous iteration’s mean composite phi time *ies_accept_phi_fac*), then a “partial upgrade” is performed, where only realizations that have yield a phi meeting this criteria are updated. After this partial upgrade, the full ensemble phi statistics are recalculated to determine if the lambda value for the next iteration. If after a partial upgrade, the acceptable phi criteria is still not met, PESTPP-IES will return to upgrade calculations with an increased lambda. In this situation, PESTPP-IES will save “rejected” parameter and observation ensembles in case users want to inspect these quantities.\nSpecial values of NOPTMAX can instigate special PESTPP-IES behaviour. If NOPTMAX is set to -1, PESTPP-IES does not upgrade random parameter sets which comprise an ensemble. It simply runs the model once for each parameter set, records model output values, and then ceases execution, thereby effective undertaking unconstrained Monte Carlo analysis. If NOPTMAX is set to zero, execution of PESTPP-IES is even shorter. It evaluates only the parameter values listed in the control file­ – replicating the behaviour of PESTPP-GLM and PEST. If NOPTMAX is supplied as -2, then PESTPP-IES will calculate the mean value of the initial parameter ensemble, evaluate it (by running the model once) and record the results.\nPESTPP-IES reports several different objective functions, namely “composite”, “measurement”, “regularization”, and “actual”, depending on the mode of operation. The “measurement” objective function is calculated using the current simulated outputs and the observations values in the pest control combined with realizations of additive measurement noise (described elsewhere in this manual). The measurement objective function is calculated using the weights in the pest control file (unless an *obscov* is supplied, described elsewhere, or unless a user-generated observations plus noise ensemble is supplied, described elsewhere). Note that if the *ies_no_noise* option is activated, the “measurement” and “actual” objective functions are the same and only the “actual” is reported to the screen and record file.\nThe “regularization” objective function is calculated as parameter value deviations from the initial (stochastic) realized values–this objective function is scaled by the diagonal of the prior parameter covariance matrix. Note the “regularization” objective function is only used and reported if the value of *ies_reg_factor* is supplied with a value greater than 0.0.\nThe “composite” objective function is simply the combination of the measurement and regularization objective functions. Note the regularization objective function is reported in the phi summary but the contribution to the composite objective function is controlled by *ies_reg_factor,* which is 0.0 by default. Note the composite objective function is used to select lambda-scale factor pairs and to control termination criteria. Similar to the “regularization” objective function, the “composite” objective function is only used and reported if *ies_reg_factor* is greater than 0.0.\nThe “actual” objective function is calculated using the current simulated outputs and the observation values in the control file (that is, without measurement noise realizations). Through the *ies_no_noise* option, users can make the “measurement” and “actual” objective functions one in the same. This is an important consideration when subjective weighting is used to balance the contribution of several types of observations to the objective function–a process that can result in very small weights, which implies very large measurement noise.",
      "header": "9.2.9 Termination Criteria, Objective Functions, and Upgrade Acceptance ",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "15858d119534",
      "next_id": "2fbe597b07b9",
      "summary_self": "PESTPP-IES uses termination criteria (NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP, NRELPAR) applied to the mean objective function across realizations.  NOPTMAX=0/-1/-2 triggers special behavior.  It reports \"composite,\" \"measurement,\" \"regularization,\" and \"actual\" objective functions (*ies_reg_factor*>0 for regularization and composite terms).  The  *ies_accept_phi_fac* criterion and partial upgrades handle unsuccessful iterations.  A final model run is performed unless stopped via PSTOPST (in parallel mode).",
      "summary_prev": "PESTPP-IES generates multiple output files (detailed in the next section), controlled by *ies_verbose_level* (default 1).  It saves parameter and observation ensembles in CSV or JCB files (iteration-specific) and, optionally (*save_lambda_ensembles*=true), lambda-testing parameter sets.  These files are used to diagnose numerical instability issues.",
      "summary_next": "PESTPP-IES balances objective function contributions from observation groups internally (*ies_phi_factor_file*,  two-column file: tag, phi factor) at runtime.  Tags identify groups; phi factors set group contributions (maintaining the mean measurement phi).  *ies_phi_factors_by_real*=true enables per-realization weighting (using a table of realization and tag-based phi factors).  pyEMU and PEST utilities offer more granular control.",
      "header_level_1": "9. PESTPP-IES",
      "header_level_2": "9.2 Using PESTPP-IES",
      "header_summary_1": "Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.",
      "header_summary_2": "To use PEST's \"regularisation\" mode, set PESTMODE to \"regularisation\" in the control data section. This mode categorizes observations into \"regul\" groups and others. Regularization weights are adjusted by the regularization weight factor. Key variables in the \"regularisation\" section include PHIMLIM, PHIMACCEPT, WFINIT, and others. PEST aims to minimize the regularization objective function while iterating until PHIMLIM is reached. Adjusting PHIMACCEPT, FRACPHIM, and other parameters influences optimization.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "PHIREDSTP",
        "ies_accept_phi_fac",
        "ies_no_noise",
        "ies_reg_factor"
      ],
      "similarity": 0.745495527445758,
      "normalized_semantic": 0.745495527445758,
      "normalized_keyword": 0.267425388097763,
      "combined_score": 0.4108464299021615,
      "reranked_score": 0.4108464299021615,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 4731,
        "semantic_score": 0.745495527445758,
        "keyword_score": 0.267425388097763,
        "combined_score": 0.4108464299021615,
        "final_score": 0.4108464299021615
      }
    },
    {
      "chunk_id": "ff1b7fa73d29",
      "chunk_index": 1,
      "content": "Use of PESTLIN assumes that a complete PEST input dataset exists for parameter estimation (regularised or otherwise), or predictive uncertainty analysis. It also assumes that a Jacobian matrix file exists for this dataset, together with a run record file in which parameter values pertinent to this Jacobian matrix are recorded. On the basis of this Jacobian matrix PESTLIN writes a GENLIN (see above) input dataset, encapsulating a linearised form of the model. It also writes a new PEST control file so that (regularised) inversion or predictive uncertainty analysis can be undertaken on the basis of the linearised model. Because this linearised model will generally run much faster than the real model, concepts can be tested and/or approximate solutions to these types of problems can be obtained, very quickly indeed.\nIn most cases the easiest way to build a linearised equivalent of a PEST input dataset (including a linearised equivalent of the model) is as follows.\n1. As stated above, build an entire PEST input dataset based on the real model. Ensure that this dataset is correct and consistent using the PESTCHEK utility.\n2. Set NOPTMAX to ‑1 in the pertinent PEST control file.\n3. Run PEST. PEST will undertake enough model runs to calculate the Jacobian matrix. Then it will cease execution, recording initial parameter values, together with uncertainty statistics (if these are calculable), on its run record file.\n4. Run PESTLIN.\nAlternatively, PESTLIN can be run at the end of an entire parameter estimation process. In this case the Jacobian matrix file will contain sensitivities with respect to optimised parameter values (or, if a minor improvement in parameter estimates occurred on the last iteration, with respect to near‑optimised parameter values). Meanwhile the run record file will record optimised parameter values, together with model‑generated counterparts to measurements comprising the calibration dataset calculated on the basis of these optimised parameter values (unless PEST is run using SVD‑assist, in which case the PARREP utility should be employed to construct such a run record file by first constructing a new PEST control file on the basis of optimised parameters and then running PEST in the manner described above).",
      "header": "14.5.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "9993028820b6",
      "next_id": "fe9c86ccbde4",
      "summary_self": "PESTLIN creates a linearized model from an existing PEST dataset (control and JCO files, requiring a PEST run with NOPTMAX=-1). It generates a GENLIN input file and a new PEST control file for faster linearized inversion or predictive uncertainty analysis.  Alternatively, it can be run after parameter estimation to use optimized parameter sensitivities.",
      "summary_prev": "GENLIN optionally creates a derivatives file (for use with PEST, Chapter 12, Part I) containing derivatives with respect to native (not log-transformed) parameters. This file can replace finite-difference derivatives, reducing PEST's computational burden.  Log-transformed parameters require additional calculations.",
      "summary_next": "PESTLIN linearizes a PEST dataset (pestincase.pst, .jco, .rec), creating a GENLIN dataset (linbasename.in, .out, .ins, .tpl) and a new PEST control file (pestoutcase.pst).  The `/d` switch enables external derivatives.  It handles tied parameters. Use `pestlin pestincase pestoutcase linbasename [/d]`.",
      "header_level_1": "14. Miscellaneous Utilities",
      "header_level_2": "14.5 PESTLIN",
      "header_summary_1": "Observation re-referencing simplifies derivative calculations by adjusting initial model conditions based on upgraded parameters, improving solver convergence time. It involves creating reference model outputs for accurate derivatives, with specific commands and activation steps. SVDAPREP and BEOPEST support this feature, enhancing model accuracy and efficiency.",
      "header_summary_2": "SVDAPREP supports observation re-referencing (mode 1 only) by creating r_svdabatch.bat and d_svdabatch.bat from existing \"r_\" and \"d_\" prefixed files (adding PARCALC and PICALC commands). The new control file activates observation re-referencing and is ready for use.  Mode 2 is not supported with SVD-assisted parameter estimation.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.774541749087469,
      "normalized_semantic": 0.774541749087469,
      "normalized_keyword": 0.232209324836731,
      "combined_score": 0.39490905211195243,
      "reranked_score": 0.39490905211195243,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 2261,
        "semantic_score": 0.774541749087469,
        "keyword_score": 0.232209324836731,
        "combined_score": 0.39490905211195243,
        "final_score": 0.39490905211195243
      }
    },
    {
      "chunk_id": "7882ba27349c",
      "chunk_index": 1,
      "content": "SENSAN allows you to undertake many model runs without user intervention. The sensitivity of certain model outputs to certain parameters can be tested. However SENSAN does not compute an objective function because it does not read an observation dataset, and hence cannot compare model outputs with corresponding observations to calculate residuals.\nHowever once all PEST input files have been prepared for a particular case, SENSAN can be used in conjunction with PEST to study the dependence of the objective function (or any components thereof) on certain parameters. Where there are only two parameters, this can be used to contour the objective function in parameter value space.\nA SENSAN control file implementing this is shown in figure 17.6.\nscf\n* control data\nverbose\n6 1\n1 1 single point\n* sensan files\nparvar.dat\nout1.txt\nout2.txt\nout3.txt\n* model command line\npest ves4\n* model input/output\npst.tpl ves4.pst\nrec.ins ves4.rec\nFigure 17.6 A SENSAN control file with PEST as the model.\nNote the following points.\n- In the PEST control file the value of NOPTMAX should be set to zero. Hence PEST runs the model only once before it terminates execution.\n- There is only one template file and one instruction file.\n- The template file is built from the PEST control file. Parameters adjusted by SENSAN are initial parameter values as listed on the PEST control file.\n- SENSAN’s observation file is the run record file for the PEST case.\n- As in normal SENSAN operation, supply parameter values to be used by SENSAN through a parameter variation file.\nThe instruction set by which the PEST control file may be read is shown below (the observation name is “phi”).\npif $\n$(ie phi)$ $=$ !phi!\nThis instruction set simply instructs SENSAN to read the PEST run record file until it encounters the string “(ie phi)” followed by “=”, and then to read the observation named “phi” as a non-fixed observation following that. More complex instruction sets are required where multiple objective function components must be read.",
      "header": "17.5 Sensitivity of the Objective Function",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "5ab5473f2398",
      "next_id": "81126e43e397",
      "summary_self": "SENSAN, combined with PEST (NOPTMAX=0), analyzes objective function dependence on parameters.  A SENSAN control file (Figure 17.6) uses a PEST control file as a template, and the PEST run record file as the observation file.  A parameter variation file provides parameter values;  an instruction file extracts the objective function.",
      "summary_prev": "SENSAN uses TEMPCHEK and INSCHEK (Part II).  SENSAN creates a parameter value file (t###.par), so avoid using this filename. INSCHEK saves read observation values to instruct.obf; avoid filename conflicts by using unique names for instruction files.",
      "summary_next": "SENSCHEK (Part II) thoroughly checks SENSAN input data.  SENSAN reports parameter variation file errors to the screen and continues;  it handles model and INSCHEK errors similarly, reporting to the screen and continuing.  Check for matching parameter names in template and parameter variation files;  use \"verbose\" mode for initial runs to detect errors, then switch to \"noverbose\".",
      "header_level_1": "17. SENSAN (continuación)",
      "header_level_2": "",
      "header_summary_1": "SENSAN uses control, parameter variation, and PEST template and instruction files. It runs system commands post-model runs, with options for OS commands or executables. PEST templates generate model inputs, instructions read outputs. Run with `sensan infile`, using tempchek.exe and inschek.exe. Outputs include ABSFLE, RELFLE, SENSFLE. SENSCHEK checks input data.",
      "header_summary_2": "",
      "keywords": [
        "* control data",
        "* model command line",
        "* model input/output",
        "NOPTMAX"
      ],
      "similarity": 0.743044999734759,
      "normalized_semantic": 0.743044999734759,
      "normalized_keyword": 0.220296368002892,
      "combined_score": 0.3771209575224521,
      "reranked_score": 0.3771209575224521,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 2021,
        "semantic_score": 0.743044999734759,
        "keyword_score": 0.220296368002892,
        "combined_score": 0.3771209575224521,
        "final_score": 0.3771209575224521
      }
    },
    {
      "chunk_id": "1fd4a5136d77",
      "chunk_index": 1,
      "content": "CALMAINTAIN prompts the user for its input data as this is more convenient than supplying these data on the command line. Its first prompt is\nEnter name of PEST control file:\nCALMAINTAIN opens the PEST control file. At the same time it ensures that a corresponding JCO file exists. (The contents of this file become the Z matrix of the above equations). Next it asks\nEnter name of parameter adjustment file:\nAn example of a parameter adjustment file follows.\nExample of a parameter adjustment file\nk_ppt30           0.8\nk_ppt31           2.6\nk_ppt32           0.8\nk_ppt33           1.0\nk_ppt34           0.8\nk_ppt35           0.8\nk_ppt36           0.5\nk_ppt37           1.8\nFigure 14.2 Example of a parameter adjustment file.\nEach line of a parameter adjustment file must have two entries. The first entry is the name of a parameter. The second entry is the new value of that parameter. Blank lines are ignored. Comment lines (which begin with the “#” character) are also ignored.\nCALMAINTAIN will object if you attempt to adjust the value of a fixed or tied parameter. However, it is acceptable to adjust the value of a parent parameter to which other parameters are tied; the child parameters are automatically adjusted if this is the case.\nCALMAINTAIN next asks for the name of the parameter value file that it must write. The prompt is:\nEnter name for output parameter value file:\nIt then asks the following three questions:\n- Use SVD or LSQR to solve equation? [l/s]:\n- Truncate at how many singular values:\n- Adopt what fraction of upgrade vector:\nAs is apparent from the first of the above questions, you have the choice of using either LSQR or singular value decomposition to solve equation 14.3.3. LSQR is faster than singular value decomposition where parameter numbers are high, but can sometimes be less precise.\nThe second of the above prompts allows you to limit the propensity for numerical noise to contaminate the solution of equation 14.3.3. The best response to this question varies with context. Based on limited experience at the time of writing, it is suggested that a value equal to the number of adjusted parameters featured in the parameter adjustment file may work well. “Damping” of parameter compensation can also be used to limit contamination of the solution to equation 14.3.3 by numerical noise; therefore a value of between 0.0 and 1.0 is a suitable answer to the third of the above questions (normally closer to 1.0 than 0.0). Some trial and error may be necessary to find the best response to the second and third of the above questions in any particular modelling context.\nOnce all of the above questions have been answered, CALMAINTAIN performs the calculations indicated above, and then writes the requested parameter value file. The values assigned to parameters in this file are the user‑adjusted values (for those parameters which are cited in the parameter adjustment file), together with values for other parameters which are altered in such a way as to maintain the model in as much of a calibrated state as possible.\nIf desired, the PARREP utility can be used to insert parameter values recorded in this file into a PEST control file. If NOPTMAX is set to zero in this file, PEST can be used to run the model and calculate an objective function. In this way adherence to calibration constraints can be tested.",
      "header": "14.3.3 Using CALMAINTAIN",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "91cc4af72d4e",
      "next_id": "bea21df90035",
      "summary_self": "CALMAINTAIN adjusts parameters to maintain calibration after changes (specified in a parameter adjustment file, Figure 14.2) to other parameters. It prompts for a PEST control file (with JCO file), parameter adjustment file, output parameter value file, solution method (\"l\" or \"s\"), number of singular values, and upgrade vector fraction (0.0-1.0).  It uses linear theory (Equation 14.3.3).  Use PARREP and set NOPTMAX=0 to test calibration.",
      "summary_prev": "CALMAINTAIN compensates for changes (δk₂) in a subset of parameters (k₂) by adjusting another subset (k₁), aiming to maintain calibration (Equation 14.3.3: Z₁δk₁=-Z₂δk₂). It solves exactly if possible; otherwise, it minimizes the right side of Equation 14.3.4.  It uses Equation 14.3.5 (Q<sup>1/2</sup>h=Q<sup>1/2</sup>Zk+Q<sup>1/2</sup>ε) instead of Equation 14.3.1.",
      "summary_next": "GENLIN, a linear model calculator, uses Equation 14.4.1 (h=h₀+M(k-k₀)) or 14.4.2 (h=h₀+M(log₁₀(k)-log₁₀(k₀)) for log-transformed parameters) to compute outputs (h) from inputs (k). M is a sensitivity/Jacobian matrix. It can be used independently or with PESTLIN.",
      "header_level_1": "14. Miscellaneous Utilities",
      "header_level_2": "14.3 CALMAINTAIN",
      "header_summary_1": "Observation re-referencing simplifies derivative calculations by adjusting initial model conditions based on upgraded parameters, improving solver convergence time. It involves creating reference model outputs for accurate derivatives, with specific commands and activation steps. SVDAPREP and BEOPEST support this feature, enhancing model accuracy and efficiency.",
      "header_summary_2": "Observation re-referencing with NUMCOM=1, DERCOM=1 involves three commands: main model command for objective function calculations and parameter upgrades, \"d_\" command for derivatives, and \"r_\" command for reference model outputs. For NUMCOM > 1, additional \"r_\" commands are needed before derivative calculations, except for the first command (index 1). Users create these \"r_\" commands.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.759939267638967,
      "normalized_semantic": 0.759939267638967,
      "normalized_keyword": 0.201133787631989,
      "combined_score": 0.36877543163408244,
      "reranked_score": 0.36877543163408244,
      "debug_factors": {
        "length_factor": 1.0,
        "content_length": 3354,
        "semantic_score": 0.759939267638967,
        "keyword_score": 0.201133787631989,
        "combined_score": 0.36877543163408244,
        "final_score": 0.36877543163408244
      }
    }
  ],
  "metrics": {
    "raw_results_count": 10,
    "unique_results_count": 10,
    "variations_count": 5
  }
}