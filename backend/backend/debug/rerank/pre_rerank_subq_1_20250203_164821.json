{
  "subquestion": "What is noptmax?",
  "variations": [
    "What does noptmax mean?",
    "Can you explain what noptmax is?",
    "What is the definition of noptmax?",
    "Could you clarify what noptmax refers to?",
    "Please describe what noptmax is."
  ],
  "keywords": [
    "noptmax"
  ],
  "raw_results": [
    {
      "chunk_id": "1c679819e0a7",
      "chunk_index": 1,
      "content": "LHS2PEST provides a linkage between PEST and the LHS program written by Sandia National Laboratories. It facilitates the undertaking of multiple PEST runs, each based on a different set of Latin hypercube parameter value samples generated by LHS.\nPEST runs can be undertaken for a number of purposes. If the NOPTMAX control variable is set to 0, then PEST will simply run the model once, calculate the objective function and different components thereof, calculate and record some statistics, and then cease execution.\nIf NOPTMAX is set to ‑1 or ‑2, PEST will calculate the Jacobian matrix, this comprising sensitivities of members of the observation dataset to the different parameters. If NOPTMAX is set to a positive number, then PEST will undertake parameter estimation; for each parameter estimation run, initial parameter values can thus be Latin hypercube samples of the various parameters.\nFor NOPTMAX not set to zero, the following should be noted.\n• If a model is linear with respect to its parameters, sensitivities recorded in the Jacobian matrix are independent of parameter values.\n• If undertaking repeated parameter estimation based on different LHS‑generated initial parameter values, and this process does not employ the SVD‑assist methodology (do not confuse this with singular value decomposition as a solution device for the inverse problem), consider running PEST with the “/i” switch so that it can re‑use the same Jacobian matrix on its first iteration for each of these parameter estimation exercises. Presumably this matrix will have been calculated using a representative set of parameter values ‑ ideally prior expected parameter values. (Note that in the batch file written by LHS2PEST ‑ see below ‑ the command to run PEST is not accompanied by this switch; you must add it to the pertinent command yourself.)\n• Through use of the ADDREG1 utility, Tikhonov constraints can be implemented which promulgate maximum adherence of adjusted parameter values to initial parameter values; maximum respect for LHS samples as parameters are adjusted to satisfy calibration constraints is thereby maintained.\nUse of LHS2PEST is predicated on the assumption that a PEST input dataset and corresponding LHS input dataset exist. It is also assumed that the same parameters have the same names in both of these datasets. (As will be discussed, either of the files comprising these dataset can possess other parameters as well.) Adherence to this protocol will require that parameter name lengths be restricted to 12 characters or less in the LHS input dataset, as this is the character length limit for a parameter name employed by PEST.\nIt is further assumed that LHS has been run, and that an LHS output file with parameter sample values has thus been recorded. LHS2PEST reads these samples, and builds a set of PEST parameter values files, each recording the values associated with one sample set. (Parameter value files are described in section 2.2 of this manual.) These files can be used in similar ways to those written by the RANDPAR utility. In particular, through sequential use of the PARREP utility, parameter sets contained in these files can be used as initial values in a sequence of PEST control files. PEST can then use these control files to undertake sequential runs for any of the reasons discussed above.\nThe tasks performed by LHS2PEST depend on the command that is used to run it. The commands, and the tasks that correspond to these commands, are now described.",
      "header": "13.3.1 General",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "578d27a8ea30",
      "next_id": "e09851a2d028",
      "summary_self": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples.  PEST runs can calculate objective functions (NOPTMAX=0), Jacobian matrices (NOPTMAX=-1 or -2), or perform parameter estimation (NOPTMAX>0, using LHS samples as initial values). The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints.  LHS and PEST datasets must have matching parameter names (≤12 characters). LHS2PEST creates PEST parameter value files from the LHS output file.",
      "summary_prev": "PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.",
      "summary_next": "LHS2PEST creates PEST parameter value files (parfilebaseN.par) from LHS output (lhsoutfile). Parameter names must be ≤12 characters; otherwise, execution stops.  SCALE=1, OFFSET=0, PRECIS=\"single\", DPOINT=\"point\" are used. The number of files equals the number of LHS sample sets.  Use `lhs2pest lhsoutfile parfilebase`.",
      "header_level_1": "13. Latin Hypercube Sampling",
      "header_level_2": "13.3 LHS2PEST",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "LHS2PEST facilitates multiple PEST runs using LHS-generated parameter samples. It can calculate objective functions, Jacobian matrices, or perform parameter estimation. The `/i` switch reuses Jacobian matrices for efficiency. ADDREG1 adds Tikhonov constraints. Parameter names must be ≤12 characters. It creates PEST parameter value files from LHS output.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.740065069190857,
      "normalized_semantic": 0.740065069190857,
      "normalized_keyword": 2,
      "combined_score": 1.622019520757257
    },
    {
      "chunk_id": "d131ce523618",
      "chunk_index": 1,
      "content": "Program PARREP replaces initial parameter values provided in a PEST control file by another set of values, the latter being supplied in a PEST parameter value file. See section 2.2 of this manual for specifications of a parameter value file.\nRecall from Section 5.3.2 of part I of this manual that in the course of the inversion process PEST writes a parameter value file every time it improves its parameter estimates. After a PEST run has finished (either of its own accord or manually halted), optimised parameter values can be found in the parameter value file. The parameter value file possesses the same filename base as the PEST control file but has an extension of “.par”. Because it has such a simple structure, a parameter value file can also be easily built by the user with the help of a text editor.\nPARREP is useful when commencing a new PEST run where an old run finished. An updated PEST control file can be produced by replacing parameter values in the old file with the best parameter values determined during the previous PEST run as recorded in the parameter value file written during that run. Recommencing a PEST run in this way, rather than through use of the “/r”, “/j”, “/s” or “/d” switches, allows you to alter certain PEST control variables, fix or tie certain parameters, or adjust PEST’s management of the parameter estimation process in other ways, prior to commencement of the new run.\nPARREP is also useful when undertaking a single model run on the basis of a certain set of parameters in order to calculate the objective function. Simply create a new PEST control file using PARREP as described above, and set NOPTMAX to zero in that file.\nPARREP is run using the command\nparrep parfile pestfile1 pestfile2 [new_noptmax]\nwhere\n|parfile|is the name of a parameter value file,|\n|---|---|\n|pestfile1|is the name of an existing PEST control file,|\n|pestfile2|is the name for the new PEST control file, and|\n|new_noptmax|optionally provides a new value for NOPTMAX.|\nWhen PARREP replaces parameter values in the existing PEST control file by those read from the parameter value file, it does not check that each parameter value lies between its upper and lower bounds, that log‑transformed parameters are positive, etc. Hence, especially if using a manually‑created parameter value file, it is a good idea to run PESTCHEK before running PEST to ensure that all is consistent and correct.\nA special aspect of PARREP’s behaviour is worthy of note. If a parameter is tied or fixed in the existing PEST control file which PARREP reads, PARREP will not object if that parameter is omitted from the parameter value file that is provided to PARREP. The value of a fixed parameter is simply transferred from the existing PEST control file to the new PEST control file. The value of a tied parameter omitted from the parameter value file is calculated from the new value assigned to its parent parameter on the assumption that the ratio between the two remains the same in new PEST control file as it was in the old PEST control file.",
      "header": "4.4 PARREP",
      "level": 2,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "51cac29a6097",
      "next_id": "05375a187143",
      "summary_self": "PARREP replaces initial parameter values in a PEST control file (pestfile1) with those from a parameter value file (parfile, section 2.2), creating a new control file (pestfile2).  Optional new_noptmax sets NOPTMAX.  It doesn't check bounds; use PESTCHEK afterwards. Tied/fixed parameters omitted from parfile retain their original values/ratios. Use `parrep parfile pestfile1 pestfile2 [new_noptmax]`.",
      "summary_prev": "Run TPL2PST using `tpl2pst infile pestfile`; infile is the input file, and pestfile is the name of the output partial PEST control file (recommended extension: .pst).",
      "summary_next": "OBSREP replaces observed values in a PEST control file (pestfile1) with model outputs from a PEST residuals file (resfile, .res or .rei), creating a new control file (pestfile2).  All observations/prior information in pestfile1 must be in resfile; otherwise, OBSREP halts with an error. Use `obsrep resfile pestfile1 pestfile2`.",
      "header_level_1": "4. Building and Altering a PEST Control File",
      "header_level_2": "",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.724614815436922,
      "normalized_semantic": 0.724614815436922,
      "normalized_keyword": 2,
      "combined_score": 1.6173844446310766
    },
    {
      "chunk_id": "3e78a19f3d34",
      "chunk_index": 1,
      "content": "Like PEST and PESTPP-GLM, PESTPP-IES reads termination criteria from the eighth line of the “control data” section of a PEST control file.\nPESTPP-IES ceases execution after NOPTMAX iterations have elapsed. However, during these NOPTMAX iterations it applies the PHIREDSTP, NPHISTP and NPHINORED termination criteria to the mean objective function calculated using all realizations of the ensemble over successive smoother iterations. If the relative reduction in the mean objective function is less than PHIREDSTP over NPHISTP iterations, or if NPHINORED iterations have elapsed since the last reduction in the mean objective function has occurred, PESTPP-IES ceases execution.\nNote that, as described above, PESTPP-IES also ceases execution if, during any particular iteration of the smoother process, it cannot find in successive NPHINORED iterations, a lambda and scale factor that allows it to calculate parameter upgrades for which the objective function is less than *ies_accept_phi_fac()*. If the results of a particular iteration’s solution process do not meet the acceptable phi criteria (the previous iteration’s mean composite phi time *ies_accept_phi_fac*), then a “partial upgrade” is performed, where only realizations that have yield a phi meeting this criteria are updated. After this partial upgrade, the full ensemble phi statistics are recalculated to determine if the lambda value for the next iteration. If after a partial upgrade, the acceptable phi criteria is still not met, PESTPP-IES will return to upgrade calculations with an increased lambda. In this situation, PESTPP-IES will save “rejected” parameter and observation ensembles in case users want to inspect these quantities.\nSpecial values of NOPTMAX can instigate special PESTPP-IES behaviour. If NOPTMAX is set to -1, PESTPP-IES does not upgrade random parameter sets which comprise an ensemble. It simply runs the model once for each parameter set, records model output values, and then ceases execution, thereby effective undertaking unconstrained Monte Carlo analysis. If NOPTMAX is set to zero, execution of PESTPP-IES is even shorter. It evaluates only the parameter values listed in the control file­ – replicating the behaviour of PESTPP-GLM and PEST. If NOPTMAX is supplied as -2, then PESTPP-IES will calculate the mean value of the initial parameter ensemble, evaluate it (by running the model once) and record the results.\nPESTPP-IES reports several different objective functions, namely “composite”, “measurement”, “regularization”, and “actual”, depending on the mode of operation. The “measurement” objective function is calculated using the current simulated outputs and the observations values in the pest control combined with realizations of additive measurement noise (described elsewhere in this manual). The measurement objective function is calculated using the weights in the pest control file (unless an *obscov* is supplied, described elsewhere, or unless a user-generated observations plus noise ensemble is supplied, described elsewhere). Note that if the *ies_no_noise* option is activated, the “measurement” and “actual” objective functions are the same and only the “actual” is reported to the screen and record file.\nThe “regularization” objective function is calculated as parameter value deviations from the initial (stochastic) realized values–this objective function is scaled by the diagonal of the prior parameter covariance matrix. Note the “regularization” objective function is only used and reported if the value of *ies_reg_factor* is supplied with a value greater than 0.0.\nThe “composite” objective function is simply the combination of the measurement and regularization objective functions. Note the regularization objective function is reported in the phi summary but the contribution to the composite objective function is controlled by *ies_reg_factor,* which is 0.0 by default. Note the composite objective function is used to select lambda-scale factor pairs and to control termination criteria. Similar to the “regularization” objective function, the “composite” objective function is only used and reported if *ies_reg_factor* is greater than 0.0.\nThe “actual” objective function is calculated using the current simulated outputs and the observation values in the control file (that is, without measurement noise realizations). Through the *ies_no_noise* option, users can make the “measurement” and “actual” objective functions one in the same. This is an important consideration when subjective weighting is used to balance the contribution of several types of observations to the objective function–a process that can result in very small weights, which implies very large measurement noise.",
      "header": "9.2.9 Termination Criteria, Objective Functions, and Upgrade Acceptance ",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "15858d119534",
      "next_id": "2fbe597b07b9",
      "summary_self": "PESTPP-IES uses termination criteria (NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP, NRELPAR) applied to the mean objective function across realizations.  NOPTMAX=0/-1/-2 triggers special behavior.  It reports \"composite,\" \"measurement,\" \"regularization,\" and \"actual\" objective functions (*ies_reg_factor*>0 for regularization and composite terms).  The  *ies_accept_phi_fac* criterion and partial upgrades handle unsuccessful iterations.  A final model run is performed unless stopped via PSTOPST (in parallel mode).",
      "summary_prev": "PESTPP-IES generates multiple output files (detailed in the next section), controlled by *ies_verbose_level* (default 1).  It saves parameter and observation ensembles in CSV or JCB files (iteration-specific) and, optionally (*save_lambda_ensembles*=true), lambda-testing parameter sets.  These files are used to diagnose numerical instability issues.",
      "summary_next": "PESTPP-IES balances objective function contributions from observation groups internally (*ies_phi_factor_file*,  two-column file: tag, phi factor) at runtime.  Tags identify groups; phi factors set group contributions (maintaining the mean measurement phi).  *ies_phi_factors_by_real*=true enables per-realization weighting (using a table of realization and tag-based phi factors).  pyEMU and PEST utilities offer more granular control.",
      "header_level_1": "9. PESTPP-IES",
      "header_level_2": "9.2 Using PESTPP-IES",
      "header_summary_1": "Tikhonov regularization in PEST enhances stability by reducing error variance and incorporating expert knowledge. Use IREGADJ, SVD, or LSQR with MAXSING and EIGTHRESH settings for stability. PEST stops after NOPTMAX iterations, reaching target objectives, minimal parameter changes, or slow improvement. Regularization mode categorizes observations into \"regul\" groups, adjusting weights with a regularization weight factor.",
      "header_summary_2": "To use PEST's \"regularisation\" mode, set PESTMODE to \"regularisation\" in the control data section. This mode categorizes observations into \"regul\" groups and others. Regularization weights are adjusted by the regularization weight factor. Key variables in the \"regularisation\" section include PHIMLIM, PHIMACCEPT, WFINIT, and others. PEST aims to minimize the regularization objective function while iterating until PHIMLIM is reached. Adjusting PHIMACCEPT, FRACPHIM, and other parameters influences optimization.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "PHIREDSTP",
        "ies_accept_phi_fac",
        "ies_no_noise",
        "ies_reg_factor"
      ],
      "similarity": 0.715564003783942,
      "normalized_semantic": 0.715564003783942,
      "normalized_keyword": 1.80000007152557,
      "combined_score": 1.4746692512030817
    },
    {
      "chunk_id": "cbb14971764f",
      "chunk_index": 1,
      "content": "The eighth line of the “control data” section of a PEST control file holds variables which control termination of an inversion process. These are NOPTMAX, PHIREDSTP, NPHISTP, NPHINORED, RELPARSTP and NRELPAR. Suitable (PESTCHEK-friendly) values for these variables are provided in figure 4.2, namely 50, 0.005, 4, 4, 0.005 and 4. PESTPP-GLM uses all of these variables; PESTPP-IES uses all except RELPARSTP and NRELPAR. Other programs of the PEST++ suite use only NOPTMAX.\nNOPTMAX, an integer variable, sets the maximum number of iterations that an inversion or optimization process is allowed to run. However, values of 0, -1 and -2 trigger behaviour that is dependent on the PEST++ program that reads the PEST control file.\nIf NOPTMAX is set to 0, PESTPP-GLM does not estimate parameters. Instead it completes one model run using parameter values supplied in the “parameter data” section of the PEST control file. It computes objective function components based on the result of this single model run. This can be used to ensure that PESTPP-GLM setup is correct, and that weights assigned to observations in the “observation data” section of the PEST control file are suitable.\nIf NOPTMAX is set to -1 or -2, PESTPP-GLM calculates a Jacobian matrix and stores it in a Jacobian matrix file (i.e., a JCO file). If asked to do so, it also calculates linear statistics based on that Jacobian matrix. It then ceases execution. The same Jacobian matrix is available for more complex linear analysis using pertinent PEST utilities, as well as PyEMU. The Jacobian matrix that is stored in the JCO file can also be put to other uses; see section 3.4.\nPHIREDSTP is a real variable whereas NPHISTP is an integer variable. If, in the course of a PESTPP-GLM inversion process, there have been NPHISTP optimization iterations for which (Φ*i* - Φ*min* )/Φ*i* ≤ PHIREDSTP (Φ*i* being the objective function value at the end of the *i*th optimization iteration and Φmin being the lowest objective function achieved to date), PESTPP-GLM considers that the inversion process is at an end. Alternatively, if PESTPP-GLM has failed to lower the objective function over NPHINORED successive iterations, it ceases execution. PESTPP-IES supplies these same termination criteria to ensemble-mean objective functions.\nIf the magnitude of the maximum relative parameter change is less than RELPARSTP over NRELPAR successive iterations, then PESTPP-GLM ceases execution. The relative parameter change between iterations for any parameter is calculated using equation 3.2. PESTPP-GLM evaluates this change for all adjustable parameters at the end of all iterations, and determines the relative parameter change with the highest magnitude. If this maximum relative change is less than RELPARSTP, a counter is advanced by one; if it is greater than RELPARSTP, the counter is zeroed.",
      "header": "4.6.9 Eighth Line",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "e113dd2e0863",
      "next_id": "e93b50160cd8",
      "summary_self": "NOPTMAX (integer, 50 recommended) sets maximum iterations; 0 runs one model; -1 or -2 generates a JCO file.  PESTPP-GLM uses PHIREDSTP (real, 0.005), NPHISTP (integer, 4), NPHINORED (integer, 4), RELPARSTP (real, 0.005), and NRELPAR (integer, 4) for termination; PESTPP-IES uses all except RELPARSTP and NRELPAR. Other PEST++ programs use only NOPTMAX.",
      "summary_prev": "PHIREDSWH (real, often 0.1) in the \"control data\" section controls switching from forward to central differences in PESTPP-GLM (FORCEN=\"switch\") if the relative objective function reduction between iterations is ≤ PHIREDSWH.  It's ignored if differential evolution is used.  Equation 4.1 shows the condition for switching.",
      "summary_next": "ICOV, ICOR, and IEIG (integers) in the \"control data\" section are not used by PESTPP-GLM. Set them to 0 for PESTCHEK compatibility.",
      "header_level_1": "4. The PEST Control File",
      "header_level_2": "4.6 Control Data Section",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "The optional \"automatic user intervention\" section (section 6.3) governs automatic user intervention, activated by setting DOAUI to \"doaui\" in the \"control data\" section.  If omitted, default values are used.",
      "keywords": [
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "NRELPAR",
        "PHIREDSTP",
        "RELPARSTP"
      ],
      "similarity": 0.761933383480696,
      "normalized_semantic": 0.761933383480696,
      "normalized_keyword": 1.70000004768372,
      "combined_score": 1.4185800484228128
    },
    {
      "chunk_id": "734edcaf1ca7",
      "chunk_index": 1,
      "content": "PESTPP-DA is run exactly like all other tools in the PEST++ suite – See section 5 of this manual for how to run the tools in the PEST++ suite. As is described in that section, model runs can be undertaken in series or in parallel. In either case, a prematurely terminated PESTPP-DA run can be restarted by supplying the requisite global parameter and observation ensemble files (described below).\nTo restart at a given cycle number, users can supply the optional *da_hotstart_cycle* argument along with the requisite parameter, observation and noise ensemble files. To ensure a proper restart (especially if realizations have failed during evaluation), users should supply the corresponding files written by PESTPP-DA.\nThe version 2 pest control file format is required to specify cycle numbers. If no cycle numbers are found, then PESTPP-DA proceeds with a batch assimilation (e.g., smoother) assuming all parameters and observations are in cycle 0.\nAs previously discussed, if NOPTMAX is set to zero, PESTPP-DA will run the model once for each cycle using the values listed in the parameter data section of the control file, updating dynamic states and recording simulated outputs along the way. Furthermore, if NOPTMAX is set to -1, PESTPP-DA will evaluate the prior parameter ensemble for each cycle, updating dynamic states and recording simulated output along the way.\nOne important note related to the PEST control and parallel run management: because the template and/or instruction files may vary depending on the cycle number, the PESTPP-DA master instance passes the cycle number to the agents at run time so that the agents know what parameter and observation control file quantities are being used and which template and instruction files are in use. So, it is important that the agents are populated with a control file that lists the same cycles information as the control file that the master is using.\nGiven the complexity of cycle-dependent interface (parameters, observations, template files, instruction files), users may wish to “debug” or test this interface by setting *debug_parse_only* equal to “true” in the control file. With this option, PESTPP-DA will process each listed cycle, checking the parameters and observations against the templates and instruction files to ensure they agree. After this checking, PESTPP-DA will exit.\nNote that comprehensive interface checking is also made during the initialization of each PESTPP-DA analysis if NOPTMAX is not equal to zero because it can be quickest to check the cycles first, rather than start the PESTPP-DA process only to discover a cycle is not defined properly. However, for high dimensional problems, this checking can take significant time. Therefore, users can disable this interface checking by setting *check_tplins* to “false” in the control file.\nThe “cycle” values assigned to the various components in the control file can be assigned as integers or as a string. The string is colon-delimited, zero-based, start-stop-stride quantity. For example, if users want to have the same recharge multiplier parameter applied every March of a monthly-based simulation that simulates several years of time, the cycle value for the march recharge multiplier could be specified as “2::12”, which reads “starting with the 3rd cycle and every 12th cycle through the end of the cycles”. If users wanted a parameter to apply every cycle from the 4th to the 15th, the cycle string value would be “3:16”. A few more examples of string-based cycle values:\n- “::2” – every other cycle starting with the first\n- “1:5:2” - every other cycle from the 2nd up to the 6th\n- “1::3” – every third cycle starting with the 2nd cycle through the end of the cycles\nIn this way, the string-based cycle values allow users to apply sophisticated rules about how parameters and/or observations are used across multiple cycles.",
      "header": "12.2.12 Running PESTPP-DA",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "a264ecd76e04",
      "next_id": "9a878768d62e",
      "summary_self": "PESTPP-DA (like other PEST++ tools, Section 5) restarts using parameter/observation/noise ensemble files and optionally *da_hotstart_cycle*. Version 2 control files are needed for cycle specification; otherwise, it defaults to batch assimilation. NOPTMAX=0 runs one model per cycle; NOPTMAX=-1 runs a prior Monte Carlo analysis.  The master instance passes cycle numbers to agents. *debug_parse_only*=true checks the interface. *check_tplins*=false disables this checking.  Cycle values are integers or colon-delimited strings (start-stop-stride).",
      "summary_prev": "Data assimilation in PESTPP-DA involves: 1) choosing a scheme (sequential or batch); 2) defining assimilation cycles; 3) assigning cycle numbers to parameters, states, and observations; 4) creating template files for parameters/states; 5) creating instruction files for outputs/states; 6) creating template files for other input files; 7) generating prior ensembles (100-500 realizations); 8) generating observation noise ensembles; 9) identifying dynamic states (identical names or \"state_par_link\" column); and 10) considering localization for large datasets/small ensembles.  11) Choose the solution method.",
      "summary_next": "PESTPP-DA's cycle concept facilitates direct predictive hypothesis testing (Moore et al., 2010).  A weight cycle table gradually increases the weight of a prediction (e.g., surface-water/groundwater exchange) across cycles, testing its compatibility with historical observations (Figure 12.XXX).  Maintaining fit while achieving the prediction supports the hypothesis;  this resembles PEST's Pareto mode but uses PESTPP-DA's efficiency.",
      "header_level_1": "12. PESTPP-DA",
      "header_level_2": "12.2 Theory",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "PEST sends messages (pest.mmf) to the model before each run.  The first line (\"forward_model_run\", \"derivative_increment\", or \"external_derivatives\") indicates the run type.  For \"derivative_increment\", the second line specifies the incremented parameter. Subsequent lines list parameter names, values, and status codes (0=adjustable untransformed, 1=adjustable log-transformed, -n=tied to parameter n, -1000000=fixed).  The message file is written to the working directory (or agent directory for Parallel PEST/BEOPEST).",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.71596947718031,
      "normalized_semantic": 0.71596947718031,
      "normalized_keyword": 1.5,
      "combined_score": 1.2647908431540928
    },
    {
      "chunk_id": "82db2179fce5",
      "chunk_index": 1,
      "content": "NOPTMAX\nNOPTMAX, an integer variable, sets the maximum number of iterations that PEST is allowed to undertake on a particular parameter estimation run. If you wish to ensure that PEST termination is triggered by other criteria, more indicative of convergence to an optimal parameter, you should set this variable to a high value such as 50.\nTwo settings for NOPTMAX have special significance however. If NOPTMAX is set to 0, PEST will not estimate parameters, nor even calculate a Jacobian matrix. Instead it will terminate execution after just one model run. This setting can be used to ensure that PEST setup is correct; at the same time, it can be used to compute objective function components and residuals based on initial parameter values provided in the PEST control file.\nIf NOPTMAX is set to -2 PEST will calculate the Jacobian matrix, store it in a JCO file, and then cease execution immediately. This matrix can then be used for linear analysis, and/or for construction of an SVD-assist input dataset.\nSetting NOPTMAX to –1 also instructs PEST to compute the Jacobian matrix. However after doing this, PEST records the same information on its output files as that which it would normally record on completion of an inversion process. This includes composite sensitivities and, if pertinent, post-calibration uncertainty and covariance statistics calculated from parameter sensitivities. It then undertakes a final model run so that model input and output files remaining after PEST execution is complete pertain to parameters values provided in the PEST control file.\nPHIREDSTP and NPHISTP\nPHIREDSTP is a real variable whereas NPHISTP is an integer variable. If, in the course of the parameter estimation process, there have been NPHISTP optimisation iterations for which (Φ - Φmin)/Φ ≤ PHIREDSTP, PEST will consider that the inversion process is at an end.\nFor many cases 0.005 and 4 are suitable values for PHIREDSTP and NPHISTP respectively. However you must be careful not to set NPHISTP too low if the optimal values for some parameters are near or at their upper or lower bounds (as defined by the parameter variables PARLBND and PARUBND discussed below). In this case it is possible that the magnitude of the parameter upgrade vector may be curtailed over one or a number of iterations to ensure that no parameter value overshoots its bound. The result may be smaller reductions in the objective function than would otherwise occur on these iterations. It would be a shame if these reduced reductions were mistaken for the onset of parameter convergence to the optimal set.\nNPHINORED\nIf PEST has failed to lower the objective function over NPHINORED successive iterations, it will terminate execution. NPHINORED is an integer variable; a value of 3 or 4 is often suitable.\nRELPARSTP and NRELPAR\nIf the magnitude of the maximum relative parameter change between iterations is less than RELPARSTP over NRELPAR successive iterations, PEST will cease execution. The relative parameter change between iterations for any parameter is calculated using equation 4.2.4. PEST evaluates this change for all adjustable parameters at the end of all iterations, and determines the relative parameter change with the highest magnitude. If this maximum relative change is less than RELPARSTP, a counter is advanced by one; if it is greater than RELPARSTP, the counter is zeroed. All adjustable parameters, whether they are relative-limited or factor-limited, are involved in the calculation of the maximum relative parameter change. RELPARSTP is a real variable for which a value of 0.005 is often suitable. NRELPAR is an integer variable; a value of 3 or 4 is normally satisfactory.\nPHISTOPTHRESH, LASTRUN and PHIABANDON\nIf PHISTOPTHRESH (a real variable) is set to a positive number, PEST will cease execution if the objective function falls below this value at the end of any iteration. Note that this criterion is applied to the measurement objective function if PEST is run in “regularisation” mode (see chapter 9). Alternatively, if PHISTOPTHRESH is set to zero or a negative number, then it is ignored. An error condition will occur if PHISTOPTHRESH is set to a positive number while PEST is asked to run in “predictive analysis” or “pareto” modes.\nIf supplied, the integer LASTRUN variable must follow the PHISTOPTHRESH variable on the eighth line of the “control data” section of the PEST control file; PHISTOPTHRESH must also then be supplied. If LASTRUN is set to zero, then PEST will not undertake a final model run using optimised parameters upon termination of execution. If it is not set to zero it must be set to one (its default value).\nThe real-valued PHIABANDON variable optionally follows LASTRUN (which must be provided if PHIABANDON is provided). If, at the end of the first model run, and any iteration thereafter, the objective function (or measurement objective function if PEST is run in “regularisation” mode) is greater than PHIABANDON, PEST will terminate execution. Set this to a very high number, or to a non-positive number (or omit it altogether), for it to have no effect.",
      "header": "4.2.9 Eighth Line",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation. User Manual Part I: PEST, SENSAN and Global Optimisers",
      "prev_id": "c130c86cab84",
      "next_id": "421e7b0896aa",
      "summary_self": "NOPTMAX (integer) sets maximum iterations; 0 runs one model; -1 or -2 calculates the Jacobian matrix.  PHIREDSTP (real) and NPHISTP (integer) define convergence criteria based on objective function reduction. NPHINORED (integer) sets iterations without improvement before stopping. RELPARSTP (real) and NRELPAR (integer) use maximum relative parameter change for termination.  PHISTOPTHRESH (real, optional) stops if the objective function is below its value. LASTRUN (integer, optional) controls the final model run; PHIABANDON (real, optional) stops if the objective function exceeds its value.",
      "summary_prev": "BOUNDSCALE (\"boundscale\" or \"noboundscale\") is an optional variable placed on the seventh line of the \"control data\" section, after PHIREDSWH, NOPTSWITCH, and SPLITSWH, and before DOAUI and DOSENREUSE. It may improve inversion efficiency but can have the opposite effect; it's often worth trying.",
      "summary_next": "PHISTOPTHRESH, PHIABANDON, and LASTRUN control null space Monte Carlo.  PHIABANDON (high value or file) stops calibration if the objective function is too high; LASTRUN (0 or 1) controls the final model run.  A PHIABANDON schedule file provides iteration-specific thresholds.  If the objective function exceeds the threshold, the parameter adjustment process is abandoned.",
      "header_level_1": "4. The PEST Control File",
      "header_level_2": "4.2 Control Data Section",
      "header_summary_1": "Figure 4.2 in PEST software displays control data section variables. The text details options for writing matrices, files, and parameters, including settings for matrix and file saving, operational modes, precision, derivative handling, and convergence criteria. Optional features like sensitivity reuse and LSQR algorithm for solving inverse problems are discussed.",
      "header_summary_2": "Figure 4.2 shows \"control data\" section variables (from Appendix A, Figure A1.1).  Some variables are discussed later. The first line must be \"* control data\";  some variables are optional (in brackets).",
      "keywords": [
        "LASTRUN",
        "NOPTMAX",
        "NPHINORED",
        "NPHISTP",
        "NRELPAR",
        "PARLBND",
        "PARUBND",
        "PHIABANDON",
        "PHIREDSTP",
        "PHISTOPTHRESH",
        "RELPARSTP"
      ],
      "similarity": 0.766030998948981,
      "normalized_semantic": 0.766030998948981,
      "normalized_keyword": 1.39999997615814,
      "combined_score": 1.2098092829953924
    },
    {
      "chunk_id": "f1e149007e9e",
      "chunk_index": 1,
      "content": "Parameter values recorded in parameter value files generated by PNULPAR can be PARREPed into a PEST control file. NOPTMAX can be set to zero in this file and the objective function computed in each case. If the model is linear, this objective function should be similar to that achieved during the previous calibration exercise.\nWhere a model is nonlinear, the use of PNULPAR‑generated parameters will probably not result in a calibrated model. In many cases, however, parameter values can be adjusted back into calibration with very little effort, this often requiring only one PEST iteration. (If desired, set NOPTMAX to 1 in the governing PEST control file to ensure that only one iteration actually takes place.) Furthermore, this process can be made even more inexpensive by employing sensitivities residing in an existing JCO file (for example, the same JCO file as that read by PNULPAR). This can be achieved by starting PEST with the “/i” switch and providing the name of the pertinent JCO file when prompted accordingly.\nWhen undertaking a single‑iteration PEST run under these conditions, the following may help.\n1. Set the BROYDEN update parameter JACUPDATE to 999. Thus on the second and further attempts to upgrade parameter values during this single iteration, PEST will have improved the Jacobian matrix on whose basis these upgrades are computed, this resulting (hopefully) in a lower objective function.\n2. Set the PHIRATSUF control variable very low (for example 0.001) and RLAMFAC to ‑4. Thus PEST will be forced to test a number of different Marquardt lambdas before the end of the iteration.\nHopefully, with the help of these strategies, an objective function can then be found which is as low as it can possibly be based on current sensitivities.\nIf the calibration null space is relatively large, then use of SVD‑assist for calibration adjustment of each PNULPAR‑generated parameter set can be achieved with a high level of model run efficiency, even if more than one iteration is required to reduce the objective function to a level at which the model is deemed to be “calibrated”. See section 10.6.3 of part I of this manual for details.\nWhichever of the above methods is chosen to enforce calibration constraints on PNULPAR‑modified parameter sets, the higher that you inform PNULPAR is the dimensionality of the calibration solution space, the less work will be required to enforce these constraints. This is because the higher that PNULPAR believes the dimensions of the calibration solution space to be, the greater is the contribution made by the parameter field calculated during the previous calibration process to each PNULPAR‑generated parameter field. The user‑supplied solution space dimensionality therefore provides a “lever” through which you can increase the efficiency of attainment of parameter fields which respect calibration constraints (as embodied in respect for an objective function that is deemed to “calibrate” the model). The cost of such a speed‑up strategy is, of course, some reduction in the diversity of the calibration‑adjusted random parameter sets thus obtained.",
      "header": "12.7.3 What to do Next",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "f00fef629bff",
      "next_id": "15d6e85d239c",
      "summary_self": "PNULPAR-modified parameter sets can be used in a PEST run (NOPTMAX=0) to calculate objective functions.  For nonlinear models, a single iteration (NOPTMAX=1, using a JCO file with the `/i` switch,  JACUPDATE=999, PHIRATSUF=0.001, RLAMFAC=-4) may suffice.  For large null spaces, use SVD-assist (section 10.6.3, Part I). Increasing the solution space dimensionality increases efficiency but reduces diversity.",
      "summary_prev": "PNULPAR modifies RANDPAR parameter sets to meet calibration constraints. It prompts for a post-calibration PEST control file (with JCO file),  confirmation of calibrated parameters (\"y\" or \"n\"), solution space dimensionality, optional Q<sup>1/2</sup>J matrix storage, input and output filename bases. It then modifies parameter sets based on null-space projection (Equation 12.7.2), preserving tied parameter ratios.  It halts if PESTMODE is not \"estimation\".",
      "summary_next": "RDMULRES reads data from multiple files (e.g., model1.out, model2.out, etc., from a batch file, Figure 12.2, or PEST runs using parval1.par, parval2.par, etc., and pestcase_svda.pst, Figure 12.3).  File names use an indicial integer.  -1.1E35 in model outputs indicates model failure; -1.22E35 indicates an abandoned run. A global record file (record.dat) can track results across multiple PEST runs.",
      "header_level_1": "12. Nonlinear Error and Uncertainty",
      "header_level_2": "12.7 PNULPAR",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "For SVD-assisted inversion in PEST with SVDA_EXTSUPER≠1, use model-provided base parameter derivatives. Set JACFILE=1 and DERCOM=0 for super parameters. External derivatives file must be uncompressed ASCII; JUPITER format and -1.11e33 values not supported. Base parameter JCO file needed for initial super parameter definition. SVDAPREP creates batch files if JACFILE=1.",
      "keywords": [
        "JACUPDATE",
        "NOPTMAX",
        "PHIRATSUF",
        "RLAMFAC",
        "lambdas"
      ],
      "similarity": 0.753125756606375,
      "normalized_semantic": 0.753125756606375,
      "normalized_keyword": 1.39999997615814,
      "combined_score": 1.2059377102926105
    },
    {
      "chunk_id": "4910e03afcfa",
      "chunk_index": 1,
      "content": "PESTPP-MOU is run exactly like all other tools in the PEST++ suite – See section 5 of this manual for how to run the tools in the PEST++ suite. As is described in that section, model runs can be undertaken in series or in parallel. In either case, a prematurely terminated PESTPP-MOU run can be restarted by supplying the requisite decision variable population file.\nAs previously discussed, if NOPTMAX is set to zero, PESTPP-MOU will run the model once using the values listed in the parameter data section of the control file. Furthermore, if NOPTMAX is set to -1, PESTPP-MOU will evaluate the initial decision variable population, and, optionally and chance runs, record outputs and then quit.\nConstraints/objectives are identified in exactly the same way as PESTPP-OPT: via the observation/prior information equation group names. Group names that start with “less_than” are identified as less-than constraints/minimization objectives; group names that start with “greater_than” are identified as greater-than constraints/maximization objectives. The distinction between constraints and objectives is made via the *mou_objectives* argument. Any observation and prior information equation names (not group names) passed via *MOU_OBJECTIVES* are treated as objectives, not constraints. While it may seem tempting to make all constraints objectives, in practice, the algorithm elements encoded in PESTPP-MOU can tolerate up to 5 objectives, and, more realistically, 2-3 objectives may be a better choice.\nDecision variables are distinguished from parameters through the *opt_dec_var_groups* option which lists parameter groups whose members should be treated as decision variables. If this option is not specified, then all adjustable parameters as treated as decision variables. As with the number of objectives, it is important to point out the global evolutionary optimization methods do not scale to high dimensions; a maximum realistic number of decision variables is likely hundreds.",
      "header": "13.2.5 Running PESTPP-MOU",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation: PEST++ a Software Suite for Parameter Estimation, Uncertainty Analysis, Management Optimization and Sensitivity Analysis",
      "prev_id": "8e1a78f2d303",
      "next_id": "05b85a679d12",
      "summary_self": "PESTPP-MOU (like other PEST++ tools, Section 5) runs models serially or in parallel;  restarts use a decision variable population file. NOPTMAX=0 runs the model once; NOPTMAX=-1 evaluates the initial population. Constraints/objectives are defined by group names (\"less_than,\" \"greater_than\") and *mou_objectives*. Decision variables are specified by *opt_dec_var_groups* (defaults to all adjustable parameters);  high dimensionality is not recommended.",
      "summary_prev": "PESTPP-MOU optionally treats risk as an objective (*mou_risk_objective*=true), adding \"\\_risk\\_\" as a decision variable, to explore objective-risk trade-offs.  Self-adaptive differential evolution is automatically activated using decision variables \"\\_DE\\_F\", \"\\_CR\\_\", and/or \"\\_MR\\_\", but requires careful range specification.  This may increase complexity/nonlinearity.",
      "summary_next": "PESTPP-MOU outputs (Table 13.1, case=control file base name, <iter>=iteration number): case.rec (run history), case.rmr (parallel run management), case.log (performance log), case.pareto.summary.csv (Pareto solutions), and current/iteration-specific ensembles (case.chance.obs_pop.csv/jcb, case.chance.dv_pop.csv/jcb, case.obs_pop.csv/jcb, case.dv_pop.csv/jcb, case.<iter>.obs_pop.csv/jcb, case.<iter>.dv_pop.csv/jcb, case.<iter>.chance.obs_pop.csv/jcb, case.<iter>.chance.dv_pop.csv/jcb), and case.lineage.csv.  Files may be CSV or JCB depending on *SAVE_BINARY*.",
      "header_level_1": "13. PESTPP-MOU",
      "header_level_2": "13.2 Theory",
      "header_summary_1": "PPD2ASC converts case.ppd to a textfile with objective function components, model outputs, and parameter values for spreadsheets. PPD2PAR extracts parameters from ppdfile to parfile for PEST utilities, matching objective function values in case.pod and case.par.N. Specific commands are required for each task.",
      "header_summary_2": "PHISTATS reports PEST run objective function information (initial and final, per observation group;  measurement/regularization or prediction/error terms as appropriate) from a run record file (recfile) and loop index (N). It does not work for \"pareto\" mode runs. Use `phistats recfile N`.",
      "keywords": [
        "NOPTMAX"
      ],
      "similarity": 0.749470405327948,
      "normalized_semantic": 0.749470405327948,
      "normalized_keyword": 1.39999997615814,
      "combined_score": 1.2048411049090824
    },
    {
      "chunk_id": "bcf0a20e1744",
      "chunk_index": 1,
      "content": "The steps required to build a DSI model, and to evaluate posterior predictive uncertainties, are now repeated. It is assumed that history‑matching is undertaken using PEST_HP. See the above documentation for use of PESTPP‑IES instead.\n1. Run the real model NREAL times, where NREAL is the number of parameter realisations. Construct a CSV file of model outputs. These outputs include those that\nare used for history matching, and those that comprise model predictions of interest.\n1. Record real‑world observations in a file that mimics the “observation data” section of a PEST control file. (We refer to this type of file as a “partial PEST control file”.) Optionally, include measurement noise standard deviations, as well as weights, in this file.\n2. Run DSI2 to build a surrogate model. Experience suggests that you should request a high singular value energy level (e.g. 0.99999). Consider setting extrapmode to 1 or 2 in response to the pertinent DSI2 prompt if you request Gauss transformation of model outputs; these extrapmode settings generally support better fits between DSI model outputs and field data when calibrating the DSI model than an extrapmode setting if 0.\n3. Use ADDREG2 to add regularisation to the PEST control file that DSI2 builds. Choose an appropriate value for the target measurement objective function. Specify “continue” and “hp” on the ADDREG2 command line.\n4. Calibrate the DSI model using PEST_HP.\n5. Use PARREP to build a new PEST control file in which initial PCA parameter values (i.e. DSI model parameter values) are calibrated values. Set NOPTMAX to 0 in this new PEST control file.\n6. Run PEST using the “/hpstart” switch; PEST runs the model once. Plot model outputs using information contained in the run record (i.e. REC) or residuals (i.e. RES) file that PEST writes. If there are too many “bumps and lumps” in these DSI model outputs, then go back to step 4 in order to set a higher value for the PHIMLIM target measurement objective function. Or perhaps return to step 3 and set extrapmode to 0 when running DSI2 if DSI model outputs are completely unacceptable.\n7. Once the DSI model has been successfully calibrated, and a PEST control file has been built using calibrated parameter values as initial values, and PEST has been invoked to run the calibrated DSI model, run POSTDSIMOD to obtain posterior predictive uncertainty intervals. Set extrapmode to 0 when running POSTDSIMOD if outer uncertainty limits are unacceptably bumpy or transgress physical limits.\n10.3.11 Other Options\nAs is stated above, if Gaussian transformation is undertaken, then the DSI model is nonlinear. This does not prevent the undertaking of more traditional linear analysis than that described above. However the results will be approximate.\nTo prepare for this analysis, a Jacobian matrix should be calculated for the calibrated DSI model. Using the example presented above, this requires that NOPTMAX be set to ‑1 or ‑2 when running case_soln.pst. (Recall that this PARREP‑constructed PEST control file contains calibrated DSI model parameter values.)\nOnce a Jacobian matrix has been obtained (this takes no time at all), linear analysis can be used to calculate quantities such as the following:\n- optimum number of singular values to use (PREDVAR1);\n- solution and null space contributions to the uncertainty of a prediction (PREDVAR1);\n- a linear approximation to the uncertainty of any prediction (JROW2VEC and PREDUNC1);\n- observation worth (PREDUNC5);\n- a posterior PCA‑parameter covariance matrix (PREDUNC7).\nAs an alternative to using these utilities one after another, they can be run sequentially and\nautomatically under the control of GENLINPRED to perform a number of pre‑set tasks. For all of the above tasks, the prior covariance matrix of PCA parameters are contained in a file that was written by DSI2; this has an extension of “.unc”. The posterior PCA parameter covariance matrix can be sampled using RANDPAR, RANDPAR1, RANDPAR2, RANDPAR3 or RANDPAR4. The DSIMOD model can then be run using all of these samples (using PEST_HP, PESTPP‑SWP or PESTPP‑IES). This will enable sampling of a linear approximation to the posterior probability distribution of any desired model prediction.\nPEST’s predictive analyser can be used to maximize/minimize the value of a prediction of interest subject to history‑matching constraints. Setup for this operation is facilitated using the ADDPRED1 utility. This utility is now discussed.",
      "header": "18.3.10 Workflow Summary",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "86223817565b",
      "next_id": "2e63481ddc5e",
      "summary_self": "To perform posterior predictive uncertainty analysis using PEST_HP: 1) run the model NREAL times, creating a CSV file; 2) create a partial PEST control file (with optional standard deviations); 3) run DSI2 (high singular value energy level, consider extrapmode 1 or 2); 4) add regularization (ADDREG2, target, continue, hp); 5) calibrate using PEST_HP; 6) create a new control file with calibrated values (PARREP, NOPTMAX=0); 7) run PEST (`/hpstart`); 8) run POSTDSIMOD (extrapmode=0 for better results).  Linear analysis (using Jacobian matrix from a run with NOPTMAX=-1 or -2) is an alternative.",
      "summary_prev": "POSTDSIMOD calculates posterior predictive uncertainty intervals;  extrapmode=0 prevents exceeding model output ranges. It uses either user-supplied standard deviations or inverse weights from the DSI2 control file for uncertainty calculations. Equation C′(x) = [Z<sup>T</sup>C(ε)⁻¹Z + C(x)⁻¹]⁻¹ calculates the posterior covariance matrix of PCA parameters; σ'²=y<sup>T</sup>C′(x)y calculates prediction uncertainty variance.",
      "summary_next": "ADDPRED1 modifies a PEST control file, setting PESTMODE to \"predictive analysis\", adding a \"predictive analysis\" section, and adding prior information equations (parameter initial values). It checks that the prediction (in the \"predict\" group) has a weight of zero in the input file, otherwise it halts with an error message.  The prediction must already exist in the input file.",
      "header_level_1": "18. Data Space Inversion",
      "header_level_2": "18.3 DSI2, DSIMOD and POSTDSIMOD",
      "header_summary_1": "The text describes using soil clod shrinkage data to fit two straight lines using Equation 18.1.1 with parameters s1, s2, y1, and xc in the pestex subfolder. The TWOLINE program reads parameters and water contents from in.dat, adjusts parameters using PEST, and generates input files for calculations. The final prediction value is 0.786.",
      "header_summary_2": "DSI2 creates files for data space inversion using PESTPP-IES or PEST_HP, computing an empirical covariance matrix from a CSV file of model outputs. It uses a PEST control file's weights for observations, creating a new control file for history-matching. Posterior predictive uncertainty analysis with PEST_HP involves multiple steps, including running the model NREAL times and calibrating with regularization. Linear analysis is an alternative method.",
      "keywords": [
        "NOPTMAX",
        "PHIMLIM"
      ],
      "similarity": 0.712140058023928,
      "normalized_semantic": 0.712140058023928,
      "normalized_keyword": 1.39999997615814,
      "combined_score": 1.1936420007178765
    },
    {
      "chunk_id": "c0a8e6ba741f",
      "chunk_index": 1,
      "content": "The following aspects of the input dataset written by REGPRED should be carefully noted.\n1. If, in the original PEST control file whose name is supplied to REGPRED, there is an observation group named “predict”, and if it contains more than one member, REGPRED will cease execution with an appropriate error message. Alternatively, if there is such a group and it contains only one member, REGPRED will prompt (as discussed above) for permission to treat this one member as the prediction whose task it is for PEST to maximise/minimise in the forthcoming predictive analysis process. If you do not want this, REGPRED will ask you to assign that observation to another.\nobservation group. If there is no observation group named “predict” in the original PEST control file REGPRED will create one. It is then your task to add an actual prediction to this PEST control file. A new instruction file (or an alteration made to an existing one) will also be required in order to provide PEST with the means to read this new prediction from the model output dataset. REGPRED issues a warning to this effect before finishing execution.\n1. As discussed above, observation and prior information weights are not transferred from the original PEST control file to the new one. Rather observation weights are assigned on the basis of observation uncertainties as supplied to REGPRED through an observation uncertainty file. However if any observation or prior information equation is assigned a weight of zero in the original PEST control file, it will also be assigned a weight of zero in the new PEST control file as this is taken as an indication that the user is not interested in this observation.\n2. All regularisation observations and prior information equations are eliminated from the new PEST control file written by REGPRED. On many occasions of PEST usage regularisation constraints are limited solely to prior information. The elimination of these prior information equations from the new PEST control file has no adverse consequences. However where observations, rather than prior information equations, are eliminated from the PEST control file because they belong to a regularisation group, pertinent instruction files comprising the PEST input dataset need to be deleted or modified. It is your responsibility to undertake this task. (REGPRED reminds you of this before ceasing execution).\n3. If a “singular value decomposition” section exists in the original PEST control file, it is removed.\n4. Irrespective of the NOPTMAX (current number of iterations) setting in the original PEST control file, a NOPTMAX setting of 50 is provided to the new PEST control file. (This can prevent you from being severely disappointed if, on returning to your computer the morning after setting up PEST to run all night, you find that PEST has run the model only once in order to calculate the objective function, or that PEST ran for only one iteration in order to calculate parameter sensitivities because you forgot to alter the NOPTMAX setting.)\n5. Predictive analysis control variables written to the “predictive analysis” section of the new PEST control file by REGPRED are conservative. A line search is instigated, the control variables for this line search being such as to sample the line densely enough to detect the existence of a possible fall in the objective function followed by a rise before intersection of the PD0 contour. Also, convergence criteria are tight. If these settings are not suitable, you should alter them yourself.\nWhen PEST is run on the basis of the new PEST control file (it may be necessary to add the prediction to this file first as discussed above) the initial objective function should be zero. There may be an occasion or two when PEST will cease execution after the first iteration, saying that the “phi gradient is zero”. If this is the case, perturb the initial value of one of the parameters by a slight amount and re‑commence PEST execution.",
      "header": "12.12.5 Some Notes",
      "level": 3,
      "file_name": "PEST Model-Independent Parameter Estimation User Manual Part II: PEST Utility Support Software",
      "prev_id": "e0a723324bbb",
      "next_id": "ec39245ac93b",
      "summary_self": "REGPRED creates a predictive analysis PEST control file.  It prompts for a PEST control file (with optimized parameters/outputs) and requires a resolution or SVD matrix. It removes regularization information, sets NOPTMAX=50, and uses conservative predictive analysis settings.  It checks for a \"predict\" group (one observation only), otherwise prompts the user to add one.  Observation weights are assigned based on uncertainty; zero-weighted observations remain zero-weighted.",
      "summary_prev": "REGPRED modifies the model (assumed \".bat\" extension), adding commands to compute g (Equation 12.12.9), using  par###.tpl/par###.mat, parlog###.mat, partran###.mat (created by REGPRED), MATDIFF, and MATPROD (creating projdiff###.mat, read by proj###.ins).  g elements are added as observations (\"projdiff\" group, using C(g)) to the new PEST control file.  VECLOG, MATDIFF, and MATPROD executables must be accessible.",
      "summary_next": "To generate an SVD file for REGPRED,  modify the PEST control file: set NUMLAM=1, RLAMBDA1=0, remove regularization (SUBREG1), add an \"SVD\" section (EIGWRITE=1), set NOPTMAX=1, create a new JCO file (JCO2JCO), and run PEST using the `/i` switch (supplying the new JCO filename).  This generates an SVD file containing the V matrix.",
      "header_level_1": "12. Nonlinear Error and Uncertainty",
      "header_level_2": "12.12 REGPRED",
      "header_summary_1": "PEST uses pest.mmf to send messages before each run, indicating run type and parameter details. Different commands can be used for regular and derivative-calculating model runs, potentially reducing run time. Models can provide PEST with derivatives more efficiently, supporting various file formats. PEST control file variables manage model commands, messaging, and external derivatives.",
      "header_summary_2": "REGPRED is an older utility for predictive uncertainty analysis, requiring a prior regularized inversion. It uses a predictive approach considering calibration data and expert knowledge. Less efficient than Monte Carlo methods, it sets up PEST predictive runs, calculating null-space deviations and constraints for parameter realism. It prompts for solution space dimensions and requires an optimized PEST control file with calibrated parameters and model outputs.",
      "keywords": [
        "NOPTMAX",
        "PD0"
      ],
      "similarity": 0.723788565686091,
      "normalized_semantic": 0.723788565686091,
      "normalized_keyword": 1.30000007152557,
      "combined_score": 1.1271366197737263
    }
  ]
}